// Устанавливаются снаружи
Перем мКонфигурация Экспорт;

Перем мСтараяСтраницаПанелиЧасти Экспорт;
Перем мСтараяСтраницаПанелиОсновная Экспорт;
Перем мТекущаяСтрокаСвязи;
Перем мТекущаяСтрокаУсловияСвязи;
Перем мТекущаяСтрокаВыбранногоПоля;
Перем мТекущаяСтрокаУсловия;
Перем мТекущаяСтрокаПараметраТаблицы;
Перем мТекущаяСтрокаЧастиОбъединения;
Перем мТекущаяСтрокаЗапросыПакета;
Перем мТекущаяСтрокаВыбранныеТаблицы;
Перем мТекущаяСтрокаГруппируемогоПоля;
Перем мТекущееИмяОсновнойТаблицы;
Перем мТекущееИмяВыбраннойТаблицы;
Перем мТекущееИмяПараметра;
Перем мТекущееИмяДоступнойТаблицы;
Перем мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей;
Перем мЧислоСтатическихКолонокТППоляПсевдонимовПолей;
Перем мРежимРедактированияТекста Экспорт;
Перем мТерминалыЯзыкаЗапросов Экспорт;
Перем ПараметрыДиалектаSQL;
Перем мСтрокаНачальногоЗапроса;
Перем мСтрокаНачальнойЧастиОбъединения;
Перем мРазборПоследнийТокенРазделитель;
Перем мРазборИндексПринимающегоПоля; // Используется при разборе текста запроса для INSERT

//Перем СлужебноеПолеТекстовогоДокумента2 Экспорт;

// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
Перем ПолеТекстовогоДокументаСКонтекстнойПодсказкой Экспорт;
// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой

// @@@.КЛАСС.ПолеТекстоввогоДокументаСКонтекстнойПодсказкой
// Транслятор обработки событий нажатия на кнопки командной панели в компоненту.
//
// Параметры:
//  Кнопка       – КнопкаКоманднойПанели.
//
Процедура КлсПолеТекстовогоДокументаСКонтекстнойПодсказкойНажатие(Кнопка)
	
	// Специальная обработка команд компоненты ДО
	ЭкземплярКомпоненты = ПолучитьТекущуюКомпонентуКонтекстнойПодсказки(Кнопка);
	Если ЭкземплярКомпоненты <> Неопределено Тогда
		Результат = ЭкземплярКомпоненты.Нажатие(Кнопка);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьТекущуюКомпонентуКонтекстнойПодсказки(Кнопка = Неопределено)

	Если ПолеТекстовогоДокументаСКонтекстнойПодсказкой.Свойство(ТекущийЭлемент.Имя) Тогда
		ЭкземплярКомпоненты = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ТекущийЭлемент.Имя];
	КонецЕсли;
	Возврат ЭкземплярКомпоненты;

КонецФункции

////////////////////////////

Процедура УстановитьДанные(НачальныйТокен = Неопределено, ТаблицаКомментариев = Неопределено, БылиПотери = Неопределено,
	ПринудительноПерезаполнитьДоступныеТаблицы = Истина) Экспорт
	
	Если Ложь
		Или ПринудительноПерезаполнитьДоступныеТаблицы
		Или ДоступныеТаблицы.Количество() = 0
	Тогда
		ЗаполнитьДоступныеТаблицы();
	КонецЕсли;
	мСтрокаНачальногоЗапроса = Неопределено;
	мСтрокаНачальнойЧастиОбъединения = Неопределено;
	Если ЗапросыПакета.Количество() > 0 Тогда 
		СортироватьДоступныеТаблицы();
		Возврат;
	КонецЕсли; 
	Состояние("Анализ дерева запроса...");
	ОчиститьДанные();
	ЭтаФорма.ТабличноеПолеКорневогоПакета = ЭлементыФормы.ЗапросыПакета;
	Если БылиПотери = Неопределено Тогда
		БылиПотери = Ложь;
	КонецЕсли; 
	Если НачальныйТокен = Неопределено Тогда
		ЗапросПакета = ДобавитьЗапросПакета();
		ДобавитьЧастьОбъединения(ЗапросПакета);
	Иначе
		мРазборИндексПринимающегоПоля = 0;
		ЗаполнитьПоТокену(НачальныйТокен,,,,,, ТаблицаКомментариев);
		БылиПотери = СообщитьОНеразобранныхКомментариях(ТаблицаКомментариев) Или БылиПотери;
	КонецЕсли;
	БылиПотери = ОбработатьРасширениеЯзыкаЗапросов() Или БылиПотери;
	СортироватьДоступныеТаблицы();
	Если БылиПотери Тогда
		Предупреждение("При разборе текста некоторые фрагменты были проигнорированы! Подробнее смотри в окне сообщений.");
	КонецЕсли; 
	ОбновитьРежимПакетногоЗапроса();
	Если мСтрокаНачальногоЗапроса <> Неопределено Тогда
		ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = мСтрокаНачальногоЗапроса;
		Если мСтрокаНачальнойЧастиОбъединения <> Неопределено Тогда
			ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = мСтрокаНачальнойЧастиОбъединения;
		КонецЕсли; 
	КонецЕсли; 
	Состояние();
	
КонецПроцедуры

Процедура СортироватьДоступныеТаблицы()
	
	ДоступныеТаблицы.Сортировать("Имя, Схема, Тип");

КонецПроцедуры

Процедура ЗаполнитьДоступныеТаблицы()
	
	Если ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
		ЗаполнитьДоступныеТаблицыWQL();
	ИначеЕсли ирОбщий.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
		ЗаполнитьДоступныеТаблицы1С();
	Иначе
		ЗаполнитьДоступныеТаблицыADO();
		КопияТаблицы = ДоступныеТаблицы.Выгрузить(, "Тип");
		КопияТаблицы.Свернуть("Тип");
		ЭлементыФормы.ДоступныеТаблицы.Колонки.Тип.Видимость = КопияТаблицы.Количество() > 1;
	КонецЕсли;

КонецПроцедуры

Функция ОбновитьРежимПакетногоЗапроса()

	ЭтаФорма.ЛиПакетныйЗапрос = ЗапросыПакета.Количество() > 1;
	Если ЭтаФорма.Открыта() Тогда
		ИзменитьСвернутостьПанельПакета(ЛиПакетныйЗапрос);
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

// Результат - имелись ли потери при разборе текста
Функция ОбработатьРасширениеЯзыкаЗапросов()
	
	ТекстПакета = СобратьСлужебныйТекстПакетаПостроителя();
	Если ТекстПакета <> "" Тогда
		ТаблицаКомментариев = Неопределено;
		СтартовыйТокен = РазобратьТекстЗапроса(ТекстПакета,,, Null,, ТаблицаКомментариев);
		Если СтартовыйТокен = Неопределено Тогда
			ВызватьИсключение "Ошибка разбора текста промежуточного запроса";
		КонецЕсли; 
		СлужебноеПолеТекстовогоДокумента.УстановитьТекст(ТекстПакета);
		ЗаполнитьПоТокену(СтартовыйТокен,,,,, Истина, ТаблицаКомментариев);
		Результат = СообщитьОНеразобранныхКомментариях(ТаблицаКомментариев);
	Иначе
		Результат = Ложь;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Результат - имелись ли потери при разборе текста
Функция СообщитьОНеразобранныхКомментариях(ТаблицаКомментариев) Экспорт
	
	Для Каждого СтрокаРасширения Из ТаблицаКомментариев Цикл
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Проигнорирован комментарий """ + СокрЛП(СтрокаРасширения.Текст) + """", , СтатусСообщения.Внимание);
	КонецЦикла;
	Результат = ТаблицаКомментариев.Количество() > 0;
	Возврат Результат;
	
КонецФункции

Функция СобратьСлужебныйТекстПакетаПостроителя(пЗапросыПакета = Неопределено)

	Если пЗапросыПакета = Неопределено Тогда
		пЗапросыПакета = ЗапросыПакета;
	КонецЕсли; 
	ТекстПакета = "";
	Для ИндексЗапроса = 0 По пЗапросыПакета.Количество() - 1 Цикл
		ЗапросПакета = пЗапросыПакета[ИндексЗапроса];
		ТекстЗапросаПакета = "";
		Для ИндексЧасти = 0 По ЗапросПакета.ЧастиОбъединения.Количество() - 1 Цикл
			ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[ИндексЧасти];
			ТекстЧастиОбъединения = ЧастьОбъединения.ТекстРасширения;
			Для Каждого СтрокаВложенногоЗапроса Из ЧастьОбъединения.ВыбранныеТаблицы.НайтиСтроки(Новый Структура("ПолноеИмя", "")) Цикл
				ТекстВложенногоЗапроса = СобратьСлужебныйТекстПакетаПостроителя(СтрокаВложенногоЗапроса.ВложенныйПакет);
				Если ЗначениеЗаполнено(ТекстВложенногоЗапроса) Тогда
					ТекстЧастиОбъединения = ТекстЧастиОбъединения + "
					|#EmbeddedQuery " + XMLСтрока(ЧастьОбъединения.ВыбранныеТаблицы.Индекс(СтрокаВложенногоЗапроса)) + "
					|(" + ТекстВложенногоЗапроса + ")";
				КонецЕсли; 
			КонецЦикла;
			Если ЗначениеЗаполнено(ТекстЧастиОбъединения) Тогда
				ТекстЗапросаПакета = ТекстЗапросаПакета + "
				|#UnionPart " + XMLСтрока(ИндексЧасти) + "
				|" + ТекстЧастиОбъединения;
			КонецЕсли; 
		КонецЦикла;
		ТекстЗапросаПакета = ТекстЗапросаПакета + "
			|" + ЗапросПакета.ТекстРасширения;
		Если ЗначениеЗаполнено(ТекстЗапросаПакета) Тогда
			Если пЗапросыПакета = ЗапросыПакета Тогда // Пакет
				Если ТекстПакета <> "" Тогда
					ТекстПакета = ТекстПакета + ";";
				КонецЕсли; 
				ТекстПакета = ТекстПакета + "#Root " + XMLСтрока(ИндексЗапроса) + ТекстЗапросаПакета;
			Иначе
				ТекстПакета = ТекстПакета + ТекстЗапросаПакета;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Возврат ТекстПакета;

КонецФункции

Функция НайтиДобавитьВыбраннуюТаблицуВСвязи(СтрокаВыбраннойТаблицы, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	СвязьТаблицы = ЧастьОбъединения.СвязиТаблиц.Строки.Найти(СтрокаВыбраннойТаблицы.Имя, "Таблица", Истина);
	Если СвязьТаблицы = Неопределено Тогда
		СвязьТаблицы = ЧастьОбъединения.СвязиТаблиц.Строки.Добавить();
		СвязьТаблицы.Таблица = СтрокаВыбраннойТаблицы.Имя;
	КонецЕсли; 
	Возврат СвязьТаблицы;

КонецФункции // НайтиДобавитьВыбраннуюТаблицуВСвязи()
 
Процедура ОбработатьЗапросПослеУстановкиДанных(ЗапросПакета)
	
	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	Если Истина
		И ЗапросПакета.ТипЗапроса <> 2 // DROP 
		И ЗапросПакета.ТипЗапроса <> 3 // INSERT 
		И ЗапросПакета.ТипЗапроса <> 6 // TRUNCATE
	Тогда
		ПерваяЧасть = ЗапросПакета.ЧастиОбъединения[0];
		Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
			ОбновитьНаименованиеЧасти(ЧастьОбъединения);
			Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
				Если СтрокаВыбраннойТаблицы.ВложенныйПакет = Неопределено Тогда
					НайтиДобавитьДоступнуюВременнуюТаблицу(СтрокаВыбраннойТаблицы.ПолноеИмя);
				КонецЕсли; 
				НайтиДобавитьВыбраннуюТаблицуВСвязи(СтрокаВыбраннойТаблицы, ЧастьОбъединения);
				//ПолучитьИмяВыбраннойТаблицы(СтрокаВыбраннойТаблицы);
			КонецЦикла;
			ГруппировкиСПустымКомментарием = ЧастьОбъединения.Группировки.НайтиСтроки(Новый Структура("Комментарий", ""));
			ЕстьГруппировка = Ложь
				Или ЧастьОбъединения.ВыбранныеПоля.Найти(Истина, "ЕстьАгрегаты") <> Неопределено
				Или ЧастьОбъединения.Группировки.Количество() > 0;
			ЧастьОбъединения.Автогруппировки = ГруппировкиСПустымКомментарием.Количество() = ЧастьОбъединения.Группировки.Количество();
			КоличествоОдинаковыхПолейИГруппировок = 0;
			ИндексВыбранногоПоля = 0;
			ОбновитьКомпоновщик = Ложь;
			ВыбранныеЗвездочкамиТаблицы = Новый ТаблицаЗначений();
			ВыбранныеЗвездочкамиТаблицы.Колонки.Добавить("ВыбраннаяТаблица");
			ВыбранныеЗвездочкамиТаблицы.Колонки.Добавить("Позиция");
			Пока ИндексВыбранногоПоля < ЧастьОбъединения.ВыбранныеПоля.Количество() Цикл
				ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[ИндексВыбранногоПоля];
				ИмяПоля = ирОбщий.ПолучитьПоследнийФрагментЛкс(ВыбранноеПоле.Определение);
				Если ИмяПоля = "*" Тогда
					ИмяТаблицы = Лев(ВыбранноеПоле.Определение, СтрДлина(ВыбранноеПоле.Определение) - 2);
					ЧастьОбъединения.ВыбранныеПоля.Удалить(ИндексВыбранногоПоля);
					Если ИмяТаблицы = "" Тогда
						//ИмяТаблицы = ЧастьОбъединения.ВыбранныеТаблицы[0].Имя;
						Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
							СтрокаВыбраннойЗвездочкойТаблицы = ВыбранныеЗвездочкамиТаблицы.Добавить();
							СтрокаВыбраннойЗвездочкойТаблицы.ВыбраннаяТаблица = ВыбраннаяТаблица;
							СтрокаВыбраннойЗвездочкойТаблицы.Позиция = ИндексВыбранногоПоля;
						КонецЦикла;
					Иначе
						СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяТаблицы), "НИмя");
						Если СтрокаВыбраннойТаблицы = Неопределено Тогда
							СтрокаВыбраннойТаблицы = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
							СтрокаВыбраннойТаблицы.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы,  ИмяТаблицы);
							СтрокаВыбраннойТаблицы.ПолноеИмя = ИмяТаблицы;
							СтрокаВыбраннойТаблицы.Обязательная = Истина;
							ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбраннойТаблицы);
							ОбновитьКомпоновщик = Истина;
						КонецЕсли; 
						СтрокаВыбраннойЗвездочкойТаблицы = ВыбранныеЗвездочкамиТаблицы.Добавить();
						СтрокаВыбраннойЗвездочкойТаблицы.ВыбраннаяТаблица = СтрокаВыбраннойТаблицы;
						СтрокаВыбраннойЗвездочкойТаблицы.Позиция = ИндексВыбранногоПоля;
					КонецЕсли; 
					ИндексВыбранногоПоля = ИндексВыбранногоПоля - 1;
				Иначе
					Если ПерваяЧасть = ЧастьОбъединения Тогда
						Если ЗапросПакета.ТипЗапроса = 3 Тогда // INSERT
							ВыбранноеПоле.Имя = ЗапросПакета.ПринимающиеПоля[ИндексВыбранногоПоля].Поля;
						КонецЕсли; 
						Если Не ЗначениеЗаполнено(ВыбранноеПоле.Имя) Тогда
							ВыбранноеПоле.Имя = ПолучитьАвтоПсевдонимПоля(ВыбранноеПоле, ЧастьОбъединения);
						КонецЕсли;
					КонецЕсли;
					Если Истина
						И ЕстьГруппировка
						И ЧастьОбъединения.Автогруппировки 
					Тогда
						Группировка = Неопределено;
						Если Не ВыбранноеПоле.ЕстьАгрегаты Тогда
							Группировка = ЧастьОбъединения.Группировки.Найти(ВыбранноеПоле.Определение, "Определение"); // Регистр!
						КонецЕсли; 
						Если Ложь
							Или (Истина
								И ВыбранноеПоле.ЕстьАгрегаты
								И ВыбранноеПоле.АгрегатнаяФункция = "" // Иначе выражение одновременно с агрегатами и обычными полями не будут выключать автогруппировку
								//И Группировка <> Неопределено // Видимо некорректный код
							)
							Или (Истина
								И Не ВыбранноеПоле.ЕстьАгрегаты 
								И Группировка = Неопределено)
						Тогда
							ЧастьОбъединения.Автогруппировки = Ложь;
						ИначеЕсли Не ВыбранноеПоле.ЕстьАгрегаты Тогда 
							КоличествоОдинаковыхПолейИГруппировок = КоличествоОдинаковыхПолейИГруппировок + 1;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
				ИндексВыбранногоПоля = ИндексВыбранногоПоля + 1;
			КонецЦикла;
			Если Истина
				И ЧастьОбъединения.Автогруппировки
				И ЕстьГруппировка
				И (Ложь
					Или КоличествоОдинаковыхПолейИГруппировок <> ЧастьОбъединения.ВыбранныеПоля.НайтиСтроки(Новый Структура("ЕстьАгрегаты", Ложь)).Количество()
					Или КоличествоОдинаковыхПолейИГруппировок <> ЧастьОбъединения.Группировки.Количество())
			Тогда
				ЧастьОбъединения.Автогруппировки = Ложь;
			КонецЕсли;
			//Если ОбновитьКомпоновщик Или ВыбранныеЗвездочкамиТаблицы.Количество() > 0 Тогда
				ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения, Ложь);
			//КонецЕсли;
			Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
				ВыбранноеПоле.ТипЗначения = ПолучитьТипЗначенияВыражения(ВыбранноеПоле.Токен, ЧастьОбъединения);
			КонецЦикла;
			Для ИндексТаблицыИзЗвездочки = 1 По ВыбранныеЗвездочкамиТаблицы.Количество() Цикл
				СтрокаВыбраннойЗвездочкойТаблицы = ВыбранныеЗвездочкамиТаблицы[ВыбранныеЗвездочкамиТаблицы.Количество() - ИндексТаблицыИзЗвездочки];
				ВыбраннаяТаблица = СтрокаВыбраннойЗвездочкойТаблицы.ВыбраннаяТаблица;
				ВыбраннаяТаблица.ВсеПоля = Истина;
				КоличествоВыбранныхПолей = ЧастьОбъединения.ВыбранныеПоля.Количество();
				СдвигИндексаПослеДобавления = 0;
				Если КоличествоВыбранныхПолей > 0 Тогда
					СдвигИндексаПослеДобавления = -(КоличествоВыбранныхПолей - СтрокаВыбраннойЗвездочкойТаблицы.Позиция);
				КонецЕсли; 
				ДобавитьВсеПоляТаблицыВВыбранныеПоля(ВыбраннаяТаблица.Имя, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления);
			КонецЦикла;
			Если ПерваяЧасть <> ЧастьОбъединения Тогда
				Для ИндексВыбранногоПоля = 0 По ЧастьОбъединения.ВыбранныеПоля.Количество() - 1 Цикл
					ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[ИндексВыбранногоПоля];
					Если ПерваяЧасть.ВыбранныеПоля.Количество() = ИндексВыбранногоПоля Тогда
						Если Не ЗначениеЗаполнено(ВыбранноеПоле.Имя) Тогда
							ВыбранноеПоле.Имя = ПолучитьАвтоПсевдонимПоля(ВыбранноеПоле, ЧастьОбъединения);
						КонецЕсли; 
						ВыбранноеПолеПервойЧасти = ПерваяЧасть.ВыбранныеПоля.Добавить();
						ВыбранноеПолеПервойЧасти.ИД = Новый УникальныйИдентификатор;
						ВыбранноеПолеПервойЧасти.Определение = "NULL";
						ВыбранноеПолеПервойЧасти.Имя = ВыбранноеПоле.Имя;
					Иначе
						ВыбранноеПоле.Имя = ПерваяЧасть.ВыбранныеПоля[ИндексВыбранногоПоля].Имя;
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
		КонецЦикла;
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
		ОбновитьНаименованиеЗапроса(ЗапросПакета);
	КонецЕсли; 
	
КонецПроцедуры

Функция ДобавитьВсеПоляТаблицыВВыбранныеПоля(ИмяТаблицы, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0,
	КонтролироватьУникальность = Ложь)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
		ДоступноеПолеКомпоновщика = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы.Найти(ИмяТаблицы);
	Иначе
		ДоступноеПолеКомпоновщика = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора;
	КонецЕсли; 
	Если ДоступноеПолеКомпоновщика <> Неопределено Тогда
		ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(ДоступноеПолеКомпоновщика, Истина, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
			КонтролироватьУникальность);
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

//
// Индикатор - Неопределено - автоиндикатор, можно передать Null для блокировки автосоздания индикатора
Функция ЗаполнитьПоТокену(Знач Токен, Стек = Неопределено, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено, Индикатор = Неопределено,
	РазборРасширений = Ложь, ТаблицаКомментариев = Неопределено, Знач ТекущаяСвязьТаблиц = Неопределено) Экспорт
	
	Данные = Токен.Data;
	Если Ложь
		Или Данные = Неопределено 
		//Или Данные.TokenCount = 0 // так делать нельзя, т.к. пустые позиции будут пропускаться, например параметры вирт. таблиц
	Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Стек = Неопределено Тогда
		Стек = Новый Массив();
	КонецЕсли;
	Если Индикатор = Неопределено Тогда
		ИндикаторБылСоздан = Истина;
		Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(, "Структура запроса");
	КонецЕсли;
	Если Индикатор <> Null Тогда
		ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
	КонецЕсли; 
	Результат = Неопределено;
	ИмяПравила = Данные.RuleText();
	Стек.Вставить(0, ИмяПравила);
	КоличествоДочерних = Данные.TokenCount;
	Если ИмяПравила = "<EmbeddedQuery>" Тогда
		ВложенныйПакет = ЗапросыПакета.СкопироватьКолонки();
		ВложенныйЗапрос = ДобавитьЗапросПакета(ВложенныйПакет);
		ДобавленЗапрос = Истина;
		ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		//Если ТекущийУзел.Параметры <> Неопределено Тогда
		//	ВызватьИсключение "Неверный тип выбранной таблицы для вложенного запроса";
		//КонецЕсли; 
		ТекущийУзел.ВложенныйПакет = ВложенныйПакет;
		ЗаполнитьПоТокену(Токен.Data.Tokens(1),, ВложенныйЗапрос,, Индикатор, РазборРасширений, ТаблицаКомментариев);
	ИначеЕсли ИмяПравила = "<ExtEmbeddedQuery>" Тогда
		ИндексВложенногоЗапроса = Данные.Tokens(1).Data;
		ИндексВложенногоЗапроса = Число(ИндексВложенногоЗапроса);
		ВложенныйПакет = ЧастьОбъединения.ВыбранныеТаблицы[ИндексВложенногоЗапроса].ВложенныйПакет;
		ЗаполнитьПоТокену(Данные.Tokens(3), , ВложенныйПакет[0],, Индикатор, РазборРасширений, ТаблицаКомментариев);
	ИначеЕсли ИмяПравила = "<Join>" Тогда
		Если ТекущаяСвязьТаблиц = Неопределено Тогда
			ТекущаяСвязьТаблиц = ЧастьОбъединения.СвязиТаблиц;
		КонецЕсли; 
		ЛевыйУзел = ЗаполнитьПоТокену(Данные.Tokens(0).Data.Tokens(0), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаКомментариев, ТекущаяСвязьТаблиц); //<TableOrJoin>.<TableWithName>
		Если ЛевыйУзел = "FixedTables" Тогда // 02.12.2015
			ТекущаяСвязьТаблиц = ТекущаяСвязьТаблиц.Строки[0];
		ИначеЕсли ТипЗнч(ЛевыйУзел) = Тип("Строка") Тогда
			ТекущаяСвязьТаблиц = ТекущаяСвязьТаблиц.Строки.Добавить();
			ТекущаяСвязьТаблиц.Таблица = ЛевыйУзел;
		Иначе
			ТекущаяСвязьТаблиц = ЛевыйУзел;
		КонецЕсли; 
		ПравыйУзел = ЗаполнитьПоТокену(Данные.Tokens(3).Data.Tokens(0), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаКомментариев, ТекущаяСвязьТаблиц); //<TableOrJoin>.<TableWithName>
		Если ТипЗнч(ПравыйУзел) = Тип("Строка") Тогда
			ТекущаяСвязьТаблиц = ТекущаяСвязьТаблиц.Строки.Добавить();
			ТекущаяСвязьТаблиц.Таблица = ПравыйУзел;
		Иначе
			ТекущаяСвязьТаблиц = ПравыйУзел;
		КонецЕсли; 
		ТипCOMОбъекта = Данные.Tokens(1).Data; //"<JoinType>"
		Если ТипCOMОбъекта.TokenCount > 0 Тогда
			ТипCOMОбъекта = ТипCOMОбъекта.Tokens(0).Name;
		Иначе
			ТипCOMОбъекта = Неопределено;
		КонецЕсли; 
		Если Ложь
			Или ТипCOMОбъекта = "LEFT"
			Или ТипCOMОбъекта = "LEFT OUTER"
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "LEFT";
		ИначеЕсли Ложь
			Или ТипCOMОбъекта = "RIGHT"
			Или ТипCOMОбъекта = "RIGHT OUTER"
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "RIGHT";
		ИначеЕсли Ложь
			//Или ТипCOMОбъекта = "OUTER"
			Или ТипCOMОбъекта = "FULL"
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "FULL";
		ИначеЕсли Ложь
			Или ТипCOMОбъекта = "INNER"
			Или ПустаяСтрока(ТипCOMОбъекта)
		Тогда
			ТекущаяСвязьТаблиц.ТипСвязи = "INNER";
		Иначе
			ВызватьИсключение "Неизвестный тип связи таблиц """ + ТипCOMОбъекта + """";
		КонецЕсли;
		ТокенУсловия = Данные.Tokens(5);
		НастройкиКомпоновки = Новый НастройкиКомпоновкиДанных;
		ПостроитьДеревоЛогическогоВыражения(НастройкиКомпоновки.Отбор, ТокенУсловия, ЗапросПакета, ЧастьОбъединения);
		ТекущаяСвязьТаблиц.Условие = НастройкиКомпоновки;
		СобратьКомментарийТокена(ТокенУсловия, ТаблицаКомментариев, ТекущаяСвязьТаблиц.Комментарий);
		//ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущаяСвязьТаблиц, "Таблица");
		Результат = ТекущаяСвязьТаблиц.Родитель;
	ИначеЕсли ИмяПравила = "<ParameterOfTable>" Тогда
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		ТекущийУзел = ВыбраннаяТаблица.Параметры.Добавить();
		ТекущийУзел.Номер = ВыбраннаяТаблица.Параметры.Количество();
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Токен = Токен;
	ИначеЕсли ИмяПравила = "<Allowed>" Тогда
		ЗапросПакета.ОпцияРазрешенные = Истина;
	ИначеЕсли ИмяПравила = "<AutoOrder>" Тогда
		Если ПолучитьТекстИзТокена(Токен) <> "" Тогда
			ЗапросПакета.ОпцияАвтоупорядочивание = Истина;
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Distinct>" Тогда
		ЧастьОбъединения.ОпцияРазличные = Истина;
	ИначеЕсли ИмяПравила = "<ForUpdate>" Тогда
		Если Данные.TokenCount > 0 Тогда
			ЧастьОбъединения.ОпцияДляИзменения = Истина;
			ПоследнийТокен = Данные.Tokens(Данные.TokenCount - 1);
			Если ПоследнийТокен.Kind = 0 Тогда
				ЗаполнитьПоТокену(ПоследнийТокен, Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаКомментариев);
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Top>" Тогда
		ЗапросПакета.ОпцияПервые = Истина;
		Если Данные.TokenCount > 1 Тогда
			Если Данные.Tokens(1).Type = 1 Тогда
				ЗапросПакета.ПервыеКоличество = Данные.Tokens(1).Data;
			Иначе
				ТокенКоличества = Данные.Tokens(1).Data.Tokens(0);
				Если ТокенКоличества.text = "<Parameter>" Тогда
					ЗапросПакета.ПервыеКоличество = СобратьВыражениеЗапроса(ТокенКоличества,, ЗапросПакета, ЧастьОбъединения);
				Иначе
					ЗапросПакета.ПервыеКоличество = Число(ТокенКоличества.Data);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Limit>" Тогда
		Если Данные.TokenCount > 0 Тогда
			ЗапросПакета.ОпцияПервые = Истина;
			Если Данные.Tokens(1).Type = 1 Тогда
				ЗапросПакета.ПервыеКоличество = Данные.Tokens(1).Data;
			Иначе
				ТокенКоличества = Данные.Tokens(1).Data.Tokens(0);
				Если ТокенКоличества.text = "<Parameter>" Тогда
					ЗапросПакета.ПервыеКоличество = СобратьВыражениеЗапроса(ТокенКоличества,, ЗапросПакета, ЧастьОбъединения);
				Иначе
					ЗапросПакета.ПервыеКоличество = Число(ТокенКоличества.Data);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Fetch>" Тогда
		ЗапросПакета.ОпцияПервые = Истина;
		ТокенКоличества = Данные.Tokens(2).Data.Tokens(0);
		Если ТокенКоличества.text = "<Parameter>" Тогда
			ЗапросПакета.ПервыеКоличество = СобратьВыражениеЗапроса(ТокенКоличества,, ЗапросПакета, ЧастьОбъединения);
		Иначе
			ЗапросПакета.ПервыеКоличество = Число(ТокенКоличества.Data);
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Offset>" Тогда
		Если Данные.TokenCount > 0 Тогда
			Сообщить("Оператор OFFSET проигнорирован, т.к. не поддерживается конструктором");
		КонецЕсли; 
	//ИначеЕсли ИмяПравила = "<MultiField>" Тогда
	//	ТекущийУзел = ЧастьОбъединения.ВыбранныеПоля[ЧастьОбъединения.ВыбранныеПоля.Количество() - 1];
	//	ТекущийУзел.Определение = ПолучитьТекстИзТокена(Токен);
	ИначеЕсли ИмяПравила = "<Where>" Тогда
		Если Данные.TokenCount > 0 Тогда
			ПостроитьДеревоЛогическогоВыражения(ЧастьОбъединения.Компоновщик.Настройки.Отбор, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения);
			СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЧастьОбъединения.КомментарийОтбора);
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Having>" Тогда
		Если Данные.TokenCount > 0 Тогда
			ПостроитьДеревоЛогическогоВыражения(ЧастьОбъединения.Компоновщик.Настройки.Отбор, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения);
			СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЧастьОбъединения.КомментарийОтбора);
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<SelectExpr>" Тогда
		ТекущийУзел = ЧастьОбъединения.ВыбранныеПоля.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(0);
		ТекущийУзел.ИД = Новый УникальныйИдентификатор();
		ЕстьАгрегаты = Ложь;
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,, ЕстьАгрегаты);
		ТекущийУзел.ЕстьАгрегаты = ЕстьАгрегаты;
		ТекущийУзел.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ТекущийУзел.Токен);
		//ТекущийУзел.ТипЗначения = ПолучитьТипЗначенияВыражения(ТекущийУзел.Токен, ЧастьОбъединения); // Перенесено в ОбработатьЗапросПослеУстановкиДанных
		Если КоличествоДочерних = 2 Тогда
			ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(1));
		КонецЕсли; 
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
	ИначеЕсли ИмяПравила = "<GroupExpr>" Тогда
		ТекущийУзел = ЧастьОбъединения.Группировки.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
	ИначеЕсли ИмяПравила = "<SetExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПринимающиеПоля.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1).Data.Tokens(1);
		ТекущийУзел.Поля = ПолучитьТекстИзТокена(Данные.Tokens(0));
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения);
		//ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
	ИначеЕсли ИмяПравила = "<InsertField>" Тогда
		ТекущийУзел = ЗапросПакета.ПринимающиеПоля.Добавить();
		ТекущийУзел.Поля = ПолучитьТекстИзТокена(Данные.Tokens(0));
	ИначеЕсли ИмяПравила = "<InsertExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПринимающиеПоля[мРазборИндексПринимающегоПоля];
		ТекущийУзел.Токен = Данные.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения);
		мРазборИндексПринимающегоПоля = мРазборИндексПринимающегоПоля + 1;
	ИначеЕсли ИмяПравила = "<TotalsExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ГруппирующиеПоляИтогов.Добавить();
		ДанныеHierExpr = Данные.Tokens(0).Data;
		ТекущийУзел.Токен = ДанныеHierExpr.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ,,,, Ложь);
		ДанныеHierMode = ДанныеHierExpr.Tokens(1).Data;
		Если ДанныеHierMode.TokenCount = 0 Тогда
			ТипИтогов = "Элементы";
		Иначе
			ПервыйТокен = ДанныеHierMode.Tokens(0);
			Если Истина
				И ПервыйТокен.Kind = 0 
			Тогда 
				ТипИтогов = "ЭлементыИИерархия";
			ИначеЕсли Истина
				И ПервыйТокен.Kind = 1 
				И ПервыйТокен.Name = "ONLY"
			Тогда 
				ТипИтогов = "Иерархия";
			//ИначеЕсли Истина
			//	И ПервыйТокен.Kind = 1 
			//	И ПервыйТокен.Name = "PERIODS"
			//Тогда 
			//	ТипИтогов = "Периодами";
			КонецЕсли; 
		КонецЕсли; 
		ТекущийУзел.ТипИтогов = ТипИтогов;
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(1));
	ИначеЕсли ИмяПравила = "<OrderExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПоляПорядка.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		ТокенНаправления = Данные.Tokens(Данные.TokenCount - 1).Data.Tokens(0);
		Если Истина
			И ТокенНаправления <> Неопределено
			И ТокенНаправления.Kind = 1 
			И ТокенНаправления.Name = "DESC" 
		Тогда
			ТекущийУзел.Направление = НаправлениеСортировки.Убыв;
		Иначе
			ТекущийУзел.Направление = НаправлениеСортировки.Возр;
		КонецЕсли; 
		ТокенИерархии = Данные.Tokens(1);
		Если ТокенИерархии.Data.TokenCount > 0 Тогда
			ТекущийУзел.Иерархия = Истина;
		Иначе
			ТекущийУзел.Иерархия = Ложь;
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<AgregatExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ГруппируемыеПоляИтогов.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(1));
	ИначеЕсли ИмяПравила = "<IndexExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПоляИндекса.Добавить();
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(Данные.Tokens(0),, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		//ТекущийУзел.Токен = Токен;
	ИначеЕсли ИмяПравила = "<ExtSelectExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЧастьОбъединения.ПоляВыбораПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(0);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(1));
	ИначеЕсли ИмяПравила = "<ExtWhereExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЧастьОбъединения.ПоляОтбораПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(0);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(1));
	ИначеЕсли ИмяПравила = "<ExtOrderExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЗапросПакета.ПоляПорядкаПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(0);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета,,,,, Ложь);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(1));
	ИначеЕсли ИмяПравила = "<ExtTotalExpr>" Тогда
		ДанныеПоля = Данные.Tokens(0).Data;
		ТекущийУзел = ЗапросПакета.ПоляИтоговПостроителя.Добавить();
		ТекущийУзел.Токен = ДанныеПоля.Tokens(0);
		ТекущийУзел.ИспользоватьДочерние = ТекущийУзел.Токен.Data.Tokens(1).Data.TokenCount > 0;
		Если ТекущийУзел.ИспользоватьДочерние Тогда
			ТекущийУзел.Токен = ТекущийУзел.Токен.Data.Tokens(0);
		КонецЕсли; 
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета,,,,, Ложь);
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, ДанныеПоля.Tokens(1));
	ИначеЕсли Истина
		И ИмяПравила = "<TableName>" 
		И Стек[1] = "<TableNames>"
	Тогда
		ТекстОпределения = СобратьВыражениеЗапроса(Токен,, ЗапросПакета, ЧастьОбъединения);
		//СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ТекстОпределения), "НПолноеИмя"); // Так для неизвестных таблиц не будет работать
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(ТекстОпределения, "ПолноеИмя");
		Если ВыбраннаяТаблица <> Неопределено Тогда
			ВыбраннаяТаблица.ДляИзменения = Истина;
		КонецЕсли; 
	ИначеЕсли Истина
		И ИмяПравила = "<TablePseudoname>" 
		И (Ложь
			Или Стек[1] = "<TableWithName>"
			Или Стек[1] = "<FromUnion>")
	Тогда
		ТокенПсевдонима = Неопределено;
		Если Данные.TokenCount > 0 Тогда
			ТокенПсевдонима = Данные.Tokens(Данные.TokenCount - 1);
		КонецЕсли; 
		Если ТокенПсевдонима = Неопределено Тогда
			ТекстОпределения = "";
		Иначе
			ТекстОпределения = СобратьВыражениеЗапроса(ТокенПсевдонима,, ЗапросПакета, ЧастьОбъединения);
		КонецЕсли; 
		ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		ТекущийУзел.Имя = ТекстОпределения;
		ТекущийУзел.Имя = ПолучитьИмяБезКвадратныхСкобок(ТекущийУзел.Имя);
		Если Не ЗначениеЗаполнено(ТекущийУзел.Имя) Тогда
			ЗаменаПустойСтроки = ТекущийУзел.ПолноеИмя;
			Если Не ЗначениеЗаполнено(ЗаменаПустойСтроки) Тогда
				ЗаменаПустойСтроки = ПолучитьСловоЯзыкаЗапросов("Table") + "1";
			КонецЕсли; 
			ТекущийУзел.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЧастьОбъединения.ВыбранныеТаблицы, ТекущийУзел,,, ЗаменаПустойСтроки);
		КонецЕсли; 
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);
		Результат = ТекущийУзел.Имя;
	ИначеЕсли ИмяПравила = "<TableWith>" Тогда
		Если Данные.TokenCount > 0 Тогда
			ТокенУровняИзоляции = Данные.Tokens(2);
			лУровеньИзоляции = ПолучитьТекстИзТокена(ТокенУровняИзоляции);
			Если Стек[1] = "<TableWithName>" Тогда
				ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
				ТекущийУзел.УровеньИзоляции = ПолучитьТекстИзТокена(ТокенУровняИзоляции);
			Иначе
				ЗапросПакета.УровеньИзоляции = лУровеньИзоляции;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ИмяПравила = "<CreateQuery>"
		Или ИмяПравила = "<SelectQuery>"
		Или ИмяПравила = "<Query>"
	Тогда
		Если ИмяПравила = "<CreateQuery>" Тогда  // FromTables
			ИндексТокенаВыбранныхТаблиц = 4;
		Иначе
			ИндексТокенаВыбранныхТаблиц = 3;
		КонецЕсли; 
		ЗаполнитьПоТокену(Данные.Tokens(ИндексТокенаВыбранныхТаблиц), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаКомментариев);
		Для ИндексТокена = 1 По КоличествоДочерних - 1 Цикл
			Если ИндексТокена = ИндексТокенаВыбранныхТаблиц Тогда
				Продолжить;
			КонецЕсли; 
			ТокенВниз = Данные.Tokens(ИндексТокена);
			Если ТокенВниз.Kind = 0 Тогда
				ЗаполнитьПоТокену(ТокенВниз, Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаКомментариев);
			КонецЕсли;
		КонецЦикла;
		ИмяЗапросаИзКомментария = "";
		ИмяЧастиОбъединенияИзКомментария = "";
		СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЧастьОбъединения.Комментарий, , ИмяЗапросаИзКомментария, ИмяЧастиОбъединенияИзКомментария);
		Если Ложь
			Или ИмяПравила = "<CreateQuery>"
			Или ИмяПравила = "<SelectQuery>"
		Тогда
			Если СтрЧислоВхождений(ЧастьОбъединения.Комментарий, "/") = СтрДлина(ЧастьОбъединения.Комментарий) Тогда
				ЧастьОбъединения.Комментарий = "";
			КонецЕсли; 
		КонецЕсли; 
		Если ЗначениеЗаполнено(ИмяЗапросаИзКомментария) Тогда
			Если ЗапросПакета.ЧастиОбъединения.Количество() = 1 Тогда
				ЗапросПакета.Имя = ИмяЗапросаИзКомментария;
				ЗапросПакета.РучноеИмя = Истина;
			КонецЕсли; 
		КонецЕсли; 
		Если ЗначениеЗаполнено(ИмяЧастиОбъединенияИзКомментария) Тогда
			ЧастьОбъединения.Имя = ИмяЧастиОбъединенияИзКомментария;
			ЧастьОбъединения.РучноеИмя = Истина;
		КонецЕсли; 
	Иначе
		Если Ложь
			Или ИмяПравила = "<SelectRoot>"
			Или ИмяПравила = "<CreateRoot>"
			Или ИмяПравила = "<DropRoot>"
			Или ИмяПравила = "<TruncateRoot>"
			Или ИмяПравила = "<InsertRoot>"
			Или ИмяПравила = "<UpdateRoot>"
			Или ИмяПравила = "<DeleteRoot>"
		Тогда
			ЗапросПакета = ДобавитьЗапросПакета();
			Если Истина
				И мКонечнаяСтрока <> Неопределено
				И мСтрокаНачальногоЗапроса = Неопределено 
			Тогда 
				НачальныйТокен = Токен.GetBorderToken(0, Истина);
				КонечныйТокен = Токен.GetBorderToken(1, Истина);
				НачальнаяСтрокаТокена = НачальныйТокен.LineNumber;
				КонечнаяСтрокаТокена = КонечныйТокен.LineNumber;
				Если Истина
					И НачальнаяСтрокаТокена <= мКонечнаяСтрока
					И мКонечнаяСтрока <= КонечнаяСтрокаТокена 
				Тогда 
					мСтрокаНачальногоЗапроса = ЗапросПакета;
				КонецЕсли; 
			КонецЕсли; 
			ОбновитьДоступныеВременныеТаблицы();
			Если ИмяПравила = "<SelectRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 0;
			ИначеЕсли ИмяПравила = "<CreateRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 1;
			ИначеЕсли ИмяПравила = "<DropRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 2;
				СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЗапросПакета.Комментарий);
				ЗапросПакета.ИмяОсновнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(2));
			ИначеЕсли ИмяПравила = "<InsertRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 3;
				ЗапросПакета.ЗначенияИзВыборки = Истина;
				СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЗапросПакета.Комментарий);
				ЗапросПакета.ИмяОсновнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(2));
			ИначеЕсли ИмяПравила = "<UpdateRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 4;
				ЗапросПакета.ИмяОсновнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(2));
				ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
				СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЧастьОбъединения.Комментарий);
			ИначеЕсли ИмяПравила = "<DeleteRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 5;
				СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЗапросПакета.Комментарий);
				ЗапросПакета.ИмяОсновнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(3));
				ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
				СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЧастьОбъединения.Комментарий);
			ИначеЕсли ИмяПравила = "<TruncateRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 6;
				СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЗапросПакета.Комментарий);
				ЗапросПакета.ИмяОсновнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(2));
			КонецЕсли; 
		ИначеЕсли ИмяПравила = "<ExtRoot>" Тогда
			ИндексЗапроса = Данные.Tokens(1).Data;
			ИндексЗапроса = Число(ИндексЗапроса);
			ЗапросПакета = ЗапросыПакета[ИндексЗапроса];
		ИначеЕсли ИмяПравила = "<ExtUnionPart>" Тогда
			ИндексЧасти = Данные.Tokens(1).Data;
			ИндексЧасти = Число(ИндексЧасти);
			ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[ИндексЧасти];
		ИначеЕсли Истина
			И ИмяПравила = "<TableWithName>"
			И КоличествоДочерних > 1
		Тогда
			ТекущийУзел = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
			ТекущийУзел.Обязательная = Не РазборРасширений;
			СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		ИначеЕсли Истина
			И ИмяПравила = "<FromUnion>" 
			//И КоличествоДочерних > 1
		Тогда
			ТекущийУзел = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
			ТекущийУзел.Обязательная = Не РазборРасширений;
		ИначеЕсли Ложь
			Или ИмяПравила = "<SelectUnion>"
			Или ИмяПравила = "<CreateUnion>"
			Или ИмяПравила = "<SimpleUnion>"
		Тогда
			ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
		ИначеЕсли Ложь
			Или ИмяПравила = "<UnionPart>"
		Тогда
			ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
			ЧастьОбъединения.БезДублей = Данные.Tokens(1).Data.TokenCount = 0;
			Если Истина
				И мКонечнаяСтрока <> Неопределено
				И мСтрокаНачальнойЧастиОбъединения = Неопределено 
				И ЗапросПакета = мСтрокаНачальногоЗапроса
			Тогда 
				НачальныйТокен = Токен.GetBorderToken(0, Истина);
				КонечныйТокен = Токен.GetBorderToken(1, Истина);
				НачальнаяСтрокаТокена = НачальныйТокен.LineNumber;
				КонечнаяСтрокаТокена = КонечныйТокен.LineNumber;
				Если Истина
					И НачальнаяСтрокаТокена <= мКонечнаяСтрока
					И мКонечнаяСтрока <= КонечнаяСтрокаТокена 
				Тогда 
					мСтрокаНачальнойЧастиОбъединения = ЧастьОбъединения;
				КонецЕсли; 
			КонецЕсли; 
		ИначеЕсли Ложь
			Или ИмяПравила = "<InsertExprs>"
		Тогда
			ЗапросПакета.ЗначенияИзВыборки = Ложь;
		ИначеЕсли Истина
			И ИмяПравила = "<Table>" 
			И Стек[1] = "<TableWithName>"
		Тогда
			ТекстОпределенияТаблицы = СобратьВыражениеЗапроса(Данные.Tokens(0),, ЗапросПакета, ЧастьОбъединения);
			ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
			//Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ТекстОпределенияТаблицы);
			//ПолноеИмя = "";
			//Для Каждого Фрагмент Из Фрагменты Цикл
			//	Если ПолноеИмя <> "" Тогда
			//		ПолноеИмя = ПолноеИмя + ".";
			//	КонецЕсли; 
			//	ПолноеИмя = ПолноеИмя + ПолучитьИмяБезКвадратныхСкобок(Фрагмент);
			//КонецЦикла;
			Если Найти(ТекстОпределенияТаблицы, ".") = 0 Тогда
				ПолноеИмя = ПолучитьИмяБезКвадратныхСкобок(ТекстОпределенияТаблицы);
			Иначе
				ПолноеИмя = ТекстОпределенияТаблицы;
			КонецЕсли; 
			ЧастьОбъединения.КомпоновщикАктуален = Ложь;
			ТекущийУзел.ПолноеИмя = ирОбщий.ПолучитьПервыйФрагментЛкс(ПолноеИмя, "(");
			//Перейти ~Выход; // Еще параметры виртуальной таблицы надо разбирать
		ИначеЕсли ИмяПравила = "<Into>" Тогда
			//ЗапросПакета.ТипЗапроса = 1;
			ЗапросПакета.ИмяОсновнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(2));
			ОбновитьНаименованиеЗапроса(ЗапросПакета);
		КонецЕсли;
		Для ИндексТокена = 0 По КоличествоДочерних - 1 Цикл
			ТокенВниз = Данные.Tokens(ИндексТокена);
			Если ТокенВниз.Kind = 0 Тогда
				// Не терминальный токен
				ПсевдонимСнизу = ЗаполнитьПоТокену(ТокенВниз, Стек, ЗапросПакета, ЧастьОбъединения, Индикатор, РазборРасширений, ТаблицаКомментариев, ТекущаяСвязьТаблиц);
				Если ПсевдонимСнизу <> Неопределено Тогда 
					Если Ложь
						Или ИмяПравила = "<FromUnion>" 
						Или ИмяПравила = "<JoinSide>" 
						Или ИмяПравила = "<TableWithName>" 
						Или ИмяПравила = "<TablePseudoname>" 
					Тогда 
						Результат = ПсевдонимСнизу;
					КонецЕсли; 
				КонецЕсли;
			Иначе
				ИмяТерминала = ТокенВниз.Data;
				Если ИмяТерминала = "(" Или ИмяТерминала = "," Тогда
					мРазборПоследнийТокенРазделитель = ТокенВниз;
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
		Если Истина
			И ИмяПравила = "<FromUnion>" 
			//И КоличествоДочерних > 1
		Тогда
			СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ТекущийУзел.Комментарий);
		КонецЕсли; 
	КонецЕсли;
	Если Ложь
		Или ИмяПравила = "<SelectRoot>"
		Или ИмяПравила = "<CreateRoot>"
		Или ИмяПравила = "<DropRoot>"
		Или ИмяПравила = "<InsertRoot>"
		Или ИмяПравила = "<UpdateRoot>"
		Или ИмяПравила = "<DeleteRoot>"
		Или ИмяПравила = "<EmbeddedRoot>"
	Тогда
		ОбработатьЗапросПослеУстановкиДанных(ЗапросПакета);
	КонецЕсли; 
	Если ТаблицаКомментариев <> Неопределено Тогда
		// Расширения языка запросов 1С
		Если Ложь
			Или ИмяПравила = "<ParameterOfTable>"
		Тогда
			ПараметрыВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1].Параметры;
			СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ПараметрыВыбраннойТаблицы[ПараметрыВыбраннойТаблицы.Количество() - 1].ТекстРасширения, Истина);
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<FromTables>"
		Тогда
			НачальныйТерминал = Токен.GetBorderToken(0);
			Если НачальныйТерминал <> Неопределено Тогда
				КонечныйТерминал = Токен.GetBorderToken(1, Истина);
				ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
				ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
				Для Каждого СтрокаРасширения Из ТаблицаКомментариев Цикл
					Если Истина
						И СтрокаРасширения.ЭтоРасширение
						И СтрокаРасширения.Позиция >= ПозицияНачальногоТокена 
						И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена
					Тогда
						СтрокаРасширения.Текст = "FROM #FixedTables# КАК FixedTables" + Символы.ПС + СтрокаРасширения.Текст;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Если Ложь
			Или (Истина
				И ИмяПравила = "<TableWithName>"
				И КоличествоДочерних > 1)
			Или (Истина
				И ИмяПравила = "<FromUnion>" 
				//И КоличествоДочерних > 1
				)
		Тогда
			НачальныйТерминал = Токен.GetBorderToken(0, Истина);
			Если НачальныйТерминал <> Неопределено Тогда
				ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
				НачальноеКоличество = ТаблицаКомментариев.Количество(); 
				Для СчетчикРасширения = 1 По НачальноеКоличество Цикл
					СтрокаРасширения = ТаблицаКомментариев[НачальноеКоличество - СчетчикРасширения];
					Если Истина
						И СтрокаРасширения.Позиция <= ПозицияНачальногоТокена 
						И Лев(СтрокаРасширения.Текст, 1) = "#"
					Тогда
						ТекущийУзел.НомерГруппы = Число(Сред(СтрокаРасширения.Текст, 2)) + 1; // +1 сделано 02.12.2015
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<SelectUnion>"
			Или ИмяПравила = "<CreateUnion>"
			Или ИмяПравила = "<SimpleUnion>"
			Или ИмяПравила = "<UnionPart>"
		Тогда
			НачальныйТерминал = Токен.GetBorderToken(0, Истина);
			КонечныйТерминал = Токен.GetBorderToken(1, Истина);
			НачальноеКоличество = ТаблицаКомментариев.Количество(); 
			ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
			ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
			Для СчетчикТаблицаТекстаРасширения = 1 По НачальноеКоличество Цикл
				ИндексРасширения = НачальноеКоличество - СчетчикТаблицаТекстаРасширения;
				СтрокаРасширения = ТаблицаКомментариев[ИндексРасширения];
				Если Истина
					И СтрокаРасширения.ЭтоРасширение
					И СтрокаРасширения.Позиция >= ПозицияНачальногоТокена 
					И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена
				Тогда
					Если ЧастьОбъединения.ТекстРасширения <> "" Тогда
						//ЧастьОбъединения.ТекстРасширения = "#" + ЧастьОбъединения.ТекстРасширения;
						ЧастьОбъединения.ТекстРасширения = Символы.ПС + ЧастьОбъединения.ТекстРасширения ;
					КонецЕсли; 
					ЧастьОбъединения.ТекстРасширения = "{#" + ИндексРасширения + "}" + СтрокаРасширения.Текст + ЧастьОбъединения.ТекстРасширения;
					ТаблицаКомментариев.Удалить(СтрокаРасширения);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<SelectRoot>"
			Или ИмяПравила = "<CreateRoot>"
			Или ИмяПравила = "<DropRoot>"
			Или ИмяПравила = "<EmbeddedRoot>"
		Тогда
			СобратьКомментарийТокена(Токен, ТаблицаКомментариев, ЗапросПакета.ТекстРасширения, Истина);
		КонецЕсли; 
		Если Ложь
			Или ИмяПравила = "<ExtUnionPart>"
		Тогда
			СтрокаСлужебнойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти("#FixedTables#", "ПолноеИмя");
			Если СтрокаСлужебнойТаблицы <> Неопределено Тогда
				СтрокиСвязи = ЧастьОбъединения.СвязиТаблиц.Строки.НайтиСтроки(Новый Структура("Таблица", СтрокаСлужебнойТаблицы.Имя), Истина);
				Для Каждого СтрокаСвязи Из СтрокиСвязи Цикл
					СтрокаОбязательнойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(Истина, "Обязательная");
					Если СтрокаОбязательнойТаблицы <> Неопределено Тогда
						СтрокаСвязи.Таблица = СтрокаОбязательнойТаблицы.Имя;
					Иначе
						ЧастьОбъединения.СвязиТаблиц.Строки.Удалить(СтрокаСвязи);
					КонецЕсли; 
				КонецЦикла;
				ЧастьОбъединения.ВыбранныеТаблицы.Удалить(СтрокаСлужебнойТаблицы);
			КонецЕсли; 
			КонечныйТерминал = Токен.GetBorderToken(1, Истина);
			ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
			НачальноеКоличество = ТаблицаКомментариев.Количество(); 
			Для СчетчикРасширения = 1 По НачальноеКоличество Цикл
				СтрокаРасширения = ТаблицаКомментариев[НачальноеКоличество - СчетчикРасширения];
				Если Истина
					И СтрокаРасширения.Позиция <= ПозицияКонечногоТокена 
					И Лев(СтрокаРасширения.Текст, 1) = "#"
				Тогда
					ТаблицаКомментариев.Удалить(СтрокаРасширения);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	Стек.Удалить(0);
	Если ИндикаторБылСоздан = Истина Тогда
		ирОбщий.ОсвободитьИндикаторПроцессаЛкс(Индикатор);
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура СобратьКомментарийТокена(Знач Токен, Знач ТаблицаКомментариев, ТекстКомментария, Знач РежимРасширения = Ложь, выхИмяЗапросаИзКомментария = Неопределено,
	выхИмяЧастиОбъединенияИзКомментария = Неопределено)
	
	НачальныйТерминал = Токен.GetBorderToken(0, Истина);
	КонечныйТерминал = Токен.GetBorderToken(1, Истина);
	Если ТаблицаКомментариев = Неопределено Тогда
		Возврат;
	КонецЕсли;
	НачальноеКоличество = ТаблицаКомментариев.Количество(); 
	Если НачальныйТерминал = Неопределено И КонечныйТерминал = Неопределено Тогда
		Если Токен.Name = "ParameterOfTable" И мРазборПоследнийТокенРазделитель.EndNoise <> Неопределено Тогда
			ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(мРазборПоследнийТокенРазделитель) + 1;
			ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(мРазборПоследнийТокенРазделитель.EndNoise);
		Иначе
			Возврат;
		КонецЕсли;
	Иначе
		ПозицияНачальногоТокена = ПолучитьОтносительнуюПозициюТокена(НачальныйТерминал);
		ПозицияКонечногоТокена = ПолучитьОтносительнуюПозициюТокена(КонечныйТерминал);
	КонецЕсли; 
	Для СчетчикТаблицаТекстаРасширения = 1 По НачальноеКоличество Цикл
		БлокаКомментария = ТаблицаКомментариев[НачальноеКоличество - СчетчикТаблицаТекстаРасширения];
		Если Истина
			И РежимРасширения = БлокаКомментария.ЭтоРасширение
			И БлокаКомментария.Позиция >= ПозицияНачальногоТокена// - 1
			И БлокаКомментария.Позиция <= ПозицияКонечногоТокена// + 1
		Тогда
			Если ТекстКомментария <> "" Тогда
				//ТекстРасширения = "#" + ЗапросПакета.ТекстРасширения;
				ТекстКомментария = Символы.ПС + ТекстКомментария;
			КонецЕсли; 
			ТекстКомментария = БлокаКомментария.Текст + ТекстКомментария;
			ТаблицаКомментариев.Удалить(БлокаКомментария);
			РазобратьКомментарий(ТекстКомментария, выхИмяЗапросаИзКомментария, выхИмяЧастиОбъединенияИзКомментария);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Процедура ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Знач Токен)

	Данные = Токен.Data;
	Если Данные.TokenCount = 0 Тогда // Для нового движка
		Возврат;
	КонецЕсли; 
	Токен = Данные.Tokens(Данные.TokenCount - 1);
	Если Токен = Неопределено Тогда // для старого движка
		Возврат;
	КонецЕсли; 
	Данные = Токен.Data;
	Токен = Данные.Tokens(Данные.TokenCount - 1);
	//ТекстИмени = Данные.Tokens(1).Data.Tokens(0).Data; // Так будет неправильно работать что то, но что?
	ТекстИмени = ПолучитьТекстИзТокена(Токен); // Так для вложенных запросов в служебном поле текстового документа текст родительского запроса
	ТекущийУзел.Имя = ТекстИмени;
	ТекущийУзел.Имя = ПолучитьИмяБезКвадратныхСкобок(ТекущийУзел.Имя);
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);

КонецПроцедуры

Функция ПроверитьДобавитьПараметр(выхИмяПараметра, ТипЗначения = Неопределено)

	Если мПрефиксыПараметров.Найти(Лев(выхИмяПараметра, 1)) <> Неопределено Тогда
		выхИмяПараметра = Сред(выхИмяПараметра, 2);
	КонецЕсли; 
	ТекущийУзел = Параметры.Найти(НРег(выхИмяПараметра), "НИмя");
	Если ТекущийУзел = Неопределено Тогда
		ТекущийУзел = Параметры.Добавить();
		Если Не ЗначениеЗаполнено(выхИмяПараметра) Тогда
			выхИмяПараметра = ПолучитьСловоЯзыкаЗапросов("Parameter") + XMLСтрока(Параметры.Количество() - 1);
		КонецЕсли; 
		ТекущийУзел.Имя = выхИмяПараметра;
		ТекущийУзел.ТипЗначения = ТипЗначения;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);
	КонецЕсли;
	//ТекущийУзел.ЧислоОбращений = ТекущийУзел.ЧислоОбращений + 1;
	Возврат ТекущийУзел;

КонецФункции

// Попытка оптимизации пересборки большого числа выражений
Функция ЛиВыражениеЯвляетсяПолем(ВыражениеЗапроса) Экспорт
	
	ВычислительРегулярныхВыражений = мПлатформа.RegExp;
	ФрагментШаблона = "(?:[" + мПлатформа.шБуква + "][" + мПлатформа.шБуква + "\d]*|\[[^\]]+\])";
	ВычислительРегулярныхВыражений.Pattern = "^" + ФрагментШаблона + "(?:\." + ФрагментШаблона + ")*$";
	Результат = ВычислительРегулярныхВыражений.Test(ВыражениеЗапроса);
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПредставлениеЗначенияНаЯзыке(Знач Значение) Экспорт
	
	Если ТипЗнч(Значение) = Тип("ПолеКомпоновкиДанных") Тогда
		Результат = "" + Значение;
		ПолеПараметра = Результат;
		МассивСинонимов = Новый Массив();
		МассивСинонимов.Добавить("DataParameters");
		МассивСинонимов.Добавить("ПараметрыДанных");
		Для Каждого Синоним Из МассивСинонимов Цикл
			Если Найти(НРег(ПолеПараметра), НРег(Синоним + ".")) = 1 Тогда
				Результат = ПараметрыДиалектаSQL.ПрефиксПараметра;
				Если ИменованныеПараметры Тогда
					Результат = Результат + Сред(ПолеПараметра, СтрДлина(Синоним + ".") + 1);
				КонецЕсли; 
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если Не ЗначениеЗаполнено(Результат) Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
		КонецЕсли; 
	ИначеЕсли ТипЗнч(Значение) = Тип("Неопределено") Тогда
		Результат = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
	Иначе
		Если ТипЗнч(Значение) = Тип("СтандартнаяДатаНачала") Тогда
			Значение = Значение.Дата;
		КонецЕсли; 
		Если ТипЗнч(Значение) = Тип("Дата") Тогда
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				Результат = ПолучитьСловоЯзыкаЗапросов("DATETIME") + "(" + XMLСтрока(Год(Значение)) + ", " + XMLСтрока(Месяц(Значение)) + ", " + XMLСтрока(День(Значение));
				Если НачалоДня(Значение) <> Значение Тогда
					Результат = Результат + ",  " + XMLСтрока(Час(Значение)) + ", " + XMLСтрока(Минута(Значение)) + ", " + XMLСтрока(Секунда(Значение));
				КонецЕсли;
				Результат = Результат + ")";
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				Значение = ирОбщий.ПолучитьЛитералДатыДляWQLЛкс(Значение);
			Иначе// Если ирОбщий.СтрокиРавныЛкс(КодЯзыка, "WQL") Тогда
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			КонецЕсли; 
		ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
			Результат = XMLСтрока(Значение);
		ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда
			Если Значение Тогда
				Результат = ПолучитьСловоЯзыкаЗапросов("TRUE");
			Иначе
				Результат = ПолучитьСловоЯзыкаЗапросов("FALSE");
			КонецЕсли; 
		ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
			Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				Результат = """" + СтрЗаменить(Значение, """", """""") + """";
			Иначе
				Результат = "'" + Значение + "'";
			КонецЕсли; 
		Иначе
			ВызватьИсключение "Для типа значения """ + ТипЗнч(Значение) + """ не определено отображение в язык запросов";
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПредставлениеСравненияНаЯзыке(ПредставлениеЛевогоПоля, Знач ВидСравнения, ДоступноеПолеИлиОписаниеТипов = Неопределено, Отступ = "") Экспорт
	
	Результат = ПредставлениеЛевогоПоля + " ";
	Если ВидСравнения = ВидСравненияКомпоновкиДанных.Равно Тогда
		Результат = Результат + "=";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно Тогда
		Результат = Результат + "<>";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.Больше Тогда
		Результат = Результат + ">";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно Тогда
		Результат = Результат + ">=";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.Меньше Тогда
		Результат = Результат + "<";
	ИначеЕсли ВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно Тогда
		Результат = Результат + "<=";
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит
	Тогда
		Результат = Результат + ПолучитьСловоЯзыкаЗапросов("LIKE");
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " " + Результат;
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено 
	Тогда
		Если ТипЗнч(ДоступноеПолеИлиОписаниеТипов) = Тип("ОписаниеТипов") Тогда
			ОписаниеТипов = ДоступноеПолеИлиОписаниеТипов;
			ТипыПоля = ОписаниеТипов.Типы();
		Иначе
			ОписаниеТипов = ДоступноеПолеИлиОписаниеТипов.ТипЗначения;
			ТипыПоля = ОписаниеТипов.Типы();
			Если Истина
				И ДоступноеПолеИлиОписаниеТипов.Родитель <> Неопределено 
				И Не ДоступноеПолеИлиОписаниеТипов.Родитель.Папка 
			Тогда
				ТипыПоля.Добавить(Тип("Null"));
			КонецЕсли; 
		КонецЕсли; 
		Смещение = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
		ПредставлениеСписка = "";
		Если ТипыПоля.Количество() > 1 Тогда
			ПредставлениеСписка = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
		КонецЕсли;
		СписокВыражений = Новый СписокЗначений;
		Для Каждого Тип Из ТипыПоля Цикл
			Если Тип = Тип("Null") Тогда
				Продолжить;
			КонецЕсли; 
			СписокВыражений.Добавить(ирОбщий.ПолучитьКонстантуТипаЗапросаЛкс(Тип, ОписаниеТипов));
		КонецЦикла;
		СписокВыражений.СортироватьПоЗначению();
		Для Каждого ЭлементСписка Из СписокВыражений Цикл
			Если ПредставлениеСписка <> "" Тогда
				ПредставлениеСписка = ПредставлениеСписка + ", " + Символы.ПС + Смещение;
			КонецЕсли; 
			ПредставлениеСписка = ПредставлениеСписка + ЭлементСписка.Значение;
		КонецЦикла;
		Если ТипыПоля.Найти(Тип("Null")) <> Неопределено Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("IS");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("NULL");
			Результат = Результат + Результат1 + " " + Результат2;
			Если ПредставлениеСписка <> "" Тогда
				Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("OR") + " " + ПредставлениеЛевогоПоля + " ";
			КонецЕсли; 
		КонецЕсли; 
		Если ПредставлениеСписка <> "" Тогда
			Результат = Результат + ПолучитьСловоЯзыкаЗапросов("IN") + " (" + ПредставлениеСписка + ")";
		КонецЕсли; 
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " (" + Результат + ")";
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии
	Тогда
		Результат1 = ПолучитьСловоЯзыкаЗапросов("IN");
		Результат2 = ПолучитьСловоЯзыкаЗапросов("HIERARCHYIN");
		Результат = Результат + Результат1 + " " + Результат2;
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " " + Результат;
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке 
		Или ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке
	Тогда
		Результат1 = ПолучитьСловоЯзыкаЗапросов("IN");
		Результат = Результат + Результат1;
		Если ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("NOT") + " " + Результат;
		КонецЕсли; 
	Иначе
		ВызватьИсключение "Вид сравнения " + ВидСравнения + " компоновки не поддерживается";
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПолноеИмяПоляВВыражении(ИмяПоля, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, СтароеИмяТаблицы = "",
	НовоеИмяТаблицы = "", РазрешитьНормализациюИмен = Истина, НужноПересобратьТокены = Ложь) Экспорт

	Результат = ИмяПоля;
	Если Истина
		И ПараметрыДиалектаSQL.МногоТаблиц
		И ЧастьОбъединения <> Неопределено 
	Тогда // Пока не проверяем другие выражения
		Если Найти(СтароеИмяТаблицы, ".") = 0 Тогда
			ПозицияТочки = Найти(Результат, ".");
			Если Истина
				И РазрешитьНормализациюИмен
				И ПозицияТочки = 0 
			Тогда
				//ОбновитьДоступныеВременныеТаблицы(); // Неоптимально?
				ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения, Ложь);
				Для Каждого ГруппаПолей Из ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы Цикл
					ДоступноеПоле = ГруппаПолей.Элементы.Найти("" + ГруппаПолей.Поле + "." + Результат);
					Если ДоступноеПоле <> Неопределено Тогда
						Результат = "" + ДоступноеПоле.Поле;
						// Правильно было бы проверить и другие таблицы для исключения неоднозначности привязки поля к таблице
						Прервать;
					КонецЕсли; 
				КонецЦикла;
			ИначеЕсли ЗначениеЗаполнено(СтароеИмяТаблицы) Тогда
				ИмяТаблицыПоля = Лев(Результат, ПозицияТочки - 1);
				Если ирОбщий.СтрокиРавныЛкс(ИмяТаблицыПоля, СтароеИмяТаблицы) Тогда
					Результат = НовоеИмяТаблицы + "." + Сред(Результат, ПозицияТочки + 1);
					НужноПересобратьТокены = Истина;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(Результат,, Истина);
			Если Фрагменты.Количество() > 1 Тогда
				ИмяПервогоПоля = Фрагменты[0] + "." + Фрагменты[1];
				Если ирОбщий.СтрокиРавныЛкс(ИмяПервогоПоля, СтароеИмяТаблицы) Тогда
					Фрагменты.Удалить(0);
					Фрагменты.Удалить(0);
					Результат = НовоеИмяТаблицы;
					Если Фрагменты.Количество() > 0 Тогда
						Результат = Результат + "." + ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(Фрагменты);
					КонецЕсли; 
					НужноПересобратьТокены = Истина;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Если РасширеннаяПроверка Тогда
			ПолеКомпоновки = Новый ПолеКомпоновкиДанных(Результат);
			ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолеКомпоновки);
			Если ДоступноеПоле = Неопределено Тогда
				Если ЗапросПакета <> Неопределено Тогда
					ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = ЗапросПакета;
				КонецЕсли; 
				Если ЧастьОбъединения <> Неопределено Тогда
					ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = ЧастьОбъединения;
				КонецЕсли; 
				ВызватьИсключение "Поле """ + ИмяПоля + """ не найдено";
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДобавитьПробелПослеТокена(Текст, ИмяПредыдущегоТокенаВниз)

	Если Истина // После них не ставим пробел
		И ИмяПредыдущегоТокенаВниз <> "."
		И ИмяПредыдущегоТокенаВниз <> "("
		И ИмяПредыдущегоТокенаВниз <> "&"
		И ИмяПредыдущегоТокенаВниз <> "?"
		И ИмяПредыдущегоТокенаВниз <> "@"
	Тогда
		Текст = Текст + " ";
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьСловоЯзыкаЗапросов(Ключ) Экспорт

	Результат = Неопределено;
	Если ирОбщий.СтрокиРавныЛкс("AS", Ключ) Тогда
		Если Не ПараметрыДиалектаSQL.КАК Тогда
			Результат = "";
		КонецЕсли;
	КонецЕсли; 
	Если Результат = Неопределено Тогда
		СтрокаТерминала = мТерминалыЯзыкаЗапросов.Найти(Ключ);
		Если ПараметрыДиалектаSQL <> Неопределено И ПараметрыДиалектаSQL.Это1С Тогда 
			Если СтрокаТерминала = Неопределено Тогда
				ВызватьИсключение "Не найден терминал """ + Ключ + """ языка запросов 1C";
			КонецЕсли; 
			Если Не Английский1С Тогда
				Результат = СтрокаТерминала.Русский;
			Иначе
				Результат = СтрокаТерминала.Английский;
			КонецЕсли; 
		Иначе
			Результат = Ключ;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Параметры:
//   РазрешитьНормализациюИмен - Булево - делать ли преобразование коротких имен полей к длинным (с именем таблицы)
//
Функция СобратьВыражениеЗапроса(Знач Токен, Отступ = 0, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено,
	СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", выхЕстьАгрегаты = Ложь, РазрешитьНормализациюИмен = Истина, НужноПересобратьТокены = Неопределено) Экспорт
	
	Если НужноПересобратьТокены = Неопределено Тогда
		НужноПересобратьТокены = Ложь;
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Токен.Kind = 1 Тогда
		Возврат Данные;
	КонецЕсли; 
	ИмяПравила = Данные.RuleText();
	Если Ложь
		Или ИмяПравила = "<Parameter>"
		Или ИмяПравила = "<TableParameter>"
	Тогда
		ВыражениеПараметра = Данные.Tokens(0).Data;
		Если СтароеИмяТаблицы = ВыражениеПараметра Тогда
			ВыражениеПараметра = НовоеИмяТаблицы;
			НужноПересобратьТокены = Истина;
		КонецЕсли; 
		ИмяПараметра = ВыражениеПараметра;
		ОписаниеТиповПараметра = Неопределено;
		Если ИмяПравила = "<TableParameter>" Тогда
			ОписаниеТиповПараметра = Новый ОписаниеТипов("ТаблицаЗначений");
		КонецЕсли; 
		ПроверитьДобавитьПараметр(ИмяПараметра, ОписаниеТиповПараметра);
		Результат = ПараметрыДиалектаSQL.ПрефиксПараметра;
		Если ИменованныеПараметры Тогда
			Результат = Результат + ИмяПараметра;
		КонецЕсли;
	Иначе
		Если ИмяПравила = "<Agregate>" Тогда
			выхЕстьАгрегаты = Истина;
		КонецЕсли; 
		ЧислоТокенов = Данные.TokenCount;
		Результат = "";
		//ЛевыйОтступ = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
		ЛевыйОтступ = Лев("														", Отступ); // Так быстрее
		Если ИмяПравила = "<Case>" Тогда
			ВыражениеВыбора = СобратьВыражениеЗапроса(Данные.Tokens(1), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
				выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			Результат = ПолучитьСловоЯзыкаЗапросов("CASE");
			Если ЗначениеЗаполнено(ВыражениеВыбора) Тогда
				Результат = Результат + " " + ВыражениеВыбора;
			КонецЕсли;
			Результат = Результат + СобратьВыражениеЗапроса(Данные.Tokens(2), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
				выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			ТекстElse = СобратьВыражениеЗапроса(Данные.Tokens(3), Отступ + 1, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
				выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			Если ЗначениеЗаполнено(ТекстElse) Тогда
				Результат = Результат + Символы.ПС + ЛевыйОтступ + "	" + ТекстElse;
			КонецЕсли; 
			Результат = Результат + Символы.ПС + ЛевыйОтступ + ПолучитьСловоЯзыкаЗапросов("END");
		ИначеЕсли ИмяПравила = "<WhenThen>" Тогда
			Результат = "
			|" + ЛевыйОтступ + "	" + ПолучитьСловоЯзыкаЗапросов("WHEN") + " " + СобратьВыражениеЗапроса(Данные.Tokens(1), Отступ + 2, ЗапросПакета, ЧастьОбъединения,
				СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены) + "
			|" + ЛевыйОтступ + "		" + ПолучитьСловоЯзыкаЗапросов("THEN") + " " + СобратьВыражениеЗапроса(Данные.Tokens(3), Отступ + 2, ЗапросПакета, ЧастьОбъединения,
				СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			Если ЧислоТокенов > 4 Тогда
				Результат = Результат + СобратьВыражениеЗапроса(Данные.Tokens(4), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
					выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
			КонецЕсли; 
		ИначеЕсли Ложь
			Или ИмяПравила = "<AndExpr>"
			Или ИмяПравила = "<OrExpr>"
		Тогда
			Результат = СобратьВыражениеЗапроса(Данные.Tokens(0), Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты,
				РазрешитьНормализациюИмен, НужноПересобратьТокены) + "
			|" + ЛевыйОтступ + "	" + Данные.Tokens(1).Data + " " + СобратьВыражениеЗапроса(Данные.Tokens(2), Отступ, ЗапросПакета, ЧастьОбъединения,
				СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
		ИначеЕсли ИмяПравила = "<EmbeddedQuery>" Тогда
			ВнутреннийТокен = Данные.Tokens(1);
			Если ВнутреннийТокен.Name = "EmbeddedRoot" Тогда
				Пакет = ЗапросыПакета.СкопироватьКолонки();
				ЗапросПакета = ДобавитьЗапросПакета(Пакет);
				ЗаполнитьПоТокену(ВнутреннийТокен, , ЗапросПакета, ЧастьОбъединения, Null);
				ОбновитьПоляОбъединенияЗапроса(ЗапросПакета); // Это уже делается в ОбработатьЗапросПослеУстановкиТекста
				Результат = "(" + Символы.ПС + ЛевыйОтступ + Символы.Таб + СобратьТекстПакета(Пакет, Символы.Таб) + ")";
			Иначе
				Результат = "(" + СобратьВыражениеЗапроса(ВнутреннийТокен,,,,,,,, НужноПересобратьТокены) + ")";
			КонецЕсли; 
		Иначе
			ИмяПредыдущегоТокена = Неопределено;
			ЗапретитьПробелы = Ложь
				Или ИмяПравила = "<MultiField>" 
				Или ИмяПравила = "<MultiFieldBody>";
			Для ИндексТокена = 0 По Данные.TokenCount - 1 Цикл
				ТокенВниз = Данные.Tokens(ИндексТокена);
				Если Истина
					И (Ложь
						Или ИмяПравила = "<Exprs>"
						Или ИмяПравила = "<NamedExprs>"
						Или ИмяПравила = "<EmptyTableFields>"
						)
					И ИмяПредыдущегоТокена = ","
				Тогда
					Результат = Результат + Символы.ПС + ЛевыйОтступ;
				КонецЕсли; 
				Если ТокенВниз.Kind = 0 Тогда
					Если Не ПустаяСтрока(Прав(Результат, 1)) И Не ЗапретитьПробелы Тогда
						ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
					КонецЕсли; 
					// Не терминальный токен
					РезультатСнизу = СобратьВыражениеЗапроса(ТокенВниз, Отступ, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,
						выхЕстьАгрегаты, РазрешитьНормализациюИмен, НужноПересобратьТокены);
					ИмяПредыдущегоТокена = Неопределено;
				Иначе
					ИмяТокена = ТокенВниз.Name;
					// Терминальный токен
					Если Ложь // Перед ними не ставим пробел
						Или ИмяТокена = ")"
						Или ИмяТокена = "]"
						Или ИмяТокена = ","
						Или ИмяТокена = "."
						Или ИмяТокена = ".*"
						Или (Истина
							И ИндексТокена = 1
							И ИмяТокена = "(")
					Тогда
						// Закомментировано 28.02.2016
						//Если ИмяТокена = ")" Тогда 
						//	Отступ = Отступ - 1;
						//КонецЕсли; 
						РезультатСнизу = ТокенВниз.Data;
					ИначеЕсли Ложь
						Или ИмяТокена = "id"
						Или ИмяТокена = "BadID"
						Или ИмяТокена = "strLiteral"
						Или ИмяТокена = "numLiteral" 
						Или ИмяТокена = "refLiteral" 
						Или ИмяТокена = "Parameter" 
						Или ИмяТокена = "MultiCommentLine"
						Или ИмяТокена = "COMP_OPERATOR"
						Или ИмяТокена = "("
						Или ИмяТокена = "["
						Или ИмяТокена = "&"
						Или ИмяТокена = "?"
						Или ИмяТокена = "@"
						Или ИмяТокена = "+"
						Или ИмяТокена = "-"
						Или ИмяТокена = "*"
						Или ИмяТокена = "/"
					Тогда
						Если ИмяТокена = "(" Тогда 
							Отступ = Отступ + 1;
						КонецЕсли; 
						Если Не ПустаяСтрока(Прав(Результат, 1)) Тогда
							ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
						КонецЕсли; 
						РезультатСнизу = ТокенВниз.Data;
					Иначе
						Если Ложь
							Или ИмяПравила = "<ID>"
							Или ИмяПравила = "<SmartID>"
							Или ИмяПравила = "<TableAS>"
						Тогда
							РезультатСнизу = ТокенВниз.Data;
						Иначе
							Если Не ПустаяСтрока(Прав(Результат, 1)) Тогда
								ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
							КонецЕсли; 
							РезультатСнизу = ПолучитьСловоЯзыкаЗапросов(ИмяТокена);
						КонецЕсли; 
					КонецЕсли; 
					ИмяПредыдущегоТокена = ИмяТокена;
				КонецЕсли;
				Результат = Результат + РезультатСнизу;
			КонецЦикла;
		КонецЕсли;
		Если ИмяПравила = "<Field>" Тогда
			Результат = ПолучитьПолноеИмяПоляВВыражении(Результат, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, РазрешитьНормализациюИмен,
				НужноПересобратьТокены);
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьАгрегатнуюФункцию(Токен, выхТокенАргументаФункции = Неопределено) Экспорт
	
	Результат = Неопределено;
	Если ТипЗнч(Токен) <> Тип("COMОбъект") Тогда
		Возврат Результат;
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	выхТокенАргументаФункции = Токен;
	Если Токен.Kind = 0 Тогда
		КоличествоТокенов = Данные.TokenCount;
		ИмяПравила = Данные.RuleText();
		Если ИмяПравила = "<Brackets>" Тогда
			Результат = ПолучитьАгрегатнуюФункцию(Данные.Tokens(1), выхТокенАргументаФункции);
		ИначеЕсли ИмяПравила = "<Agregate>" Тогда
			ТокенВниз = Данные.Tokens(0);
			Если ТокенВниз.Kind = 1 Тогда
				Результат = ТокенВниз.Name + "(";
				выхТокенАргументаФункции = Данные.Tokens(2);
			Иначе
				Результат = ПолучитьАгрегатнуюФункцию(ТокенВниз, выхТокенАргументаФункции);
			КонецЕсли; 
		ИначеЕсли ИмяПравила = "<Count>" Тогда
			ТокенВниз = Данные.Tokens(КоличествоТокенов - 2);
			//Если ТокенВниз.Kind = 0 Тогда
				Результат = "COUNT" + "(";
				Если КоличествоТокенов = 5 Тогда 
					Результат = Результат + " DISTINCT";
					выхТокенАргументаФункции = Данные.Tokens(3);
				Иначе
					выхТокенАргументаФункции = Данные.Tokens(2);
				КонецЕсли;
			//КонецЕсли;
		ИначеЕсли КоличествоТокенов = 1 Тогда
			Результат = ПолучитьАгрегатнуюФункцию(Данные.Tokens(0), выхТокенАргументаФункции);
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьЭлементОтбораПроизвольногоВыражения(Знач ЭлементОтбора, Знач Токен, Знач Отступ = 0, Знач ЧастьОбъединения = Неопределено, Знач ЗапросПакета = Неопределено)
	
	ЕстьАгрегаты = Ложь;
	Представление = СобратьВыражениеЗапроса(Токен, Отступ, ЗапросПакета, ЧастьОбъединения,,, ЕстьАгрегаты);
	ОбновитьЭлементОтбораПроизвольногоВыражения(ЕстьАгрегаты, Представление, Токен, ЭлементОтбора);
	
КонецПроцедуры

Процедура ОбновитьЭлементОтбораПроизвольногоВыражения(Знач ЕстьАгрегаты, Знач Представление, Знач Токен, Знач ЭлементОтбора)
	
	Если ЕстьАгрегаты Тогда
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("");
	Иначе
		ЭлементОтбора.ЛевоеЗначение = Неопределено;
	КонецЕсли; 
	ЭлементОтбора.ПравоеЗначение = Токен;
	ЭлементОтбора.Представление = Представление;

КонецПроцедуры

Функция ПолучитьВыражениеЭлементаОтбораЛкс(ЭлементОтбора, Знач Отступ = 0, Знач ГруппаИзОдногоЭлемента = Ложь, выхЕстьАгрегаты = Ложь, НастройкиКомпоновки = Неопределено) Экспорт

	Если НастройкиКомпоновки = Неопределено Тогда
		НастройкиКомпоновки = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока.Компоновщик.Настройки;
		#Если Сервер И Не Сервер Тогда
		    НастройкиКомпоновки = Новый НастройкиКомпоновкиДанных;
		#КонецЕсли
	КонецЕсли;
	Если ГруппаИзОдногоЭлемента Тогда
		Отступ = Макс(Отступ - 1, 0);
	КонецЕсли; 
	Смещение = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
	Если ЗначениеЗаполнено(ЭлементОтбора.Представление) Тогда
		Представление = ЭлементОтбора.Представление;
		Если ЭлементОтбора.ПравоеЗначение = Неопределено Тогда
			Токен = РазобратьВыражениеЗапроса(Представление);
			ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен,  Отступ);
		КонецЕсли; 
		ПредставлениеЭлемента = "";
		Если ЭлементОтбора.ЛевоеЗначение <> Неопределено Тогда
			выхЕстьАгрегаты = Истина;
		КонецЕсли;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ПредставлениеЭлемента, Представление, Смещение);
		//Если Истина
		//	И Не ЛиВыражениеЯвляетсяПолем(Представление)
		//	И Не ГруппаИзОдногоЭлемента 
		//Тогда
		//	ПредставлениеЭлемента = "(" + ПредставлениеЭлемента + ")";
		//КонецЕсли; 
	Иначе
		Если ТипЗнч(ЭлементОтбора.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			ДоступноеПолеИлиОписаниеТипов = НастройкиКомпоновки.ДоступныеПоляОтбора.НайтиПоле(ЭлементОтбора.ЛевоеЗначение);
			Если ДоступноеПолеИлиОписаниеТипов = Неопределено Тогда
				ДоступноеПолеИлиОписаниеТипов = Новый ОписаниеТипов("NULL");
			КонецЕсли;
		Иначе
			МассивТипов = Новый Массив();
			МассивТипов.Добавить(ТипЗнч(ЭлементОтбора.ЛевоеЗначение));
			ДоступноеПолеИлиОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
		КонецЕсли; 
		ПредставлениеЛевогоПоля = ПолучитьПредставлениеЗначенияНаЯзыке(ЭлементОтбора.ЛевоеЗначение);
		ПредставлениеЭлемента = ПолучитьПредставлениеСравненияНаЯзыке(ПредставлениеЛевогоПоля, ЭлементОтбора.ВидСравнения, ДоступноеПолеИлиОписаниеТипов, Отступ + 1);
		Если Истина
			И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.Заполнено
			И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.НеЗаполнено
		Тогда
			ПравоеЗначение = ЭлементОтбора.ПравоеЗначение;
			Если ТипЗнч(ПравоеЗначение) <> Тип("ПолеКомпоновкиДанных") Тогда
				XMLТип = СериализаторXDTO.XMLТипЗнч(ПравоеЗначение);
				Если XMLТип <> Неопределено Тогда
					Если Истина
						И Найти(XMLТип.URIПространстваИмен, "http://v8.1c.ru/8.1/data") > 0
						И Не ирОбщий.СтрокиРавныЛкс(XMLТип.ИмяТипа, "StandardBeginningDate")
					Тогда
						СтрокаПараметра = Параметры.Найти(ПравоеЗначение, "Значение");
						Если СтрокаПараметра = Неопределено Тогда
							БазовоеИмяПараметра = "" + ПравоеЗначение;
							Если Не ЗначениеЗаполнено(БазовоеИмяПараметра) Тогда
								БазовоеИмяПараметра = ирОбщий.ПолучитьПоследнийФрагментЛкс(XMLТип.ИмяТипа);
							КонецЕсли; 
							ИмяПараметра = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Параметры, БазовоеИмяПараметра,,, ПолучитьСловоЯзыкаЗапросов("Parameter"));
							СтрокаПараметра = Параметры.Добавить();
							СтрокаПараметра.Имя = ИмяПараметра;
							СтрокаПараметра.Значение = ПравоеЗначение;
							ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
						Иначе
							ИмяПараметра = СтрокаПараметра.Имя;
						КонецЕсли; 
						МассивТипов = Новый Массив();
						МассивТипов.Добавить(ТипЗнч(ПравоеЗначение));
						СтрокаПараметра.ТипЗначения = Новый ОписаниеТипов(СтрокаПараметра.ТипЗначения, МассивТипов);
						//СтрокаПараметра.ЧислоОбращений = СтрокаПараметра.ЧислоОбращений + 1;
						ПравоеЗначение = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + ИмяПараметра);
						ЭлементОтбора.ПравоеЗначение = ПравоеЗначение;
						ЗагрузитьДоступныеНастройкиКомпоновки();
						ЗагрузитьВыражениеУсловияСвязи();
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
			СтрокаПравогоЗначения = ПолучитьПредставлениеЗначенияНаЯзыке(ПравоеЗначение);
			Если Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит
			Тогда
				Если ТипЗнч(ПравоеЗначение) = Тип("Строка") Тогда
					СтрокаПравогоЗначения = ПолучитьПредставлениеЗначенияНаЯзыке("%" + ПравоеЗначение + "%");
				КонецЕсли; 
			ИначеЕсли Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке 
			Тогда
				СтрокаПравогоЗначения = "(" + СтрокаПравогоЗначения + ")";
			КонецЕсли;
			ПредставлениеЭлемента = ПредставлениеЭлемента + " " + СтрокаПравогоЗначения;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ПредставлениеЭлемента;

КонецФункции

// Параметры:
//  ФильтрацияАгрегатов - 
//		0 - не фильтровать
// 		1 - собирать только элементы без агрегатов
//		2 - собирать только элементы с агрегатами
//
Функция ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ГруппаОтбора, Отступ = 0, ФильтрацияАгрегатов = 0, выхЕстьАгрегаты = Ложь, НастройкиКомпоновки = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
		_Н = Новый НастройкиКомпоновкиДанных;
		ГруппаОтбора = _Н.Отбор;
	#КонецЕсли
	Если ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		ТипГруппы = ГруппаОтбора.ТипГруппы;
	Иначе
		ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
	КонецЕсли;
	ТекстГруппы = "";
	ГруппаИзОдногоЭлемента = ГруппаОтбора.Элементы.Количество() = 1;
	Смещение = ирОбщий.ПолучитьСтрокуПовторомЛкс(Символы.Таб, Отступ);
	СтрокаНе = "NOT";
	ЗначениеXDTO = СериализаторXDTO.ЗаписатьXDTO(ТипГруппы);
	Если ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
		ОператорГруппы = "AND";
	Иначе
		ОператорГруппы = ВРег(СтрЗаменить(ЗначениеXDTO.ЛексическоеЗначение, "Group", ""));
	КонецЕсли; 
	Если ОператорГруппы = "AND" Тогда
		НейтральныйЭлементГруппы = ПолучитьСловоЯзыкаЗапросов("TRUE");
	Иначе
		НейтральныйЭлементГруппы = ПолучитьСловоЯзыкаЗапросов("FALSE");
	КонецЕсли; 
	ОператорГруппы = ПолучитьСловоЯзыкаЗапросов(ОператорГруппы);
	СтрокаНе = ПолучитьСловоЯзыкаЗапросов(СтрокаНе);
	КоличествоСобранныхЭлементовГруппы = 0;
	БылиНейтральныеЭлементы = Ложь;
	БылиДобавленыВнешниеСкобки = Ложь;
	Для Каждого ЭлементОтбора Из ГруппаОтбора.Элементы Цикл
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли; 
		ПредставлениеЭлемента = "";
		БылиДобавленыВнешниеСкобкиЭлемента = Ложь;
		ЕстьАгрегаты = Ложь;
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			Если ГруппаИзОдногоЭлемента Тогда
				ОтступВложенный = Отступ;
			Иначе
				ОтступВложенный = Отступ + 1;
			КонецЕсли; 
			ПредставлениеЭлемента = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЭлементОтбора, ОтступВложенный, ФильтрацияАгрегатов, ЕстьАгрегаты, НастройкиКомпоновки);
			Если Истина
				И Не ГруппаИзОдногоЭлемента 
				И ЭлементОтбора.ТипГруппы <> ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе
			Тогда
				ПредставлениеЭлемента = "(" + ПредставлениеЭлемента + ")";
				БылиДобавленыВнешниеСкобкиЭлемента = Истина;
			КонецЕсли;
		Иначе
			ПредставлениеЭлемента = ПолучитьВыражениеЭлементаОтбораЛкс(ЭлементОтбора, Отступ + 1, ГруппаИзОдногоЭлемента, ЕстьАгрегаты, НастройкиКомпоновки);
		КонецЕсли; 
		Если ПредставлениеЭлемента = НейтральныйЭлементГруппы Тогда
			БылиНейтральныеЭлементы = Истина;
			Продолжить;
		КонецЕсли; 
		Если Ложь
			Или ТипЗнч(ГруппаОтбора) <> Тип("ОтборКомпоновкиДанных")
			Или ФильтрацияАгрегатов = 0
			Или (Истина
				И ФильтрацияАгрегатов = 1 
				И Не ЕстьАгрегаты)
			Или (Истина
				И ФильтрацияАгрегатов = 2 
				И ЕстьАгрегаты)
		Тогда
			Если ТекстГруппы <> "" Тогда
				ТекстГруппы = ТекстГруппы + Символы.ПС + Смещение + ОператорГруппы + " ";
			КонецЕсли; 
			ТекстГруппы = ТекстГруппы + ПредставлениеЭлемента;
			КоличествоСобранныхЭлементовГруппы = КоличествоСобранныхЭлементовГруппы + 1;
			Если КоличествоСобранныхЭлементовГруппы = 1 И БылиДобавленыВнешниеСкобкиЭлемента Тогда
				БылиДобавленыВнешниеСкобки = Истина;
			КонецЕсли; 
		КонецЕсли;
		выхЕстьАгрегаты = выхЕстьАгрегаты Или ЕстьАгрегаты;
	КонецЦикла;
	Если КоличествоСобранныхЭлементовГруппы = 1 И БылиДобавленыВнешниеСкобки Тогда
		ТекстГруппы = Сред(ТекстГруппы, 2, СтрДлина(ТекстГруппы) - 2);
	КонецЕсли; 
	Если Истина
		И ИерархическийСтильЛогическихВыражений 
		И (Ложь
			Или КоличествоСобранныхЭлементовГруппы > 1
			Или (Истина
		И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") // На корневом уровне оставляем ИСТИНА
		И БылиНейтральныеЭлементы))
	Тогда
		ТекстГруппы = НейтральныйЭлементГруппы + Символы.ПС + Смещение + ОператорГруппы + " " + ТекстГруппы;
	КонецЕсли; 
	Если Истина
		И ТекстГруппы <> "" 
		И (Ложь
			Или Отступ > 0
			Или ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе)
	Тогда
		////ТекстГруппы = "(" + ТекстГруппы + ")";
		Если ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
			ТекстГруппы = СтрокаНе + " (" + ТекстГруппы + ")";
		КонецЕсли;
	КонецЕсли;
	Возврат ТекстГруппы;
	
КонецФункции

Функция РазобратьВыражениеЗапроса(ВыражениеЗапроса, ЗаменятьПустоеНаNULL = Истина) Экспорт
	
	Если Не ЗначениеЗаполнено(ВыражениеЗапроса) И ЗаменятьПустоеНаNULL Тогда
		ВыражениеЗапроса = "NULL";
	КонецЕсли; 
	//ТекстДляРазбора = "ВЫБРАТЬ " + Символы.ПС + ВыражениеЗапроса + " КАК _";
	ТекстДляРазбора = "UPDATE _ SET _ = " + Символы.ПС + ВыражениеЗапроса;
	СлужебноеПолеТекстовогоДокумента.УстановитьТекст(ТекстДляРазбора); // Закомментировал 19.04.2015, Раскомментировал 27.04.2016
	//НачальныйТокен = РазобратьТекстЗапроса(ТекстДляРазбора, Истина, Ложь); // Сокращенное дерево не даст общими методами строить вложенные запросы
	НачальныйТокен = РазобратьТекстЗапроса(ТекстДляРазбора, , Ложь);
	Если НачальныйТокен = Неопределено Тогда
		ВызватьИсключение "Ошибка синтаксического разбора выражения """ + ВыражениеЗапроса + """";
	КонецЕсли; 
	//НачальныйТокен = НачальныйТокен.Data.Tokens(0).Data.Tokens(3).Data.Tokens(1); // При сокращенном дереве
	//НачальныйТокен = НачальныйТокен.Data.Tokens(0).Data.Tokens(0).Data.Tokens(0).Data.Tokens(0).Data.Tokens(3).Data.Tokens(0).Data.Tokens(1); // При ВЫБРАТЬ
	НачальныйТокен = НачальныйТокен.Data.Tokens(0).Data.Tokens(0).Data.Tokens(5).Data.Tokens(0).Data.Tokens(1).Data.Tokens(1); // При UPDATE <UpdateRoot>
	Возврат НачальныйТокен;
	
КонецФункции

Функция ДобавитьЧастьОбъединения(ЗапросПакета)

	ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения.Добавить();
	ЧастьОбъединения.Номер = ЗапросПакета.ЧастиОбъединения.Количество();
	ЧастьОбъединения.ВыбранныеТаблицы = ВыбранныеТаблицы.СкопироватьКолонки();
	ЧастьОбъединения.ВыбранныеПоля = ВыбранныеПоля.СкопироватьКолонки();
	ЧастьОбъединения.СвязиТаблиц = ирОбщий.СкопироватьКолонкиДереваЗначенийЛкс(СвязиТаблиц);
	ЧастьОбъединения.Группировки = Группировки.СкопироватьКолонки();
	ЧастьОбъединения.ПоляВыбораПостроителя = ПоляВыбораПостроителя.СкопироватьКолонки();
	ЧастьОбъединения.ПоляОтбораПостроителя = ПоляОтбораПостроителя.СкопироватьКолонки();
	ЧастьОбъединения.ОпцияРазличные = Ложь;
	ЧастьОбъединения.ОпцияДляИзменения = Ложь;
	ЧастьОбъединения.Автогруппировки = Истина;
	//ЧастьОбъединения.Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	
	//ЧастьОбъединения.Условие = ЧастьОбъединения.Компоновщик.Настройки;
	ОбновитьНаименованиеЧасти(ЧастьОбъединения);
	Возврат ЧастьОбъединения;

КонецФункции

Функция ДобавитьЗапросПакета(Пакет = Неопределено, Позиция = Неопределено)

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли; 
	Если Позиция = Неопределено Тогда
		ЗапросПакета = Пакет.Добавить();
	Иначе
		ЗапросПакета = Пакет.Вставить(Позиция);
	КонецЕсли; 
	ЗапросПакета.ИД = Новый УникальныйИдентификатор();
	ЗапросПакета.Индекс = ЗапросыПакета.Количество() - 1;
	ЗапросПакета.ЧастиОбъединения = ЧастиОбъединения.СкопироватьКолонки();
	ЗапросПакета.ПоляОбъединения = ПоляОбъединения.СкопироватьКолонки();
	ЗапросПакета.ГруппирующиеПоляИтогов = ГруппирующиеПоляИтогов.СкопироватьКолонки();
	ЗапросПакета.ГруппируемыеПоляИтогов = ГруппируемыеПоляИтогов.СкопироватьКолонки();
	ЗапросПакета.ПоляПорядкаПостроителя = ПоляПорядкаПостроителя.СкопироватьКолонки();
	ЗапросПакета.ПоляИтоговПостроителя = ПоляИтоговПостроителя.СкопироватьКолонки();
	ЗапросПакета.ОпцияОбщиеИтоги = Ложь;
	ЗапросПакета.ОпцияПервые = Ложь;
	ЗапросПакета.ОпцияРазрешенные = Ложь;
	ЗапросПакета.ОпцияАвтоупорядочивание = Ложь;
	ЗапросПакета.ПервыеКоличество = 1;
	ЗапросПакета.ИмяОсновнойТаблицы = "";
	ЗапросПакета.ПоляПорядка = ПоляПорядка.СкопироватьКолонки();
	ЗапросПакета.ПоляИндекса = ПоляИндекса.СкопироватьКолонки();
	ЗапросПакета.ПринимающиеПоля = ПринимающиеПоля.СкопироватьКолонки();
	ЗапросПакета.ТипЗапроса = 0;
	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	Возврат ЗапросПакета;

КонецФункции

Функция ДобавитьВыбраннуюТаблицу(ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Добавить();
	ВыбраннаяТаблица.Параметры = ПараметрыТаблицы.СкопироватьКолонки();
	Возврат ВыбраннаяТаблица;
	
КонецФункции

Функция ПолучитьИмяБезКвадратныхСкобок(Имя)
	
	Результат = Имя;
	Если Лев(Результат, 1) = "[" Тогда
		Результат = Сред(Результат, 2, СтрДлина(Результат) - 2);
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ОпуститьсяДоПервогоЗначимогоТокена(Токен)

	Если Токен.Kind = 0 Тогда
		Возврат Токен;
	КонецЕсли; 
	Данные = Токен.Data;
	ИмяПравила = Данные.RuleText();
	Если ИмяПравила = "<Brackets>" Тогда
		ЗначимыйТокен = ОпуститьсяДоПервогоЗначимогоТокена(Данные.Tokens(1));
		Возврат ЗначимыйТокен;
	ИначеЕсли Данные.TokenCount > 1  Тогда
		Возврат Токен;
	Иначе
		ПервыйТокен = Данные.Tokens(0);
		Если ПервыйТокен.Kind <> 0 Тогда
			Возврат Токен;
		Иначе
			Возврат ОпуститьсяДоПервогоЗначимогоТокена(ПервыйТокен);
		КонецЕсли; 
	КонецЕсли;
	
КонецФункции

Процедура ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Токен, ЗапросПакета, ЧастьОбъединения)

	#Если Сервер И Не Сервер Тогда
	    ОтборКомпоновки1 = Новый НастройкиКомпоновкиДанных;
		ГруппаОтбора = ОтборКомпоновки1.Отбор;
	#КонецЕсли
	Если Токен = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если Токен.Kind = 1 Тогда
		ИмяТокена = Токен.Name;
		Если ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ТипГруппы = ГруппаОтбора.ТипГруппы; 
		Иначе
			ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
		КонецЕсли;
		Если Ложь
			Или (Истина
				И ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
				И ИмяТокена = "FALSE")
			Или (Истина
				И ТипГруппы <> ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
				И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") // На корневом уровне оставляем ИСТИНА
				И ИмяТокена = "TRUE")
		Тогда
			Возврат;
		КонецЕсли; 
		ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ПравоеЗначение = Токен;
		Если Ложь
			Или ИмяТокена = "TRUE"
			Или ИмяТокена = "FALSE"
		Тогда
			ЭлементОтбора.Представление = ПолучитьСловоЯзыкаЗапросов(ИмяТокена);
		Иначе
			ВыражениеТокена = Токен.Data;
			ЭлементОтбора.Представление = ВыражениеТокена;
			Если Токен.text = "<Parameter>" Тогда
				ПроверитьДобавитьПараметр(ВыражениеТокена);
			КонецЕсли; 
		КонецЕсли; 
		Возврат;
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные.TokenCount = 0 Тогда
		Возврат;
	ИначеЕсли Данные.TokenCount = 1 Тогда
		ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
	Иначе
		ИмяПравила = Данные.RuleText();
		Если ИмяПравила = "<OrExpr>" Тогда
			Если Истина
				И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
				И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			Тогда
				ГруппаИли = ГруппаОтбора;
			Иначе
				ГруппаИли = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				ГруппаИли.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
			КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаИли, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ПостроитьДеревоЛогическогоВыражения(ГруппаИли, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ИначеЕсли ИмяПравила = "<AndExpr>" Тогда
			Если Истина
				И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
				И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			Тогда
				ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
			Иначе
				ГруппаИ = ГруппаОтбора;
			КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ИначеЕсли ИмяПравила = "<NotExpr>" Тогда
			ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения)
		ИначеЕсли Ложь
			Или ИмяПравила = "<CheckNULL>"
			Или ИмяПравила = "<CheckNotNULL>"
			Или ИмяПравила = "<CheckValueIn>"
			Или ИмяПравила = "<CompareExpr>"
			Или ИмяПравила = "<CheckLIKE>"
			//Или ИмяПравила = "<CheckExpr>"
		Тогда
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЛевоеЗначение = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение;
			Если ЛевоеЗначение = Неопределено Тогда
				ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, , ЧастьОбъединения, ЗапросПакета);
			//ИначеЕсли ИмяПравила = "<CheckNULL>" Тогда
			//	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
			//ИначеЕсли ИмяПравила = "<CheckNotNULL>" Тогда
			//	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
			Иначе
				ТокенИерархии = Неопределено;
				Если ИмяПравила = "<CheckValueIn>" Тогда
					ПравыйТокен = Данные.Tokens(1).Data.Tokens(0);
					ТокенИерархии = ПравыйТокен.Data.Tokens(1);
					Если ПравыйТокен.Text = "<InExprs>" Тогда
						ПравыйТокен = ПравыйТокен.Data.Tokens(3);
					Иначе//Если ПравыйТокен.Text = "<InUnion>" Тогда
						ПравыйТокен = ПравыйТокен.Data.Tokens(2);
					КонецЕсли; 
				//ИначеЕсли ИмяПравила = "<CompareExpr>" Тогда
				//	ПравыйТокен = Данные.Tokens(2);
				//ИначеЕсли ИмяПравила = "<CheckExpr>" Тогда
				//	ПравыйТокен = Данные.Tokens(3);
				Иначе
					ПравыйТокен = Данные.Tokens(2);
				КонецЕсли; 
				ПравоеЗначение = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(ПравыйТокен, ЗапросПакета, ЧастьОбъединения);
				ЭлементОтбора.ПравоеЗначение = ПравоеЗначение;
				Если ПравоеЗначение = Неопределено Тогда
					ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, , ЧастьОбъединения, ЗапросПакета);
				ИначеЕсли ИмяПравила = "<CompareExpr>" Тогда
					ОператорСравнения = Данные.Tokens(1).Data;
					Если ОператорСравнения = "=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
					ИначеЕсли ОператорСравнения = "<>" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно;
					ИначеЕсли ОператорСравнения = ">" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Больше;
					ИначеЕсли ОператорСравнения = "<" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Меньше;
					ИначеЕсли ОператорСравнения = "<=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно;
					ИначеЕсли ОператорСравнения = ">=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно;
					Иначе
						ВызватьИсключение "Неизвестный вид сравнения """ + ОператорСравнения + """";
					КонецЕсли; 
					ЭлементОтбора.ВидСравнения = лВидСравнения;
				ИначеЕсли ИмяПравила = "<CheckLIKE>" Тогда
					Если Истина
						И Лев(ПравоеЗначение, 1) = "%"
						И Прав(ПравоеЗначение, 1) = "%"
					Тогда
						ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит;
						ЭлементОтбора.ПравоеЗначение = Сред(ПравоеЗначение, 2, СтрДлина(ПравоеЗначение) - 2);
					Иначе
						ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, , ЧастьОбъединения, ЗапросПакета);
					КонецЕсли; 
				ИначеЕсли ИмяПравила = "<CheckValueIn>" Тогда
					Если ТокенИерархии.Data.Tokens(0) = Неопределено Тогда
						ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
					Иначе
						ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли;
		ИначеЕсли ИмяПравила = "<Brackets>" Тогда
			//Если Истина
			//	И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
			//	И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			//Тогда
			//	ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			//	ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
			//Иначе
			//	ГруппаИ = ГруппаОтбора;
			//КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения);
		Иначе
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЗначимыйТокен = ОпуститьсяДоПервогоЗначимогоТокена(Токен);
			//ЕстьАгрегаты = Ложь;
			//ВыражениеЭлемента = СобратьВыражениеЗапроса(ЗначимыйТокен,, ЗапросПакета, ЧастьОбъединения,,, ЕстьАгрегаты);
			//ОбновитьЭлементОтбораПроизвольногоВыражения(ЕстьАгрегаты, ВыражениеЭлемента, Токен, ЭлементОтбора);
			ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, ЗначимыйТокен,, ЧастьОбъединения, ЗапросПакета);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОсновныеДействияФормыОК(Кнопка = Неопределено)
	
	Если мРежимРедактированияТекста Тогда
		Ответ = Вопрос("Конструктор находится в режиме редактирования текста запроса. Хотите сохранить загрузить новый текст перед закрытием?", РежимДиалогаВопрос.ДаНетОтмена);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			КПТекстРедактировать();
		ИначеЕсли Ответ = КодВозвратаДиалога.Нет Тогда
			ПереключитьРежимРедактированияТекста();
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли; 
	ЭтаФорма.Модифицированность = Ложь;
	// Возвращаем текст всегда на диалекте источника
	Если Ложь
		Или мДиалектSQL <> ДиалектSQL 
	Тогда
		ДиалектSQL = мДиалектSQL;
		ОбновитьВсеВыраженияСИндикацией();
	КонецЕсли; 
	СобратьПолныйТекст(, Истина);
	Если Не ЭлементыФормы.Параметры.ТолькоПросмотр Тогда  
		ЭтотОбъект.Параметры.Загрузить(Параметры); // Здесь могут теряться значения параметров, т.к. загрузка выполняется в ТЧ
		Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
			Для Каждого СтрокаПараметра Из Параметры Цикл
				КонтекстВыполнения.Параметры.Вставить(СтрокаПараметра.Имя, СтрокаПараметра.Значение);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли; 
	Закрыть(Истина);
	
КонецПроцедуры

Функция ПолучитьОпределениеТаблицы(ИмяИлиСтрокаВыбраннойТаблицы, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, Смещение = "")
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ТипЗнч(ИмяИлиСтрокаВыбраннойТаблицы) = Тип("Строка") Тогда
		СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяИлиСтрокаВыбраннойТаблицы), "НИмя");
	Иначе
		СтрокаВыбраннойТаблицы = ИмяИлиСтрокаВыбраннойТаблицы;
	КонецЕсли; 
	Если ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.ПолноеИмя) Тогда
		ПолноеИмя = СтрокаВыбраннойТаблицы.ПолноеИмя;
		Если Истина
			И Найти(ПолноеИмя, ".") = 0 
			И Лев(ПолноеИмя, 1) <> "["
		Тогда
			Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмя);
			Результат = "";
			Для Каждого Фрагмент Из Фрагменты Цикл
				Если Результат <> "" Тогда
					Результат = Результат + ".";
				КонецЕсли; 
				Если Истина
					И Не ирОбщий.ЛиИмяПеременнойЛкс(Фрагмент) 
					И Не (Истина
						И Лев(Фрагмент, 1) = ПараметрыДиалектаSQL.ПрефиксПараметра
						И ирОбщий.ЛиИмяПеременнойЛкс(Сред(Фрагмент, 2)))
					И Не (Истина
						И ПараметрыДиалектаSQL.Это1С
						И Лев(Фрагмент, 1) = "#"
						И ирОбщий.ЛиИмяПеременнойЛкс(Сред(Фрагмент, 2)))
				Тогда
					Фрагмент = "[" + Фрагмент + "]";
				КонецЕсли; 
				Результат = Результат + Фрагмент;
			КонецЦикла;
		Иначе
			Результат = ПолноеИмя;
		КонецЕсли; 
		ТекстПараметров = "";
		Индекс = 0;
		Для каждого ПараметрТаблицы Из СтрокаВыбраннойТаблицы.Параметры Цикл
			Если Индекс > 0 Тогда
				ТекстПараметров = ТекстПараметров + ",";
			КонецЕсли; 
			ТекстПараметров = ТекстПараметров + Символы.ПС + Смещение + Символы.Таб;
			ТекстВыражения = ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, ЗапросПакета, ЧастьОбъединения,,, Истина,, Ложь, 0);
			Если ЗначениеЗаполнено(ПараметрТаблицы.ТекстРасширения) Тогда
				Если ЗначениеЗаполнено(ТекстВыражения) Тогда
					ТекстВыражения = ТекстВыражения + " ";
				КонецЕсли; 
				ТекстВыражения = ТекстВыражения + "{" + ПараметрТаблицы.ТекстРасширения + "}";
			КонецЕсли; 
			//ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПараметров, ТекстВыражения, Смещение + Символы.Таб,, Истина); // Так условия типа Поле "В (ВЫБРАТЬ ...)" кривые отступы получали
			ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПараметров, ТекстВыражения, Смещение + Символы.Таб);
			Индекс = Индекс + 1;
		КонецЦикла;
		Если ЗначениеЗаполнено(ТекстПараметров) Тогда
			Результат = Результат + "(" + ТекстПараметров + ")";
		КонецЕсли; 
	ИначеЕсли СтрокаВыбраннойТаблицы.ВложенныйПакет <> Неопределено Тогда
		лТекстПакета = СобратьТекстПакета(СтрокаВыбраннойТаблицы.ВложенныйПакет, Смещение);
		Результат = "(" + СокрЛ(лТекстПакета) + ")";
	Иначе
		ВызватьИсключение "У выбранной таблицы отсутствует определение"; 
	КонецЕсли; 
	Если Истина
		И ПараметрыДиалектаSQL.МногоТаблиц
		И ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.Имя) 
	Тогда
		Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаВыбраннойТаблицы.Имя);
	КонецЕсли; 
	Если ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.УровеньИзоляции) Тогда
		Результат = Результат + " WITH(" + СтрокаВыбраннойТаблицы.УровеньИзоляции + ")";
	КонецЕсли; 
	КомментарийТаблицы = ПолучитьКомментарийДляВставки(СтрокаВыбраннойТаблицы.Комментарий, Смещение);
	Если ЗначениеЗаполнено(КомментарийТаблицы) Тогда
		Результат = КомментарийТаблицы + Результат;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьИмяСНеобходимымиСкобками(Имя)
	
	Результат = Имя;
	Если Не ирОбщий.ЛиИмяПеременнойЛкс(Имя) Тогда
		Результат = "[" + Имя + "]";
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Параметры:
//   ЛиСобратьПакет - Булево, *Неопределено - собирать пакет, иначе только текущего запроса пакета
//
Функция СобратьПолныйТекст(Смещение = "", ЛиСобратьПакет = Неопределено) Экспорт 
	
	Если ЛиСобратьПакет = Неопределено Тогда
		ЛиСобратьПакет = ПолеТекстаОтображаетПакет;
	КонецЕсли; 
	ЗакончитьРедактированиеСвязанныхПолей();
	Если ЛиСобратьПакет Тогда
		Текст = СобратьТекстПакета();
		//Если Смещение = "" И ЗапросыПакета.Количество() > 1 Тогда
		//	Текст = "//" + мМаркерСлужебногоКомментария + "Текст собран конструктором из подсистемы ""Инструменты разработчика"" (http://devtool1c.ucoz.ru), который сохраняет звездочки и комментарии.
		//	|" + Текст;
		//КонецЕсли; 
	Иначе
		Состояние("Сборка текста запроса пакета...");
		Текст = СобратьТекстЗапросаПакета();
	КонецЕсли; 
	Состояние();
	Возврат Текст;
	
КонецФункции

Функция СобратьТекстПакета(Пакет = Неопределено, Смещение = "")

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
		Индикатор = ирОбщий.ПолучитьИндикаторПроцессаЛкс(Пакет.Количество(), "Сборка текста пакета");
	КонецЕсли; 
	Результат = "";
	ИндексЗапроса = 0;
	Для Каждого ЗапросПакета Из Пакет Цикл
		Если Индикатор <> Неопределено Тогда
			ирОбщий.ОбработатьИндикаторЛкс(Индикатор);
		КонецЕсли; 
		ТекстЗапроса = СобратьТекстЗапросаПакета(ЗапросПакета, Смещение);
		Если Результат <> "" Тогда
			Результат = Результат + "
			|;
			|";
			//Если Истина
			//	И Лев(ТекстЗапроса, СтрДлина(ПараметрыДиалектаSQL.СтрочныйКомментарий)) <> ПараметрыДиалектаSQL.СтрочныйКомментарий
			//Тогда
			//КонецЕсли; 
		КонецЕсли; 
		Если Смещение = "" И Пакет.Количество() > 1 Тогда
			Если ЗапросПакета.РучноеИмя Тогда
				ИмяЗапросаВПакете = ЗапросПакета.Имя;
			Иначе
				ИмяЗапросаВПакете = ИндексЗапроса;
			КонецЕсли; 
			Результат = Результат + Смещение + ПараметрыДиалектаSQL.СтрочныйКомментарий + мПлатформа.мМаркерИмениЗапросаПакета + ИмяЗапросаВПакете + " " 
				+ ирОбщий.ПолучитьСтрокуПовторомЛкс(ПараметрыДиалектаSQL.СтрочныйКомментарий, 20) + "
			|";
		КонецЕсли; 
		Результат = Результат + ТекстЗапроса;
		ИндексЗапроса = ИндексЗапроса + 1;
	КонецЦикла; 
	Если Индикатор <> Неопределено Тогда
		ирОбщий.ОсвободитьИндикаторПроцессаЛкс();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция СобратьТекстЗапросаПакета(ЗапросПакета = Неопределено, Смещение = "")

	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Результат = "";
	Если ЗапросПакета.ТипЗапроса = 2 Тогда
		// DROP
		Результат = Результат + ПолучитьКомментарийДляВставки(ЗапросПакета.Комментарий, Смещение);
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + ПолучитьСловоЯзыкаЗапросов("DROP") + " ";
		Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
			Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
		КонецЕсли; 
		Результат = Результат + XMLСтрока(ЗапросПакета.ИмяОсновнойТаблицы);
		Возврат Результат;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 6 Тогда
		// TRUNCATE
		Результат = Результат + ПолучитьКомментарийДляВставки(ЗапросПакета.Комментарий, Смещение);
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TRUNCATE") + " ";
		Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
			Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
		КонецЕсли; 
		Результат = Результат + XMLСтрока(ЗапросПакета.ИмяОсновнойТаблицы);
		Возврат Результат;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 3 Тогда
		// INSERT
		Результат = Результат + ПолучитьКомментарийДляВставки(ЗапросПакета.Комментарий, Смещение);
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		ТекстПринимающиеПоля = "";
		ТекстВыраженияЗначений = "";
		Для Каждого ПринимающееПоле Из ЗапросПакета.ПринимающиеПоля Цикл
			Если ТекстПринимающиеПоля <> "" Тогда
				ТекстПринимающиеПоля = ТекстПринимающиеПоля + ", ";
				ТекстВыраженияЗначений = ТекстВыраженияЗначений + "," + Смещение + Символы.Таб;
			КонецЕсли; 
			ТекстПринимающиеПоля = ТекстПринимающиеПоля + ПринимающееПоле.Поля;
			Если Не ЗапросПакета.ЗначенияИзВыборки Тогда
				ВыражениеПоля = ОбновитьВыражениеЗапроса(ПринимающееПоле,,,,,,,,, 0);
				ТекстВыраженияЗначений = ТекстВыраженияЗначений + ВыражениеПоля;
				ТекстВыраженияЗначений = ТекстВыраженияЗначений + " " + ПолучитьКомментарийДляВставки(ПринимающееПоле.Поля, Смещение + Символы.Таб);
			КонецЕсли; 
		КонецЦикла;
		Результат = Результат + "INSERT INTO " + ЗапросПакета.ИмяОсновнойТаблицы;
		Если ЗначениеЗаполнено(ЗапросПакета.УровеньИзоляции) Тогда
			Результат = Результат + " WITH(" + ЗапросПакета.УровеньИзоляции + ")";
		КонецЕсли; 
		Результат = Результат + " (" + ТекстПринимающиеПоля + ")" + Символы.ПС;
		Если Не ЗапросПакета.ЗначенияИзВыборки Тогда
			Результат = Результат + "VALUES (" + ТекстВыраженияЗначений + ")";
			Возврат Результат;
		КонецЕсли; 
	ИначеЕсли ЗапросПакета.ТипЗапроса = 4 Тогда
		// UPDATE
		ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0];
		Результат = Результат + ПолучитьКомментарийДляВставки(ЧастьОбъединения.Комментарий, Смещение);
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		ТекстПринимающиеПоля = "";
		Для Каждого ПринимающееПоле Из ЗапросПакета.ПринимающиеПоля Цикл
			Если ТекстПринимающиеПоля <> "" Тогда
				ТекстПринимающиеПоля = ТекстПринимающиеПоля + "," + Символы.ПС + Смещение + Символы.Таб;
			КонецЕсли; 
			ТекстПринимающиеПоля = ТекстПринимающиеПоля + ПринимающееПоле.Поля + " = ";
			ТекстПринимающиеПоля = ТекстПринимающиеПоля + ОбновитьВыражениеЗапроса(ПринимающееПоле,,,,,,,,, 0);
		КонецЦикла;
		Если ТекстПринимающиеПоля <> "" Тогда
			Результат = Результат + "UPDATE " + ЗапросПакета.ИмяОсновнойТаблицы;
			Если ЗначениеЗаполнено(ЗапросПакета.УровеньИзоляции) Тогда
				Результат = Результат + " WITH(" + ЗапросПакета.УровеньИзоляции + ")";
			КонецЕсли; 
			Результат = Результат + " SET " + Символы.ПС + Смещение + Символы.Таб + ТекстПринимающиеПоля;
		КонецЕсли; 
		ТекстИЗ = СобратьТекстИЗ(ЗапросПакета, ЧастьОбъединения, Смещение);
		Результат = Результат + ТекстИЗ;
		ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Компоновщик.Настройки.Отбор, 1, , , ЧастьОбъединения.Компоновщик.Настройки);
		ДобавитьТекстОтбора(Результат, Смещение, ТекстУсловия, ЧастьОбъединения);
		Возврат Результат;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 5 Тогда
		// DELETE
		ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0];
		Результат = Результат + ПолучитьКомментарийДляВставки(ЧастьОбъединения.Комментарий, Смещение);
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + "DELETE FROM " + ЗапросПакета.ИмяОсновнойТаблицы;
		Если ЗначениеЗаполнено(ЗапросПакета.УровеньИзоляции) Тогда
			Результат = Результат + " WITH(" + ЗапросПакета.УровеньИзоляции + ")";
		КонецЕсли; 
		ТекстИЗ = СобратьТекстИЗ(ЗапросПакета, ЧастьОбъединения, Смещение);
		Результат = Результат + ТекстИЗ;
		ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Компоновщик.Настройки.Отбор, 1, , , ЧастьОбъединения.Компоновщик.Настройки);
		ДобавитьТекстОтбора(Результат, Смещение, ТекстУсловия, ЧастьОбъединения);
		Возврат Результат;
	КонецЕсли; 
	
	ТекстОбъединения = "";
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		ТекстЧасти = СобратьТекстЧастиОбъединения(ЗапросПакета, ЧастьОбъединения, Смещение, ЗапросПакета.ЧастиОбъединения.Количество() > 1);
		Если ТекстОбъединения <> "" Тогда
			ТекстОбъединения = ТекстОбъединения + "
			|" + Смещение + ПолучитьСловоЯзыкаЗапросов("UNION");
			Если Не ЧастьОбъединения.БезДублей Тогда
				ТекстОбъединения = ТекстОбъединения + " " + ПолучитьСловоЯзыкаЗапросов("ALL");
			КонецЕсли; 
			ТекстОбъединения = ТекстОбъединения + Символы.ПС + Смещение;
		КонецЕсли; 
		Если ЧастьОбъединения.РучноеИмя Тогда
			ТекстОбъединения = ТекстОбъединения + ПараметрыДиалектаSQL.СтрочныйКомментарий + мПлатформа.мМаркерИмениЧастиОбъединения + ЧастьОбъединения.Имя + " " 
				+ ирОбщий.ПолучитьСтрокуПовторомЛкс(ПараметрыДиалектаSQL.СтрочныйКомментарий, 20);
			ТекстОбъединения = ТекстОбъединения + Символы.ПС + Смещение;
		КонецЕсли; 
		ТекстОбъединения = ТекстОбъединения + ТекстЧасти;
	КонецЦикла;
	Если ЗначениеЗаполнено(ТекстОбъединения) Тогда
		Результат = Результат + ТекстОбъединения;
	КонецЕсли; 
	
	// ORDER BY
	ТекстПорядок = "";
	Для Каждого ЭлементПорядка Из ЗапросПакета.ПоляПорядка Цикл
		Если ТекстПорядок <> "" Тогда
			ТекстПорядок = ТекстПорядок + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПорядок = ТекстПорядок + ПолучитьКомментарийДляВставки(ЭлементПорядка.Комментарий, Смещение + Символы.Таб);
		ТекстВыражения = ОбновитьВыражениеЗапроса(ЭлементПорядка, ЭлементыФормы.ПоляПорядка, ЗапросПакета,,,,,, Ложь, 0);
		ТекстПорядок = ТекстПорядок + ТекстВыражения;
		Если ЭлементПорядка.Иерархия Тогда
			ТекстПорядок = ТекстПорядок + " " + ПолучитьСловоЯзыкаЗапросов("HIERARCHYON");
		КонецЕсли; 
		Если ЭлементПорядка.Направление = НаправлениеСортировки.Убыв Тогда
			ТекстПорядок = ТекстПорядок + " " + ПолучитьСловоЯзыкаЗапросов("DESC");
		КонецЕсли; 
	КонецЦикла;
	Если ТекстПорядок <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("ORDER") + " " + ПолучитьСловоЯзыкаЗапросов("BY") 
			+ Символы.ПС + Смещение + Символы.Таб + ТекстПорядок;
	КонецЕсли; 
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("ORDER") + " " + ПолучитьСловоЯзыкаЗапросов("BY"),
		ЗапросПакета.ПоляПорядкаПостроителя, ЭлементыФормы.ПоляПорядкаПостроителя, ЗапросПакета, , Смещение);
	
	Если Истина
		И ЗапросПакета.ОпцияПервые
		И (Ложь
			Или ДиалектSQL = "SQLite" 
			Или ДиалектSQL = "PostgreSQL" 
			Или ДиалектSQL = "MySQL")
	Тогда
		Результат = Результат + Символы.ПС + ПолучитьСловоЯзыкаЗапросов("LIMIT") + " " + XMLСтрока(ЗапросПакета.ПервыеКоличество);
	КонецЕсли; 
	
	Если ПараметрыДиалектаSQL.INTOпослеORDER Тогда
		Если ирОбщий.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 1) Тогда
			Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INTO") + " ";
			Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
				Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
			КонецЕсли; 
			Результат = Результат + XMLСтрока(ЗапросПакета.ИмяОсновнойТаблицы);
		КонецЕсли; 
	КонецЕсли; 
	
	// INDEX BY
	ТекстИндекс = "";
	Для Каждого ЭлементИндекса Из ЗапросПакета.ПоляИндекса Цикл
		Если ТекстИндекс <> "" Тогда
			ТекстИндекс = ТекстИндекс + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстИндекс = ТекстИндекс + ПолучитьКомментарийДляВставки(ЭлементИндекса.Комментарий, Смещение + Символы.Таб);
		ТекстИндекс = ТекстИндекс + ЭлементИндекса.Определение;
	КонецЦикла;
	Если ТекстИндекс <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INDEX") 
			+ " " + ПолучитьСловоЯзыкаЗапросов("BY") + Символы.ПС + Смещение + Символы.Таб + ТекстИндекс;
	КонецЕсли; 
	
	// TOTALS
	ТекстГруппирующиеПоля = "";
	Если ЗапросПакета.ОпцияОбщиеИтоги Тогда
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + ПолучитьСловоЯзыкаЗапросов("OVERALL");
	КонецЕсли; 
	Для Каждого СтрокаПоля Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		Если ТекстГруппирующиеПоля <> "" Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + ПолучитьКомментарийДляВставки(СтрокаПоля.Комментарий, Смещение + Символы.Таб);
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + СтрокаПоля.Определение;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ЗначениеЗаполнено(СтрокаПоля.Имя) 
		Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоля.Имя);
		КонецЕсли; 
		Если ирОбщий.СтрокиРавныЛкс(СтрокаПоля.ТипИтогов, "Иерархия") Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + " " + ПолучитьСловоЯзыкаЗапросов("HIERARCHYON");
		КонецЕсли; 
	КонецЦикла;
	ТекстИтоговыеПоля = "";
	Для Каждого СтрокаПоля Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		Если ТекстИтоговыеПоля <> "" Тогда
			ТекстИтоговыеПоля = ТекстИтоговыеПоля  + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстИтоговыеПоля = ТекстИтоговыеПоля + ПолучитьКомментарийДляВставки(СтрокаПоля.Комментарий, Смещение + Символы.Таб);
		ТекстИтоговыеПоля = ТекстИтоговыеПоля + СтрокаПоля.Определение;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц 
			И ЗначениеЗаполнено(СтрокаПоля.Имя) 
		Тогда
			ТекстИтоговыеПоля = ТекстИтоговыеПоля + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоля.Имя);
		КонецЕсли; 
	КонецЦикла;
	Если Ложь
		Или ТекстГруппирующиеПоля <> ""
		Или ТекстИтоговыеПоля <> ""
	Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("TOTALS");
		Если ЗначениеЗаполнено(ТекстИтоговыеПоля) Тогда
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстИтоговыеПоля;
		КонецЕсли; 
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("BY");
		Если ЗначениеЗаполнено(ТекстГруппирующиеПоля) Тогда
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстГруппирующиеПоля;
		КонецЕсли; 
	КонецЕсли; 
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("TOTALS") + " " + ПолучитьСловоЯзыкаЗапросов("BY"),
		ЗапросПакета.ПоляИтоговПостроителя, ЭлементыФормы.ПоляИтоговПостроителя, ЗапросПакета, , Смещение);
	
	Если Истина
		И ПараметрыДиалектаSQL.Это1С
		И ЗапросПакета.ОпцияАвтоупорядочивание 
	Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("AUTOORDER");
	КонецЕсли; 

	//Если ЗначениеЗаполнено(ЗапросПакета.ТекстРасширения) Тогда
	//	Результат = Результат + Символы.ПС + "{" + ЗапросПакета.ТекстРасширения + "}";
	//КонецЕсли; 
	
	Возврат Результат;

КонецФункции

Процедура ДобавитьТекстПредложенияПостроителя(ОбщийТекст, ПредложениеПостроителя, ТаблицаПолейПостроителя, ТабличноеПолеПостроителя, ЗапросПакета,
	ЧастьОбъединения = Неопределено, Смещение = "")
	
	ТекстПостроителя = "";
	Для Каждого ПолеПостроителя Из ТаблицаПолейПостроителя Цикл
		ТекстВыражения = ПолучитьОбновитьВыражениеПоляПостроителя(ПолеПостроителя, ТабличноеПолеПостроителя, ЗапросПакета, ЧастьОбъединения);
		ТекстКомментария = ПолучитьКомментарийДляВставки(ПолеПостроителя.Комментарий, Смещение + Символы.Таб);
		Если ТекстПостроителя <> "" Тогда
			ТекстПостроителя = ТекстПостроителя + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПостроителя = ТекстПостроителя + ТекстКомментария;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПостроителя, ТекстВыражения, Смещение + Символы.Таб);
		ПсевдонимПоля = ПолеПостроителя.Имя;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ЗначениеЗаполнено(ПсевдонимПоля) 
		Тогда
			ТекстПостроителя = ТекстПостроителя + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(ПолеПостроителя.Имя);
		КонецЕсли;
	КонецЦикла;
	Если ТекстПостроителя <> "" Тогда
		ОбщийТекст = ОбщийТекст + Символы.ПС + Смещение + "{" + ПредложениеПостроителя + Символы.ПС + Смещение + Символы.Таб + ТекстПостроителя + "}"; 
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьОбновитьВыражениеПоляПостроителя(ПолеПостроителя, ТабличноеПоле, Знач ЗапросПакета, Знач ЧастьОбъединения = Неопределено)

	ТекстВыражения = ОбновитьВыражениеЗапроса(ПолеПостроителя, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения,,,,,, 0);
	Если ПолеПостроителя.ИспользоватьДочерние Тогда
		Если Лев(ТекстВыражения, 1) <> "(" Тогда
			ТекстВыражения = "(" + ТекстВыражения + ")";
		КонецЕсли; 
		ТекстВыражения = ТекстВыражения + ".*";
	КонецЕсли; 
	Возврат ТекстВыражения;

КонецФункции

Функция ПолучитьКомментарийДляВставки(Комментарий, Смещение = "")
	
	Результат = "";
	Если Не ЗначениеЗаполнено(Комментарий) Тогда
		Возврат Результат;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ПараметрыДиалектаSQL.СтрочныйКомментарий) Тогда
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Проигнорирован комментарий (не поддерживается диалектом SQL): " + Комментарий, , СтатусСообщения.Внимание);
		Возврат Результат;
	КонецЕсли; 
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(Комментарий);
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		Если Результат <> "" Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + ПараметрыДиалектаSQL.СтрочныйКомментарий + ТекстовыйДокумент.ПолучитьСтроку(Счетчик) + Символы.ПС;
	КонецЦикла;
	Результат = Результат + Смещение;
	Возврат Результат;
	
КонецФункции

Функция СобратьТекстЧастиОбъединения(ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, Смещение = "", РазвернутьАвтополя = Ложь)

	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Результат = "";
	ЕстьАгрегаты = Ложь;
	
	// SELECT
	Результат = Результат + ПолучитьКомментарийДляВставки(ЧастьОбъединения.Комментарий, Смещение);
	Если ЗначениеЗаполнено(Результат) Тогда
		Результат = Результат + Смещение;
	КонецЕсли; 
	Результат = Результат + ПолучитьСловоЯзыкаЗапросов("SELECT");
	Если ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0] Тогда
		Если Истина
			И ПараметрыДиалектаSQL.Это1С
			И ЗапросПакета.ОпцияРазрешенные 
		Тогда
			Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("ALLOWED");
		КонецЕсли; 
		Если Истина
			И ЗапросПакета.ОпцияПервые
			И Не (Ложь
				Или ДиалектSQL = "SQLite" 
				Или ДиалектSQL = "PostgreSQL" 
				Или ДиалектSQL = "MySQL")
		Тогда
			Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("TOP") + " " + XMLСтрока(ЗапросПакета.ПервыеКоличество);
		КонецЕсли; 
	КонецЕсли; 
	Если ЧастьОбъединения.ОпцияРазличные Тогда
		Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("DISTINCT");
	КонецЕсли; 
	ТекстПоляВыбора = "";
	ДобавленныеТаблицыВсеПоля = Новый Массив();
	ИндексПоля = 0;
	Для Каждого СтрокаПоляОбъединения Из ЗапросПакета.ПоляОбъединения Цикл
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(СтрокаПоляОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
		Если ЗапросПакета.ТипЗапроса = 3 Тогда
			ПсевдонимПоля = ЗапросПакета.ПринимающиеПоля[ИндексПоля].Поля;
		Иначе
			ПсевдонимПоля = СтрокаПоляОбъединения.Имя;
		КонецЕсли; 
		ТекстКомментария = "";
		Если ВыбранноеПоле = Неопределено Тогда
			ТекстВыражения = ПолучитьСловоЯзыкаЗапросов("NULL");
		ИначеЕсли ВыбранноеПоле.Автополе И Не РазвернутьАвтополя И мПараметрыДиалектаSQL.МногоТаблиц Тогда
			ПсевдонимПоля = "";
			ИмяТаблицы = ирОбщий.ПолучитьПервыйФрагментЛкс(ВыбранноеПоле.Определение);
			ТекстВыражения = ИмяТаблицы + ".*";
			КлючТаблицы = НРег(ИмяТаблицы);
			Если ДобавленныеТаблицыВсеПоля.Найти(КлючТаблицы) = Неопределено Тогда
				ДобавленныеТаблицыВсеПоля.Добавить(КлючТаблицы);
			Иначе
				Продолжить;
			КонецЕсли; 
		Иначе
			ТекстВыражения = ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, ЗапросПакета, ЧастьОбъединения,,,, ЕстьАгрегаты,, 0);
			Если Не ЗначениеЗаполнено(ТекстВыражения) Тогда
				ТекстВыражения = "NULL";
			КонецЕсли; 
			ТекстКомментария = ПолучитьКомментарийДляВставки(ВыбранноеПоле.Комментарий, Смещение + Символы.Таб);
		КонецЕсли; 
		Если ТекстПоляВыбора <> "" Тогда
			ТекстПоляВыбора = ТекстПоляВыбора + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПоляВыбора = ТекстПоляВыбора + ТекстКомментария;
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПоляВыбора, ТекстВыражения, Смещение + Символы.Таб);
		Если ПараметрыДиалектаSQL.МногоТаблиц И ЗначениеЗаполнено(ПсевдонимПоля) Тогда
			ТекстПоляВыбора = ТекстПоляВыбора + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПсевдонимПоля;
		КонецЕсли;
		ИндексПоля = ИндексПоля + 1;
	КонецЦикла;
	Если Не РазвернутьАвтополя И мПараметрыДиалектаSQL.МногоТаблиц Тогда
		Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы.НайтиСтроки(Новый Структура("ВсеПоля", Истина)) Цикл
			Если ДобавленныеТаблицыВсеПоля.Найти(СтрокаВыбраннойТаблицы.НИмя) = Неопределено Тогда
				Если ТекстПоляВыбора <> "" Тогда
					ТекстПоляВыбора = ТекстПоляВыбора + "," + Символы.ПС + Смещение + Символы.Таб;
				КонецЕсли; 
				ТекстВыражения = СтрокаВыбраннойТаблицы.Имя + ".*";
				ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПоляВыбора, ТекстВыражения, Смещение + Символы.Таб);
			КонецЕсли; 
		КонецЦикла;
		Если Не ЗначениеЗаполнено(ТекстПоляВыбора) Тогда
			ТекстПоляВыбора = "*";
		КонецЕсли; 
	КонецЕсли; 
	Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстПоляВыбора;
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("SELECT"),
		ЧастьОбъединения.ПоляВыбораПостроителя, ЭлементыФормы.ПоляВыбораПостроителя, ЗапросПакета, ЧастьОбъединения, Смещение);
		
	Если Не ПараметрыДиалектаSQL.INTOпослеORDER Тогда
		Если ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0] Тогда
			Если ирОбщий.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 1) Тогда
				Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INTO") + " ";
				Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
					Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
				КонецЕсли; 
				Результат = Результат + XMLСтрока(ЗапросПакета.ИмяОсновнойТаблицы);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
	ТекстИЗ = СобратьТекстИЗ(ЗапросПакета, ЧастьОбъединения, Смещение);
	Результат = Результат + ТекстИЗ;
	
	// WHERE
	//ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Условие.Отбор, 1, 1, ЕстьАгрегаты, ЧастьОбъединения.Компоновщик.Настройки);
	ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Компоновщик.Настройки.Отбор, 1, 1, ЕстьАгрегаты, ЧастьОбъединения.Компоновщик.Настройки);
	ДобавитьТекстОтбора(Результат, Смещение, ТекстУсловия, ЧастьОбъединения);
	
	ДобавитьТекстПредложенияПостроителя(Результат, ПолучитьСловоЯзыкаЗапросов("WHERE"),
		ЧастьОбъединения.ПоляОтбораПостроителя, ЭлементыФормы.ПоляОтбораПостроителя, ЗапросПакета, ЧастьОбъединения, Смещение);
	
	// GROUP BY
	ТекстГруппировки = "";
	Если ЧастьОбъединения.Автогруппировки И ЕстьАгрегаты Тогда
		КопияГруппировок = ЧастьОбъединения.Группировки.Скопировать();
		ЧастьОбъединения.Группировки.Очистить();
		Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
			Если ВыбранноеПоле.ЕстьАгрегаты Тогда
				Продолжить;
			КонецЕсли; 
			// Временно до добавления признака ЕстьПоля в ВыбранныеПоля
			//Группировка = ЧастьОбъединения.Группировки.Найти(ВыбранноеПоле.Определение, "Определение");
			//Если Группировка = Неопределено Тогда
				Группировка = ЧастьОбъединения.Группировки.Добавить();
				Группировка.Определение = ВыбранноеПоле.Определение;
				Группировка.Токен = ВыбранноеПоле.Токен; // !Опасно
				СтрокаКопииГруппировки = КопияГруппировок.Найти(ВыбранноеПоле.Определение, "Определение"); // Чувствительность к регистру!
				Если СтрокаКопииГруппировки <> Неопределено Тогда
					Группировка.Комментарий = СтрокаКопииГруппировки.Комментарий;
				КонецЕсли; 
			//КонецЕсли;
		КонецЦикла;
	КонецЕсли; 
	Для Каждого Группировка Из ЧастьОбъединения.Группировки Цикл
		Если ТекстГруппировки <> "" Тогда
			ТекстГруппировки = ТекстГруппировки + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстГруппировки = ТекстГруппировки + ПолучитьКомментарийДляВставки(Группировка.Комментарий, Смещение + Символы.Таб);
		ТекстВыражения = ОбновитьВыражениеЗапроса(Группировка, ЭлементыФормы.Группировки, ЗапросПакета, ЧастьОбъединения,,,,,, 0);
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстГруппировки, ТекстВыражения, Смещение + Символы.Таб);
	КонецЦикла;
	Если ТекстГруппировки <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("GROUP") 
			+ " " + ПолучитьСловоЯзыкаЗапросов("BY") + Символы.ПС + Смещение + Символы.Таб + ТекстГруппировки;
	КонецЕсли; 
	
	// HAVING
	//ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Условие.Отбор, 1, 2,, ЧастьОбъединения.Компоновщик.Настройки);
	ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Компоновщик.Настройки.Отбор, 1, 2,, ЧастьОбъединения.Компоновщик.Настройки);
	Если ТекстУсловия <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("HAVING");
		Если ИерархическийСтильЛогическихВыражений Тогда
			Результат = Результат + " ";
		Иначе
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(Результат, ТекстУсловия, Смещение);
	КонецЕсли; 
	
	Если ЧастьОбъединения.ОпцияДляИзменения Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("FOR") + " " + ПолучитьСловоЯзыкаЗапросов("UPDATE");
		ТекстТаблицДляИзменения = "";
		Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы.НайтиСтроки(Новый Структура("ДляИзменения", Истина)) Цикл
			Если ТекстТаблицДляИзменения <> "" Тогда
				ТекстТаблицДляИзменения = ТекстТаблицДляИзменения + ",";
			КонецЕсли; 
			ТекстТаблицДляИзменения = ТекстТаблицДляИзменения + Символы.ПС + Смещение + Символы.Таб + СтрокаВыбраннойТаблицы.ПолноеИмя;
		КонецЦикла;
		Результат = Результат + ТекстТаблицДляИзменения;
	КонецЕсли;
	
	//Если ЗначениеЗаполнено(ЧастьОбъединения.ТекстРасширения) Тогда
	//	Результат = Результат + Символы.ПС + "{" + ЧастьОбъединения.ТекстРасширения + "}";
	//КонецЕсли; 
	
	Возврат Результат;

КонецФункции

Процедура ДобавитьТекстОтбора(Результат, Знач Смещение, Знач ТекстУсловия, Знач ЧастьОбъединения)
	
	Если ТекстУсловия <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("WHERE");
		Если ИерархическийСтильЛогическихВыражений Тогда
			Результат = Результат + " ";
		Иначе
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(Результат, ТекстУсловия, Смещение);
		КомментарийДляВставки = ПолучитьКомментарийДляВставки(ЧастьОбъединения.КомментарийОтбора, Смещение + Символы.Таб);
		Если ЗначениеЗаполнено(КомментарийДляВставки) Тогда
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб + Символы.Таб + КомментарийДляВставки;
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

// Текст FROM
Функция СобратьТекстИЗ(ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, Смещение = "")

	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Результат = "";
	ТекстТаблицы = "";
	ГруппыСвязей = ЧастьОбъединения.СвязиТаблиц.Строки;
	Для Каждого ГруппаСвязей Из ГруппыСвязей Цикл
		СоединяемаяТаблица = ГруппаСвязей.Таблица;
		Если ТекстТаблицы <> "" Тогда
			ТекстТаблицы = ТекстТаблицы + ",";
		КонецЕсли; 
		ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + ПолучитьОпределениеТаблицы(ГруппаСвязей.Таблица, ЗапросПакета, ЧастьОбъединения, Смещение + Символы.Таб);
		НомерОткрытойГруппы = 0;
		СобратьВеткуСвязейТаблиц(НомерОткрытойГруппы, ГруппаСвязей, ЗапросПакета, Смещение, ТекстТаблицы, ЧастьОбъединения);
		Если НомерОткрытойГруппы > 0 Тогда
			ТекстТаблицы = ТекстТаблицы + "}";
		КонецЕсли; 
	КонецЦикла;
	Если ТекстТаблицы <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("FROM") + ТекстТаблицы;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура СобратьВеткуСвязейТаблиц(НомерОткрытойГруппы, Знач ВеткаСвязей, ЗапросПакета, Знач Смещение, ТекстТаблицы, ЧастьОбъединения)
	
	ТекстТаблицыТД = Новый ТекстовыйДокумент;
	ТекстТаблицыТД.УстановитьТекст(ТекстТаблицы);
	Для Каждого СтрокаСвязи Из ВеткаСвязей.Строки Цикл
		Если Не ПустаяСтрока(ТекстТаблицыТД.ПолучитьСтроку(ТекстТаблицыТД.КоличествоСтрок())) Тогда
			ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(СтрокаСвязи.Таблица), "НИмя");
		Если Истина
			И СтрокаВыбраннойТаблицы.НомерГруппы > 0 
			И НомерОткрытойГруппы <> СтрокаВыбраннойТаблицы.НомерГруппы
		Тогда
			Если НомерОткрытойГруппы > 0 Тогда
				ТекстТаблицы = ТекстТаблицы + "}";
			КонецЕсли; 
			ТекстТаблицы = ТекстТаблицы + "{";
	    	НомерОткрытойГруппы = СтрокаВыбраннойТаблицы.НомерГруппы;
		КонецЕсли; 
		
		ТекстТаблицы = ТекстТаблицы + ПолучитьСловоЯзыкаЗапросов(СтрокаСвязи.ТипСвязи);
		ТекстТаблицы = ТекстТаблицы + " " + ПолучитьСловоЯзыкаЗапросов("JOIN") 
		+ " " + ПолучитьОпределениеТаблицы(СтрокаСвязи.Таблица, ЗапросПакета, ЧастьОбъединения, Смещение + Символы.Таб);
		ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(СтрокаСвязи.Условие.Отбор, 2,,, ЧастьОбъединения.Компоновщик.Настройки);
		Если ПустаяСтрока(ТекстУсловия) Тогда
			ТекстУсловия = ПолучитьСловоЯзыкаЗапросов("TRUE");
		КонецЕсли; 
		СобратьВеткуСвязейТаблиц(НомерОткрытойГруппы, СтрокаСвязи, ЗапросПакета, Смещение + Символы.Таб, ТекстТаблицы, ЧастьОбъединения);
		ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + ПолучитьСловоЯзыкаЗапросов("ON") + " ";
		
		ирОбщий.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстТаблицы, ТекстУсловия, Смещение);
		Если ЗначениеЗаполнено(СтрокаСвязи.Комментарий) Тогда
			ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + Символы.Таб + ПолучитьКомментарийДляВставки(СтрокаСвязи.Комментарий, Смещение + Символы.Таб);
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Функция ПоменятьМестамиТаблицыСвязи(СвязьТаблиц)

	// Меняем местами левую и правую стороны
	лЛеваяТаблица = СвязьТаблиц.ЛеваяТаблица;
	СвязьТаблиц.ЛеваяТаблица = СвязьТаблиц.ПраваяТаблица;
	СвязьТаблиц.ПраваяТаблица = лЛеваяТаблица;
	лВсеСтрокиЛевой = СвязьТаблиц.ВсеСтрокиЛевой;
	СвязьТаблиц.ВсеСтрокиЛевой = СвязьТаблиц.ВсеСтрокиПравой;
	СвязьТаблиц.ВсеСтрокиПравой = лВсеСтрокиЛевой;
	Возврат Неопределено;

КонецФункции

Функция ЗакончитьРедактированиеСвязанныхПолей()

	СохранитьЗапросПакета();
	Возврат Неопределено;

КонецФункции

Процедура ВыбранныеТаблицыПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Истина
			//И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.ДоступныеТаблицы") // В портативной версии нельзя
			И ТипЗнч(ЗначениеПеретаскивания[0]) = ТипЗнч(ЭтотОбъект.ДоступныеТаблицы[0]) 
		Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Истина
			//И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.ДоступныеТаблицы") // В портативной версии нельзя
			И ТипЗнч(ЗначениеПеретаскивания[0]) = ТипЗнч(ЭтотОбъект.ДоступныеТаблицы[0]) 
		Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступнуюТаблицуВВыбранные(СтрокаПеретаскивания);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Функция ДобавитьДоступнуюТаблицуВВыбранные(СтрокаДоступнойТаблицы, ПроверятьУникальность = Ложь)

	Если Истина
		И Не ПараметрыДиалектаSQL.МногоТаблиц
		И ВыбранныеТаблицы.Количество() > 0
	Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	Если ПроверятьУникальность Тогда
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(СтрокаДоступнойТаблицы.ПолноеИмя, "ПолноеИмя");
	КонецЕсли; 
	Если ВыбраннаяТаблица = Неопределено Тогда
		ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
		ВыбраннаяТаблица.Обязательная = Истина;
		//ОпределениеТаблицы = СтрокаДоступнойТаблицы.Имя;
		//Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда
		//	ОпределениеТаблицы = СтрокаДоступнойТаблицы.Схема + "." + ОпределениеТаблицы;
		//КонецЕсли; 
		//ВыбраннаяТаблица.Определение = ОпределениеТаблицы;
		ВыбраннаяТаблица.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, СтрокаДоступнойТаблицы.Имя + "Т");
		СкорректироватьПсевдонимТаблицы(ВыбраннаяТаблица);
		ВыбраннаяТаблица.ПолноеИмя = СтрокаДоступнойТаблицы.ПолноеИмя;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
		Если СтрокаДоступнойТаблицы.Тип = "Параметр" Тогда
			Если ЭтаФорма.ТипЗапроса = 1 И ЧастьОбъединения.ВыбранныеТаблицы.Количество() = 1 Тогда
				ЭтаФорма.ИмяОсновнойТаблицы = СтрокаДоступнойТаблицы.Имя;
				ОбновитьНаименованиеЗапроса();
			Иначе
				СтрокаДоступнойТаблицыВТ = ДоступныеТаблицы.Найти(НРег(СтрокаДоступнойТаблицы.Имя), "НПолноеИмя");
				Если СтрокаДоступнойТаблицыВТ = Неопределено Тогда
					ЗапросПакетаДоп = ДобавитьЗапросПакета(, ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока));
					ЗапросПакетаДоп.ИмяОсновнойТаблицы = СтрокаДоступнойТаблицы.Имя;
					ЗапросПакетаДоп.ТипЗапроса = 1;
					ОбновитьНаименованиеЗапроса(ЗапросПакетаДоп);
					ЧастьОбъединенияДоп = ДобавитьЧастьОбъединения(ЗапросПакетаДоп);
					ВыбраннаяТаблицаДоп = ДобавитьВыбраннуюТаблицу(ЧастьОбъединенияДоп);
					ВыбраннаяТаблицаДоп.Имя = СтрокаДоступнойТаблицы.Имя;
					ВыбраннаяТаблицаДоп.ПолноеИмя = СтрокаДоступнойТаблицы.ПолноеИмя;
					ВыбраннаяТаблицаДоп.Обязательная = Истина;
					ВыбраннаяТаблицаДоп.ВсеПоля = Истина;
					ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблицаДоп);
					ОбновитьНаименованиеЧасти(ЧастьОбъединенияДоп);
					НайтиДобавитьВыбраннуюТаблицуВСвязи(ВыбраннаяТаблицаДоп, ЧастьОбъединенияДоп);
					ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединенияДоп);
					ДобавитьВсеПоляТаблицыВВыбранныеПоля(ВыбраннаяТаблицаДоп.Имя, ЗапросПакетаДоп, ЧастьОбъединенияДоп);
					ОбновитьДоступныеВременныеТаблицы();
					ОбновитьРежимПакетногоЗапроса();
				КонецЕсли; 
				ВыбраннаяТаблица.ПолноеИмя = СтрокаДоступнойТаблицы.Имя;
			КонецЕсли; 
		КонецЕсли; 
		ОбновитьНаименованиеЧасти();
		НайтиДобавитьВыбраннуюТаблицуВСвязи(ВыбраннаяТаблица);
		ОбновитьКомпоновщикЧастиОбъединения();
	КонецЕсли; 
	ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока = ВыбраннаяТаблица;
	Возврат ВыбраннаяТаблица;

КонецФункции

Процедура СкорректироватьПсевдонимТаблицы(Знач ВыбраннаяТаблица)
	
	Если Истина
		И Лев(ВыбраннаяТаблица.Имя, 1) = "_" 
		И мДиалектSQL = "MSJet"
	Тогда
		// Для EXCEL псевдонимы таблиц не могут начиваться с "_"
		ВыбраннаяТаблица.Имя = "t" + ВыбраннаяТаблица.Имя;
	КонецЕсли;

КонецПроцедуры

Процедура ВыбранныеПоляПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Функция РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания)
	
	Результат = Ложь
		Или (Истина
			И ТипЗнч(ЗначениеПеретаскивания) = Тип("ДоступноеПолеКомпоновкиДанных")
			И Не ЭтоНедоступноеДоступноеПоле(ЗначениеПеретаскивания)
			И Найти("" + ЗначениеПеретаскивания.Поле, "._Индексы") = 0)
		Или ТипЗнч(ЗначениеПеретаскивания) = Тип("ДоступноеПолеОтбораКомпоновкиДанных")
		Или (Истина
			И ТипЗнч(ЗначениеПеретаскивания) = Тип("СтрокаТаблицыЗначений")
			//И ПараметрыПеретаскивания.Значение.Владелец() = ДоступныеПоляВыбора // Так не работает
			И ЗначениеПеретаскивания.Владелец().Колонки.Найти("Имя") <> Неопределено
			И ЗначениеПеретаскивания.Владелец().Колонки.Найти("Поле") <> Неопределено);
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)

	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли;
	ИначеЕсли ТипЗнч(ЗначениеПеретаскивания) = Тип("СтрокаТаблицыЗначений") Тогда
		СтандартнаяОбработка = Ложь;
		Элемент.ДобавитьСтроку();
		НоваяСтрока = Элемент.ТекущаяСтрока;
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначениеПеретаскивания); 
		ЗагрузитьВыбранноеПоле();
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(СтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета = Неопределено,
	ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если Истина
		И (Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
		И (Ложь
			Или ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля)
			Или Найти("" + СтрокаДоступногоПоля.Поле, "._Индексы") > 0)
	Тогда
		Возврат;
	КонецЕсли; 
	Если Истина
		И (Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
		И СтрокаДоступногоПоля.Папка
	Тогда
		// Все дочерние поля
		Если Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
			Или Не ирОбщий.СтрокиРавныЛкс("ПараметрыДанных", "" + СтрокаДоступногоПоля.Поле) 
		Тогда
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(СтрокаДоступногоПоля.Поле), "НИмя");
			Иначе
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[0];
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого лСтрокаДоступногоПоля Из СтрокаДоступногоПоля.Элементы Цикл
			ДобавитьДоступноеПолеВТабличноеПоле(лСтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления);
		КонецЦикла;
	Иначе
		// Одно поле
		ДобавитьДоступноеПолеВТабличноеПоле(СтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления);
	КонецЕсли; 

КонецПроцедуры

Функция ДобавитьДоступноеПолеВТабличноеПоле(СтрокаДоступногоПоля, ТабличноеПолеПолей, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	СдвигИндексаПослеДобавления = 0, ИмяСвойстваВыраженияВыбранногоПоля = "Имя")

	Если Ложь
		Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
		Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных")
	Тогда
		Если Ложь
			Или ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля)
			Или Найти("" + СтрокаДоступногоПоля.Поле, "._Индексы") > 0
		Тогда
			Возврат Неопределено;
		КонецЕсли; 
		ВыражениеПоля = ПолучитьПолноеИмяДоступногоПоля(СтрокаДоступногоПоля);
		ПроверятьУникальность = Ложь;
	Иначе
		ВыражениеПоля = СтрокаДоступногоПоля[ИмяСвойстваВыраженияВыбранногоПоля];
		СтрокаПоляПостроителя = ТабличноеПолеПолей.Значение.Найти(ВыражениеПоля, "Определение");
		Если СтрокаПоляПостроителя <> Неопределено Тогда
			ТабличноеПолеПолей.ТекущаяСтрока = СтрокаПоляПостроителя;
			Возврат СтрокаПоляПостроителя;
		КонецЕсли;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	СтрокаПоляПостроителя = ТабличноеПолеПолей.Значение.Добавить();
	ТабличноеПолеПолей.Значение.Сдвинуть(СтрокаПоляПостроителя, СдвигИндексаПослеДобавления);
	СтрокаПоляПостроителя.Определение = ВыражениеПоля;
	Если СтрокаПоляПостроителя.Владелец().Колонки.Найти("Имя") <> Неопределено Тогда
		ИмяПоля = ПолучитьАвтоПсевдонимПоля(СтрокаПоляПостроителя, ЧастьОбъединения);
		СтрокаПоляПостроителя.Имя = ИмяПоля;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПоляПостроителя);
	КонецЕсли; 
	ОбновитьСтрокуПоляПостроителя(СтрокаПоляПостроителя, Истина,, СтрокаДоступногоПоля.ТипЗначения);
	
	//ПриИзмененииВыраженияВыбранногоПоля(СтрокаВыбранногоПоля, ЗапросПакета, ЧастьОбъединения, Ложь); // Надо делать после активизации строки
	Возврат СтрокаПоляПостроителя;

КонецФункции

Процедура ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(СтрокаДоступногоПоля, Автополе = Ложь, ЗапросПакета = Неопределено,
	ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь, ОбновитьПоляОбъединения = Истина)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если Истина
		И (Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
		И (Ложь
			Или ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля)
			Или Найти("" + СтрокаДоступногоПоля.Поле, "._Индексы") > 0)
	Тогда
		Возврат;
	КонецЕсли; 
	Если Ложь
		Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
		Или (Истина
			И (Ложь
				Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных") 
				Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
			И СтрокаДоступногоПоля.Папка)
	Тогда
		//Если ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + СтрокаДоступногоПоля.Поле) Тогда
		//	Возврат;
		//КонецЕсли; 
		// Все дочерние поля
		Если Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
			Или Не ирОбщий.СтрокиРавныЛкс("ПараметрыДанных", "" + СтрокаДоступногоПоля.Поле) 
		Тогда
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(СтрокаДоступногоПоля.Поле), "НИмя");
			Иначе
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[0];
			КонецЕсли; 
			Если Не ВыбраннаяТаблица.ВсеПоля Тогда
				Ответ = Вопрос("Хотите включить выбор всех полей из таблицы?", РежимДиалогаВопрос.ДаНет);
				Если Ответ = КодВозвратаДиалога.Да Тогда
					ВыбраннаяТаблица.ВсеПоля = Истина;
					Автополе = Истина;
					КонтролироватьУникальность = Истина;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого лСтрокаДоступногоПоля Из СтрокаДоступногоПоля.Элементы Цикл
			ДобавитьДоступноеПолеВВыбранныеПоля(лСтрокаДоступногоПоля, Автополе, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
				КонтролироватьУникальность, Ложь);
		КонецЦикла;
		Если ОбновитьПоляОбъединения Тогда
			ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
		КонецЕсли;
	Иначе
		//Если ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + СтрокаДоступногоПоля.Родитель.Поле) Тогда
		//	Возврат;
		//КонецЕсли; 
		// Одно поле
		ДобавитьДоступноеПолеВВыбранныеПоля(СтрокаДоступногоПоля, Автополе, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
			КонтролироватьУникальность, ОбновитьПоляОбъединения);
	КонецЕсли; 

КонецПроцедуры

Функция ДобавитьДоступноеПолеВВыбранныеПоля(СтрокаДоступногоПоля, Автополе = Ложь, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь, ОбновитьПоляОбъединения = Истина)

	Если ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ОпределениеПоля = ПолучитьПолноеИмяДоступногоПоля(СтрокаДоступногоПоля);
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	//ТабличноеПоле = ЭлементыФормы.ВыбранныеПоля;
	Если КонтролироватьУникальность Тогда
	//Если Автополе Тогда
		СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Найти(ОпределениеПоля, "Определение");
	КонецЕсли; 
	Если СтрокаВыбранногоПоля = Неопределено Тогда
		СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Добавить();
		Если ЗначениеЗаполнено(СдвигИндексаПослеДобавления) Тогда
			ЧастьОбъединения.ВыбранныеПоля.Сдвинуть(СтрокаВыбранногоПоля, СдвигИндексаПослеДобавления);
		КонецЕсли; 
		СтрокаВыбранногоПоля.Определение = ОпределениеПоля;
		ИмяПоля = ПолучитьАвтоПсевдонимПоля(СтрокаВыбранногоПоля, ЧастьОбъединения);
		СтрокаВыбранногоПоля.Имя = ИмяПоля;
		СтрокаВыбранногоПоля.ИД = Новый УникальныйИдентификатор();
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбранногоПоля);
		//СтрокаВыбранногоПоля.ТипЗначения = СтрокаДоступногоПоля.ТипЗначения;
	КонецЕсли; 
	СтрокаВыбранногоПоля.Автополе = Автополе;
	Если ОбновитьПоляОбъединения Тогда
		ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока = СтрокаВыбранногоПоля;
	КонецЕсли; 
	
	//ПриИзмененииВыраженияВыбранногоПоля(СтрокаВыбранногоПоля, ЗапросПакета, ЧастьОбъединения, ОбновитьПоляОбъединения); // Надо делать после активизации строки
	СтрокаВыбранногоПоля.ТипЗначения = СтрокаДоступногоПоля.Тип;
	Если ОбновитьПоляОбъединения Тогда
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
	КонецЕсли; 
	
	Возврат СтрокаВыбранногоПоля;

КонецФункции

Функция ПолучитьАвтоПсевдонимПоля(СтрокаПоля, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ПозицияТочки = Найти(СтрокаПоля.Определение, ".");
	ДлинаСтроки = 900;
	Если Прав(СтрокаПоля.Определение, 1) = ")" Тогда
		ДлинаСтроки = СтрДлина(СтрокаПоля.Определение) - ПозицияТочки - 1;
	КонецЕсли; 
	ИмяПоля = Сред(СтрокаПоля.Определение, ПозицияТочки + 1, ДлинаСтроки);
	ИмяПоля = СтрЗаменить(ИмяПоля, ".", "");
	ИмяПоля = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(СтрокаПоля.Владелец(), ИмяПоля);
	Если Ложь
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "ЛОЖЬ")
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "ИСТИНА")
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "НЕОПРЕДЕЛЕНО")
		Или ирОбщий.СтрокиРавныЛкс(ИмяПоля, "NULL")
	Тогда
		ИмяПоля = "_" + ИмяПоля;
	КонецЕсли; 
	Возврат ИмяПоля;

КонецФункции

Процедура ПанельЧастиПриСменеСтраницы(Элемент = Неопределено, ТекущаяСтраница = Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	Если Элемент = Неопределено Тогда
		Элемент = ЭлементыФормы.ПанельЧасти;
	КонецЕсли; 
	Если ТекущаяСтраница = Неопределено Тогда
		ТекущаяСтраница = Элемент.ТекущаяСтраница.Имя;
	КонецЕсли; 
	Если Ложь
		Или ТипЗапроса <> 2 // DROP
		Или ТипЗапроса <> 6 // TRUNCATE
	Тогда
		Если Ложь
			Или мСтараяСтраницаПанелиЧасти = ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеТаблицы 
		Тогда
			ЗагрузитьДоступныеНастройкиКомпоновки();
			СвязиТаблицПриАктивизацииСтроки();
		КонецЕсли; 
	КонецЕсли; 
	ПанельЧастиОбновитьТекущуюСтраницу();
	ЭтаФорма.мСтараяСтраницаПанелиЧасти = Элемент.Страницы[ТекущаяСтраница];
	
КонецПроцедуры

Функция ПанельЧастиОбновитьТекущуюСтраницу()

	лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.ТекущаяСтраница;
	Если лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Группировки Тогда
		//ДоступныеВыбранныеПоля = ВыбранныеПоля.Скопировать();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Текст Тогда
		ПересобратьВременныйТекстЧасти();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Построитель Тогда
		ЭтаФорма.ДоступныеВыбранныеПоляЧасти = ВыбранныеПоля.Скопировать();
		ДоступныеВыбранныеПоляЧасти.Сортировать("Имя");
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц Тогда
		ЭлементыФормы.СвязиТаблиц.ОбновитьСтроки();
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока = Неопределено Тогда
			Если СвязиТаблиц.Строки.Количество() > 0 Тогда
				ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока = СвязиТаблиц.Строки[0];
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Процедура ПересобратьВременныйТекстЧасти()

	Если ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Состояние("Сборка текста части объединения...");
	ТекстЧасти = СобратьТекстЧастиОбъединения(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока, ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока);
	ирОбщий.УстановитьТекстПоляСохраняяПозициюЛкс(ЭлементыФормы.ПолеТекстаЧасти, ТекстЧасти);
	Состояние();

КонецПроцедуры

Процедура ЗагрузитьДоступныеНастройкиКомпоновки()
	
	ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	Если ЧастьОбъединения = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения);
	КомпоновщикУсловияСвязи.Инициализировать(ЧастьОбъединения.ИсточникНастроек);
	Если ЧастиОбъединения.Количество() = 1 Тогда
		КомпоновщикЗапроса.Инициализировать(ЧастьОбъединения.ИсточникНастроек);
	Иначе
		КомпоновщикЗапроса.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(Новый СхемаКомпоновкиДанных));
	КонецЕсли; 
	
КонецПроцедуры

Функция ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения = Неопределено, Принудительно = Истина)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ЧастьОбъединения.КомпоновщикАктуален И Не Принудительно Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Если ЭлементыФормы.ДоступныеПоляВыбора.ТекущаяСтрока <> Неопределено Тогда
		ТекущееДоступноеПолеВыбора = ЭлементыФормы.ДоступныеПоляВыбора.ТекущаяСтрока.Поле;
	КонецЕсли; 
	Если ЭлементыФормы.ДоступныеПоляУсловия.ТекущаяСтрока <> Неопределено Тогда
		ТекущееДоступноеПолеУсловия = ЭлементыФормы.ДоступныеПоляУсловия.ТекущаяСтрока.Поле;
	КонецЕсли; 
	Если ПоказыватьИндексы Тогда
		СтруктуруХраненияБД = ирКэш.ПолучитьСтруктуруХраненияБДЛкс(, Ложь);
	КонецЕсли; 
	ДоступныеПоляВыбора = Новый ДеревоЗначений;
	ДоступныеПоляВыбора.Колонки.Добавить("Имя");
	ДоступныеПоляВыбора.Колонки.Добавить("ТипЗначения");
	Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		СтрокаТаблицыВДереве = ДоступныеПоляВыбора.Строки.Добавить();
		ИмяТаблицы = ПолучитьИмяВыбраннойТаблицы(ВыбраннаяТаблица);
		СтрокаТаблицыВДереве.Имя = ИмяТаблицы;
		ДоступныеПоляТаблицы = ПолучитьДоступныеПоляТаблицы(ИмяТаблицы, ЧастьОбъединения);
		Для Каждого ДоступноеПолеТаблицы Из ДоступныеПоляТаблицы Цикл
			СтрокаПоляВДереве = СтрокаТаблицыВДереве.Строки.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаПоляВДереве, ДоступноеПолеТаблицы); 
		КонецЦикла;
		Если ПоказыватьИндексы Тогда
			КлючПоиска = Новый Структура("ИмяТаблицы", ВыбраннаяТаблица.ПолноеИмя);
			НайденныеСтроки = СтруктуруХраненияБД.НайтиСтроки(КлючПоиска);
			Если НайденныеСтроки.Количество() > 0 Тогда
				СтрокаТаблицыХранения = НайденныеСтроки[0];
				Для Каждого ИндексТаблицыБД Из СтрокаТаблицыХранения.Индексы Цикл
					СтрокаИндексаВДереве = СтрокаТаблицыВДереве.Строки.Добавить();
					ПредставлениеИндекса = ирОбщий.ПолучитьПредставлениеИндексаХраненияЛкс(ИндексТаблицыБД,, СтрокаТаблицыХранения);
					СтрокаИндексаВДереве.Имя = "_Индексы." + ПредставлениеИндекса + "";
					Для Каждого ПолеИндекса Из ИндексТаблицыБД.Поля Цикл
						СтрокаПоляВДереве = СтрокаИндексаВДереве.Строки.Добавить();
						СтрокаПоляВДереве.Имя = ПолеИндекса.ИмяПоля;
					КонецЦикла;
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Если Параметры.Количество() > 0 Тогда
		СтрокаГруппыПараметраВДереве = ДоступныеПоляВыбора.Строки.Добавить();
		СтрокаГруппыПараметраВДереве.Имя = "<Параметры>";
		Для Каждого CтрокаПараметра Из Параметры Цикл
			СтрокаПараметраВДереве = СтрокаГруппыПараметраВДереве.Строки.Добавить();
			СтрокаПараметраВДереве.Имя = CтрокаПараметра.Имя;
			СтрокаПараметраВДереве.ТипЗначения = CтрокаПараметра.ТипЗначения;
		КонецЦикла;
	КонецЕсли; 
	
	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = ирОбщий.ДобавитьЛокальныйИсточникДанныхЛкс(СхемаКомпоновки);
	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхОбъектСхемыКомпоновкиДанных"));
	НаборДанных.ИсточникДанных = ИсточникДанных.Имя;
	Для Каждого СтрокаДоступнойТаблицы Из ДоступныеПоляВыбора.Строки Цикл
		Если СтрокаДоступнойТаблицы.Имя = "<Параметры>" Тогда
			Продолжить;
		КонецЕсли; 
		ПапкаПолей = НаборДанных.Поля.Добавить(Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных"));
		ПапкаПолей.ПутьКДанным = СтрокаДоступнойТаблицы.Имя;
		ПапкаПолей.Заголовок = ПапкаПолей.ПутьКДанным;
		Если ПоказыватьИндексы Тогда
			ПапкаИндексов = НаборДанных.Поля.Добавить(Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных"));
			ПапкаИндексов.ПутьКДанным = ПапкаПолей.ПутьКДанным + "._Индексы";
			ПапкаИндексов.Заголовок = ПапкаПолей.Заголовок + "._Индексы";
		КонецЕсли; 
		Для Каждого СтрокаДоступногоПоля Из СтрокаДоступнойТаблицы.Строки Цикл
			ПолеНабора = НаборДанных.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
			ПолеНабора.Поле = СтрокаДоступногоПоля.Имя;
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ПолеНабора.ПутьКДанным = СтрокаДоступнойТаблицы.Имя + "." + ПолеНабора.Поле;
			Иначе
				ПолеНабора.ПутьКДанным = ПолеНабора.Поле;
			КонецЕсли; 
			ПолеНабора.Заголовок = ПолеНабора.ПутьКДанным;
			Если СтрокаДоступногоПоля.ТипЗначения <> Неопределено Тогда
				ПолеНабора.ТипЗначения = СтрокаДоступногоПоля.ТипЗначения;
			КонецЕсли; 
		КонецЦикла;
	КонецЦикла;
	Для Каждого Параметр Из Параметры Цикл
		ПараметрСхемы = СхемаКомпоновки.Параметры.Добавить();
		ПараметрСхемы.Имя = Параметр.Имя;
		ПараметрСхемы.Заголовок = Параметр.Имя;
		ПараметрСхемы.ТипЗначения = Параметр.ТипЗначения;
	КонецЦикла;
	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки);
	ЧастьОбъединения.ИсточникНастроек = ИсточникНастроек;
	ЧастьОбъединения.Компоновщик.Инициализировать(ИсточникНастроек);
	ЧастьОбъединения.КомпоновщикАктуален = Истина;
	
	// Восстановим текущие доступные поля
	Если ТекущееДоступноеПолеВыбора <> Неопределено Тогда
		ДоступноеПолеВыбора = КомпоновщикЧасти.Настройки.ДоступныеПоляВыбора.НайтиПоле(ТекущееДоступноеПолеВыбора);
		Если ДоступноеПолеВыбора <> Неопределено Тогда
			ЭлементыФормы.ДоступныеПоляВыбора.ТекущаяСтрока = ДоступноеПолеВыбора;
		КонецЕсли;
	КонецЕсли; 
	Если ТекущееДоступноеПолеУсловия <> Неопределено Тогда
		ДоступноеПолеУсловия = КомпоновщикЧасти.Настройки.ДоступныеПоляОтбора.НайтиПоле(ТекущееДоступноеПолеУсловия);
		Если ДоступноеПолеУсловия <> Неопределено Тогда
			ЭлементыФормы.ДоступныеПоляУсловия.ТекущаяСтрока = ДоступноеПолеУсловия;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ИсточникНастроек;

КонецФункции

Процедура ПриОткрытии()
	
	ЭтаФорма.мСтараяСтраницаПанелиЧасти = ЭлементыФормы.ПанельЧасти.ТекущаяСтраница;
	ЭтаФорма.мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.ТекущаяСтраница;
	//ЭтаФорма.ПоказыватьИндексы = ирОбщий.ВосстановитьЗначениеЛкс("КонструкторЗапроса.ПоказыватьИндексы"); // Много времени уходит на получение структуры БД
	ЗначениеНастройки = ирОбщий.ВосстановитьЗначениеЛкс("КонструкторЗапроса.ИерархическийСтильЛогическихВыражений");
	Если ЗначениеНастройки <> Неопределено Тогда
		ЭтаФорма.ИерархическийСтильЛогическихВыражений = ЗначениеНастройки;
	Иначе
		ЭтаФорма.ИерархическийСтильЛогическихВыражений = Истина;
	КонецЕсли; 
	
	// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
	ПолеТекстовогоДокументаСКонтекстнойПодсказкой = Новый Структура;
	
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если Сервер И Не Сервер Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеВыбранногоПоля, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);

	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если Сервер И Не Сервер Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеЭлементаУсловияСвязи, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);

	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если Сервер И Не Сервер Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеЭлементаУсловия, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);
		
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если Сервер И Не Сервер Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеПараметраТаблицы, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);
		
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой");
	#Если Сервер И Не Сервер Тогда
		лПолеТекстовогоДокументаСКонтекстнойПодсказкой = Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать();
	#КонецЕсли
	лПолеТекстовогоДокументаСКонтекстнойПодсказкой.Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ПолеТекстаЗапроса, , 1,,,, Конфигурация);
		
	// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
	
	Если Не ЗначениеЗаполнено(мДиалектSQL) Тогда
		мПлатформа.ИнициализацияОписанияМетодовИСвойств();
		ИнициализироватьНеинтерактивно(1);
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ДиалектSQL) Тогда
		УстановитьДиалектSQL();
	КонецЕсли; 
	ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(ЭтаФорма.Заголовок,, мДиалектSQL);
	ЭлементыФормы.Параметры.ТолькоПросмотр = ТабличноеПолеКорневогоПакета <> ЭлементыФормы.ЗапросыПакета;
	УстановитьДанные();
	Если Истина
		И Не ЭлементыФормы.Параметры.ТолькоПросмотр 
		И ТипЗнч(КонтекстВыполнения) = Тип("Запрос") 
	Тогда
		//Параметры.Очистить();
		Для Каждого КлючИЗначение Из КонтекстВыполнения.Параметры Цикл
			СтрокаПараметра = Параметры.Найти(НРег(КлючИЗначение.Ключ), "НИмя");
			Если СтрокаПараметра = Неопределено Тогда
				СтрокаПараметра = Параметры.Добавить();
				СтрокаПараметра.Имя = КлючИЗначение.Ключ;
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
			КонецЕсли; 
			СтрокаПараметра.Значение = КлючИЗначение.Значение;
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(КлючИЗначение.Значение));
			СтрокаПараметра.ТипЗначения = Новый ОписаниеТипов(МассивТипов);
		КонецЦикла;
	КонецЕсли; 
	Если ЗначениеЗаполнено(ПараметрТекстПакета) Тогда
		Компонента = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ЭлементыФормы.ПолеТекстаЗапроса.Имя];
		Компонента.ПолеТекстовогоДокумента.УстановитьТекст(ПараметрТекстПакета);
		Компонента.ЗагрузитьТекстВКонструктор(, ЭтаФорма);
		ЭтаФорма.ПараметрТекстПакета = "";
	КонецЕсли; 
	ЭлементыФормы.ДоступныеТаблицы.Колонки.КоличествоСтрок.Видимость = Ложь;
	Если Не ЛиПакетныйЗапрос Тогда
		ИзменитьСвернутостьПанельПакета(ЛиПакетныйЗапрос);
	КонецЕсли;
	ЭтаФорма.ТекущийЭлемент = ЭлементыФормы.ФильтрДоступныхТаблиц;

КонецПроцедуры

// Выполняет программный код в контексте.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Функция ПроверитьВыражение(ТекстДляПроверки, ЛиСинтаксическийКонтроль = Ложь) Экспорт
	

КонецФункции // ВычислитьВФорме()

Процедура ОбновитьДоступныеВременныеТаблицы(ИмяВременнойТаблицы = Неопределено) Экспорт
	
	Если ТабличноеПолеКорневогоПакета <> ЭлементыФормы.ЗапросыПакета Тогда
		// Это вложенный запрос
		Возврат;
	КонецЕсли; 
	КлючПоиска = Новый Структура("Тип", "ВременнаяТаблица");
	Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
		КлючПоиска.Вставить("ПолноеИмя", ИмяВременнойТаблицы);
	КонецЕсли; 
	СтрокиТаблиц = ДоступныеТаблицы.НайтиСтроки(КлючПоиска);
	Если ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока <> Неопределено Тогда
		ИндексТекущегоЗапроса = ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
	Иначе
		ИндексТекущегоЗапроса = ЗапросыПакета.Количество() - 1;
	КонецЕсли; 
	Для Каждого СтрокаКУдалению Из СтрокиТаблиц Цикл
		СтрокаПородившегоЗапроса = ЗапросыПакета.Найти(СтрокаКУдалению.ПородившийЗапрос, "ИД");
		Если Истина
			И СтрокаПородившегоЗапроса <> Неопределено
			И ИндексТекущегоЗапроса <= ЗапросыПакета.Индекс(СтрокаПородившегоЗапроса) 
		Тогда
			ДоступныеТаблицы.Удалить(СтрокаКУдалению);
		КонецЕсли; 
	КонецЦикла;
	СтруктураДобавленныхТаблиц = Новый Соответствие();
	Для Индекс = 0 По ИндексТекущегоЗапроса - 1 Цикл
		ЗапросПакета = ЗапросыПакета[Индекс];
		Если ЗапросПакета.ТипЗапроса = 1 Тогда // Создание временной таблицы
			//Если ДоступныеТаблицы.Найти(НРег(ЗапросПакета.ИмяОсновнойТаблицы), "НПолноеИмя") = Неопределено Тогда
				СтруктураДобавленныхТаблиц.Вставить(ЗапросПакета.ИмяОсновнойТаблицы, ЗапросПакета.ИД);
			//КонецЕсли; 
		ИначеЕсли ЗапросПакета.ТипЗапроса = 2 Тогда // Удаление временной таблицы
			Если СтруктураДобавленныхТаблиц[ЗапросПакета.ИмяОсновнойТаблицы] <> Неопределено Тогда
				СтруктураДобавленныхТаблиц.Удалить(ЗапросПакета.ИмяОсновнойТаблицы);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	БылиДобавления = Ложь;
	Для Каждого КлючИЗначение Из СтруктураДобавленныхТаблиц Цикл
		НайтиДобавитьДоступнуюВременнуюТаблицу(КлючИЗначение.Ключ, КлючИЗначение.Значение, БылиДобавления);
	КонецЦикла;
	Если БылиДобавления Тогда
		СортироватьДоступныеТаблицы();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЗаполнитьДоступныеТаблицы1С()

	ДоступныеВременныеТаблицы = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "ВременнаяТаблица"));
	ДоступныеТаблицыПараметры = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "Параметр"));
	ДоступныеТаблицы.Очистить();
	ТабличноеПолеДоступныхТаблиц = ЭлементыФормы.ДоступныеТаблицы;
	Если ТабличноеПолеДоступныхТаблиц.ТекущаяСтрока <> Неопределено Тогда
		КлючТекущейСтроки = ТабличноеПолеДоступныхТаблиц.ТекущаяСтрока.ПолноеИмяОбъекта;
	Иначе
		КлючТекущейСтроки = Неопределено;
	КонецЕсли; 
	ТаблицаВсехТаблицБД = ирКэш.ПолучитьТаблицуВсехТаблицБДЛкс();
	ДоступныеТаблицы.Загрузить(ТаблицаВсехТаблицБД);
	ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ДоступныеВременныеТаблицы, ДоступныеТаблицы);
	ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ДоступныеТаблицыПараметры, ДоступныеТаблицы);
	ЭлементыФормы.ДоступныеТаблицы.Колонки.Тип.Видимость = Истина;
	ТекущаяСтрокаУстановлена = Ложь;
	Если КлючТекущейСтроки <> Неопределено Тогда
		НоваяТекущаяСтрока = ДоступныеТаблицы.Найти(КлючТекущейСтроки, "ПолноеИмяОбъекта", Истина);
		Если НоваяТекущаяСтрока <> Неопределено Тогда
			ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = НоваяТекущаяСтрока;
			ТекущаяСтрокаУстановлена = Истина;
		КонецЕсли; 
	КонецЕсли;
	ЗаполнитьСписокВыбораТиповТаблиц();
	
КонецПроцедуры

Процедура ЗаполнитьСписокВыбораТиповТаблиц()
	
	СписокВыбора = Новый СписокЗначений;
	КопияДоступныхТаблиц = ДоступныеТаблицы.Выгрузить(, "Тип");
	КопияДоступныхТаблиц.Свернуть("Тип");
	СписокВыбора.ЗагрузитьЗначения(КопияДоступныхТаблиц.ВыгрузитьКолонку("Тип"));
	СписокВыбора.СортироватьПоЗначению();
	Для Каждого ЭлементСпискаВыбора Из СписокВыбора Цикл
		ЭлементСпискаВыбора.Картинка = ирОбщий.ПолучитьКартинкуКорневогоТипаЛкс(ЭлементСпискаВыбора.Значение);
	КонецЦикла;
	ЭлементыФормы.ОтборПоТипуДоступнойТаблицы.СписокВыбора = СписокВыбора;
	
КонецПроцедуры

Функция ПолучитьДоступныеПоляТаблицы(ИмяИлиСтрокаВыбраннойТаблицы, ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ТипЗнч(ИмяИлиСтрокаВыбраннойТаблицы) = Тип("Строка") Тогда
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяИлиСтрокаВыбраннойТаблицы), "НИмя");
		Если ВыбраннаяТаблица = Неопределено Тогда
			ВызватьИсключение "Выбранная таблица """ + ИмяИлиСтрокаВыбраннойТаблицы+ """ не найдена";
		КонецЕсли; 
	Иначе
		ВыбраннаяТаблица = ИмяИлиСтрокаВыбраннойТаблицы;
	КонецЕсли; 
	ДоступныеПоляТаблицы = Новый ТаблицаЗначений;
	ДоступныеПоляТаблицы.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("Поле", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ВыбраннаяТаблица.ПолноеИмя);
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
	Если ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
		ПоляТаблицы = ВыбраннаяТаблица.ВложенныйПакет[0].ЧастиОбъединения[0].ВыбранныеПоля;
		//СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения; // Здесь еще надо тип вычислять
	ИначеЕсли СтрокаДоступнойТаблицы <> Неопределено Тогда
		ПоляТаблицы = ПолучитьПоляДоступнойТаблицы(СтрокаДоступнойТаблицы, ВыбраннаяТаблица.Параметры);
	Иначе
		ПоляТаблицы = Новый ТаблицаЗначений;
		ПоляТаблицы.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
		ПоляТаблицы.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
		СтрокаВиртуальногоПоля = ПоляТаблицы.Добавить();
		СтрокаВиртуальногоПоля.Имя = "_НеизвестноеПоле_";
	КонецЕсли;
	Если ПоляТаблицы <> Неопределено Тогда
		Для Каждого СтрокаПоля Из ПоляТаблицы Цикл
			СтрокаДоступногоПоля = ДоступныеПоляТаблицы.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаДоступногоПоля, СтрокаПоля); 
			ИмяПоля = СтрокаПоля.Имя;
			Если Не ирОбщий.ЛиИмяПеременнойЛкс(ИмяПоля) Тогда
				ИмяПоля = "[" + ИмяПоля + "]";
			КонецЕсли; 
			СтрокаДоступногоПоля.Имя = СтрокаПоля.Имя;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаДоступногоПоля);
			СтрокаДоступногоПоля.Поле = ИмяПоля;
			Если ЗначениеЗаполнено(ВыбраннаяТаблица.Имя) Тогда
				СтрокаДоступногоПоля.Поле = ВыбраннаяТаблица.Имя + "." + СтрокаДоступногоПоля.Поле;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	Возврат ДоступныеПоляТаблицы;

КонецФункции

Функция ПолучитьПоляДоступнойТаблицы(СтрокаДоступнойТаблицы, ПараметрыТаблицы = Неопределено)
	
	ПолноеИмяТаблицы = СтрокаДоступнойТаблицы.ПолноеИмя;
	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ТаблицаПолей.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	ТаблицаПолей.Колонки.Добавить("Метаданные");
	Если СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица" Тогда
		ПородившийЗапрос = ТабличноеПолеКорневогоПакета.Значение.Найти(СтрокаДоступнойТаблицы.ПородившийЗапрос, "ИД");
		КолонкиРезультата = Новый Массив();
		Если ПородившийЗапрос <> Неопределено Тогда
			//КолонкиРезультата = ПородившийЗапрос.ЧастиОбъединения[0].ВыбранныеПоля;
			КолонкиРезультата = ПородившийЗапрос.ПоляОбъединения;
		Иначе
			ТекстЗапроса = "SELECT * FROM " + ПолноеИмяТаблицы + " WHERE FALSE";
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				ВременныйЗапрос = Новый Запрос;
				ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ВременныйЗапрос.Текст = ТекстЗапроса;
				РезультатВременногоЗапроса = Неопределено;
				Попытка
					РезультатВременногоЗапроса = ВременныйЗапрос.Выполнить();
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					КолонкиРезультата = РезультатВременногоЗапроса.Колонки;
				КонецЕсли;
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				//
			Иначе // ADO
				Попытка
					РезультатВременногоЗапроса = Конфигурация.Execute(ТекстЗапроса);
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					РезультатТаблица = Новый ТаблицаЗначений;
					ирОбщий.ПолучитьКолонкиRecordsetADOЛкс(РезультатТаблица, РезультатВременногоЗапроса, Истина);
					КолонкиРезультата = РезультатТаблица.Колонки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			Если ВыбранноеПоле.Имя = "" Тогда
				ВызватьИсключение "Не определены имена полей таблицы """ + ПолноеИмяТаблицы + """";
			КонецЕсли; 
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли СтрокаДоступнойТаблицы.Тип = "Параметр" Тогда
		КолонкиРезультата = Новый Массив();
		ТаблицаПараметр = Неопределено;
		Если КонтекстВыполнения.Параметры.Свойство(СтрокаДоступнойТаблицы.Имя, ТаблицаПараметр) Тогда 
			КолонкиРезультата = ТаблицаПараметр.Колонки;
		КонецЕсли;
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
		ИндексПараметраПериодичность = Неопределено;
		ОпределениеПараметраПериодичность = "";
		Если ПараметрыТаблицы <> Неопределено Тогда
			Для ИндексПараметра = 0 По ПараметрыТаблицы.Количество() - 1 Цикл
				СтрокаПараметраТаблицы = ПараметрыТаблицы[ИндексПараметра];
				Если ЭтоПараметрПериодичность1С(СтрокаПараметраТаблицы) Тогда
					ИндексПараметраПериодичность = ИндексПараметра;
					ОпределениеПараметраПериодичность = СтрокаПараметраТаблицы.Определение;
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
		ПоляТаблицыБД = ирОбщий.ПолучитьПоляТаблицыМДЛкс(ПолноеИмяТаблицы, Ложь, ИндексПараметраПериодичность, ОпределениеПараметраПериодичность, Ложь);
		#Если Сервер И Не Сервер Тогда
		    ПоляТаблицыБД = ПолучитьСтруктуруХраненияБазыДанных().Колонки;
		#КонецЕсли
		Если ПоляТаблицыБД <> Неопределено Тогда
			Для Каждого ПолеТаблицыБД Из ПоляТаблицыБД Цикл
				//Если ПолеТаблицыБД.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений")) Тогда
				//	Продолжить;
				//КонецЕсли;
				СтрокаПоля = ТаблицаПолей.Добавить();
				СтрокаПоля.Имя = ПолеТаблицыБД.Имя;
				СтрокаПоля.ТипЗначения = ПолеТаблицыБД.ТипЗначения;
				СтрокаПоля.Метаданные = ПолеТаблицыБД.Метаданные;
			КонецЦикла;
		КонецЕсли; 
	Иначе
		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ПолноеИмяТаблицы);
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
		Если ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
			wbemFlagUseAmendedQualifiers = 131072; //&H20000
			ОписаниеКласса = Конфигурация.Get(СтрокаДоступнойТаблицы.Имя, wbemFlagUseAmendedQualifiers);
			ТаблицаКласса = Новый ТаблицаЗначений;
			МассивКоллекцийСвойств = Новый Массив();
			МассивКоллекцийСвойств.Добавить(ОписаниеКласса.Properties_);
			//Если СобиратьСистемныеСвойстваWMI Тогда
			//	МассивКоллекцийСвойств.Добавить(ОписаниеКласса.SystemProperties_);
			//КонецЕсли; 
			Для Каждого КоллекцияСвойств Из МассивКоллекцийСвойств Цикл
				Для Каждого Свойство Из КоллекцияСвойств Цикл
					ИмяТипа = ирОбщий.ПолучитьИмяТипаИзКвалификаторовWMIЛкс(Свойство);
					Попытка
						ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа,,,, Новый КвалификаторыСтроки(1024)); // Доделать распознавание типов
					Исключение
						ОписаниеТипов = Новый ОписаниеТипов();
					КонецПопытки;
					ПредставлениеСвойства = ирОбщий.ПолучитьОписаниеЭлементаWMIЛкс(Свойство, "DisplayName");
					ТаблицаКласса.Колонки.Добавить(, ОписаниеТипов, ПредставлениеСвойства);
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = Свойство.Name;
					СтрокаПоля.ТипЗначения = ОписаниеТипов;
					//СтрокаПоля.Описание = ПредставлениеСвойства;
				КонецЦикла;
			КонецЦикла;
		Иначе // ADO
			Фильтры = Новый Массив();
			Фильтры.Добавить(); //TABLE_CATALOG
			Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда //TABLE_SCHEMA
				Фильтры.Добавить(СтрокаДоступнойТаблицы.Схема);
			Иначе
				Фильтры.Добавить(Неопределено);
			КонецЕсли; 
			Фильтры.Добавить(СтрокаДоступнойТаблицы.Имя); // TABLE_NAME
			Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
			Состояние("Запрашиваем поля " + ПолноеИмяТаблицы + "...");
			ОписаниеПолейRecordSet = Конфигурация.OpenSchema(4, Фильтры); //adSchemaColumns
			ADOUtils = мПлатформа.ПолучитьADOUtils();
			Если ADOUtils <> Неопределено Тогда
				ОписаниеПолейТЗ = ADOUtils.ADORecordsetToValueTable(ОписаниеПолейRecordSet);
				Для Каждого СтрокаТЗ Из ОписаниеПолейТЗ Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = СтрокаТЗ.COLUMN_NAME;
					ЧисловаяРазрядность = СтрокаТЗ.NUMERIC_SCALE;
					ДлинаТипа = СтрокаТЗ.CHARACTER_MAXIMUM_LENGTH;
					ЧисловаяТочность = СтрокаТЗ.NUMERIC_PRECISION;
					НомерТипа = СтрокаТЗ.DATA_TYPE;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
				КонецЦикла;
			Иначе
				Пока Не ОписаниеПолейRecordSet.EOF() Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ОписаниеПолейRecordSet.Fields("COLUMN_NAME").Value;
					ЧисловаяРазрядность = ОписаниеПолейRecordSet.Fields("NUMERIC_SCALE").Value;
					ДлинаТипа = ОписаниеПолейRecordSet.Fields("CHARACTER_MAXIMUM_LENGTH").Value;
					ЧисловаяТочность = ОписаниеПолейRecordSet.Fields("NUMERIC_PRECISION").Value;
					НомерТипа = ОписаниеПолейRecordSet.Fields("DATA_TYPE").Value;
					FieldADO = ирОбщий.FieldADOЛкс(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирОбщий.FieldADO_ПолучитьТип1CЛкс(FieldADO, Истина);
					ОписаниеПолейRecordSet.MoveNext();
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Состояние();
	КонецЕсли; 
	Возврат ТаблицаПолей;
	
КонецФункции

Процедура ОбновлениеОтображения()
	
	Если ТипЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ирОбщий.ОбновитьЗаголовкиСтраницПанелейЛкс(ЭтаФорма);
	Если ПараметрыДиалектаSQL <> Неопределено Тогда
		ЭлементыФормы.ВыбранныеТаблицыПанельЭлемента.Доступность = ЭлементыФормы.ВыбранныеТаблицы.Значение.Количество() > 0;
		ЭлементыФормы.ВыбранныеПоляПанельЭлемента.Доступность = ЭлементыФормы.ВыбранныеПоля.Значение.Количество() > 0;
		ЭлементыФормы.СвязиТаблицПанельЭлемента.Доступность = Истина
			И ЭлементыФормы.СвязиТаблиц.Значение.Строки.Количество() > 0
			И ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока <> СвязиТаблиц.Строки[0];
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.Доступность = ЭлементыФормы.ДеревоУсловияСвязи.Значение.Элементы.Количество() > 0;
		ЭлементыФормы.РежимОбъединения.Доступность = Истина
			И ПараметрыДиалектаSQL.Объединения 
			И (ТипЗапроса < 2 Или (ТипЗапроса = 3 И ЗначенияИзВыборки))
			И ЧастиОбъединения.Количество() = 1;
		//ЭлементыФормы.ЛиПакетныйЗапрос.Доступность = Истина
		//	И ТабличноеПолеКорневогоПакета = ЭлементыФормы.ЗапросыПакета
		//	И ПараметрыДиалектаSQL.Пакет 
		//	И ЗапросыПакета.Количество() = 1;
		ТекущийНомерЗапроса = "";
		Если ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока <> Неопределено Тогда
			ТекущийНомерЗапроса = ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
		КонецЕсли; 
		ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(ЭлементыФормы.ЛиПакетныйЗапрос, "Заголовок", "" + ТекущийНомерЗапроса + "/" + ЗапросыПакета.Количество() + ")", " (");
		ЭлементыФормы.ИмяОсновнойТаблицы.Доступность = Ложь
			Или ТипЗапроса <> 0;
		ЭлементыФормы.КомментарийОтбора.Доступность = ТипЗапроса <> 2 И ТипЗапроса <> 6 И (ТипЗапроса <> 3 Или ЗначенияИзВыборки);
		//ЭлементыФормы.ПринимающиеПоля.Доступность = ТипЗапроса <> 5;
		ЭлементыФормы.ЗначенияИзВыборки.Доступность = ТипЗапроса = 3;
		ЭлементыФормы.ОпцияПервые.Доступность = Истина
			И ПараметрыДиалектаSQL.Первые 
			И ТипЗапроса <> 2
			И ТипЗапроса <> 6
			И (ТипЗапроса <> 3 Или ЗначенияИзВыборки);
		ЭлементыФормы.ПервыеКоличество.Доступность = ЭлементыФормы.ОпцияПервые.Доступность;
		ЭлементыФормы.ОпцияРазрешенные.Доступность = Истина
			И ПараметрыДиалектаSQL.Это1С
			И ТипЗапроса < 2;
		//Если ТипЗапроса = 2 Тогда
		//	Если Истина
		//		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения
		//		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.Текст
		//	Тогда
		//		ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения;
		//	КонецЕсли; 
		//	Если Истина
		//		И ЭлементыФормы.ПанельЧасти.ТекущаяСтраница <> ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти
		//	Тогда
		//		ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти;
		//	КонецЕсли; 
		//КонецЕсли; 
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляИндекса.Видимость = ТипЗапроса = 1;
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляПорядка.Видимость = ТипЗапроса < 2;
		ЭлементыФормы.ПанельОсновная.Страницы.Параметры.Видимость = ТипЗапроса <> 2 И ТипЗапроса <> 6;
		ЭлементыФормы.ПанельОсновная.Страницы.Итоги.Видимость = ТипЗапроса < 2;
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения.Видимость = Истина
			И ПараметрыДиалектаSQL.Объединения 
			//И ЧастиОбъединения.Количество() > 1 // Для исправления пользователем пока имеющихся ошибок в сборе полей объединения
			И РежимОбъединения;
		ЭлементыФормы.ПанельОсновная.Страницы.Построитель.Видимость = ТипЗапроса < 2;
		ЭлементыФормы.ПанельОсновная.Страницы.ПринимающиеПоля.Видимость = ТипЗапроса = 3 Или ТипЗапроса = 4;
		ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц.Видимость = Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ТипЗапроса <> 2
			И ТипЗапроса <> 6
			И (ТипЗапроса <> 3 Или ЗначенияИзВыборки)
			И ВыбранныеТаблицы.Количество() > 1;
		ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеПоля.Видимость = ТипЗапроса < 2 Или (ТипЗапроса = 3 И ЗначенияИзВыборки);
		ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеТаблицы.Видимость = ТипЗапроса <> 2 И ТипЗапроса <> 6 И (ТипЗапроса <> 3 Или ЗначенияИзВыборки);
		ЭлементыФормы.ПанельЧасти.Страницы.ДеревоУсловия.Видимость = ТипЗапроса <> 2 И ТипЗапроса <> 6 И (ТипЗапроса <> 3 Или ЗначенияИзВыборки);
		ЭлементыФормы.ПанельЧасти.Страницы.Группировки.Видимость = Истина
			И ПараметрыДиалектаSQL.Группировки
			И (Ложь
				Или ТипЗапроса < 2 
				Или (Истина
					И ТипЗапроса = 3
					И ЗначенияИзВыборки));
		ЭлементыФормы.ПанельЧасти.Страницы.Текст.Видимость = ТипЗапроса <> 2 И ТипЗапроса <> 6 И (ТипЗапроса <> 3 Или ЗначенияИзВыборки);
		ЭлементыФормы.ПанельЧасти.Страницы.Построитель.Видимость = ТипЗапроса < 2;
	КонецЕсли; 

КонецПроцедуры

Функция ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки)

	ТаблицаДобавленаВСвязи = Ложь
		Или СвязиТаблиц.Строки.Найти(ДанныеСтроки.Имя, "Таблица", Истина) <> Неопределено;
	Если ТаблицаДобавленаВСвязи Тогда
		ОформлениеСтроки.ЦветТекста = ирОбщий.ПолучитьЦветСтиляЛкс("ирТекстИнформационнойНадписи");
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Процедура ВыборЛевойТаблицыСвязиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки);
	ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ВыборПравойТаблицыСвязиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки);
	ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ВыбранныеТаблицыИмяПриИзменении(Элемент = Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	СкорректироватьПсевдонимТаблицы(мТекущаяСтрокаВыбранныеТаблицы);
	мТекущаяСтрокаВыбранныеТаблицы.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(мТекущаяСтрокаВыбранныеТаблицы.Владелец(),
		мТекущаяСтрокаВыбранныеТаблицы,,, ПолучитьСловоЯзыкаЗапросов("Table") + "1");
	НовоеИмяТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Имя;
	//Если ирОбщий.СтрокиРавныЛкс(мТекущееИмяВыбраннойТаблицы, НовоеИмяТаблицы)  Тогда
	Если мТекущееИмяВыбраннойТаблицы = НовоеИмяТаблицы Тогда
		Возврат;
	КонецЕсли; 
	ПереименоватьТаблицуИлиПараметр(, мТекущееИмяВыбраннойТаблицы, НовоеИмяТаблицы,,, Ложь);
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(мТекущаяСтрокаВыбранныеТаблицы);
	ОбновитьКомпоновщикЧастиОбъединения();
	ОбновитьТекущееИмяТаблицы();
	ЗагрузитьВыражениеУсловия();
	ЗагрузитьВыражениеУсловияСвязи();
	ЗагрузитьПараметрТаблицы();
	ЗагрузитьВыбранноеПоле();
	ЗагрузитьСвязьТаблицы();
	
КонецПроцедуры

Процедура ПереименоватьТаблицуИлиПараметр(Пакет = Неопределено, СтароеИмяТаблицыИлиПараметра = "", НовоеИмяТаблицыИлиПараметра = "", пСтароеИмяПоля = "", пНовоеИмяПоля = "",
	ГлобальныйОбход = Истина)
    
    Состояние("Обновление выражений...");
	ЭтоПереименованиеПараметра = ПараметрыДиалектаSQL.ПрефиксПараметра = Лев(СтароеИмяТаблицыИлиПараметра, 1);
	//ГлобальныйОбход = ЭтоПереименованиеПараметра Или ЗначениеЗаполнено(СтароеИмяТаблицыИлиПараметра);
	Если Пакет = Неопределено Тогда
		Если ГлобальныйОбход Тогда
			Пакет = ЗапросыПакета;
		Иначе
			Пакет = Новый Массив;
			Пакет.Добавить(мТекущаяСтрокаЗапросыПакета);
		КонецЕсли; 
	КонецЕсли; 
	Для Каждого ЗапросПакета Из Пакет Цикл
		Если ГлобальныйОбход Тогда
			лЧастиОбъединения = ЗапросПакета.ЧастиОбъединения;
			Если ирОбщий.СтрокиРавныЛкс(ЗапросПакета.ИмяОсновнойТаблицы, СтароеИмяТаблицыИлиПараметра) Тогда
				ЗапросПакета.ИмяОсновнойТаблицы = НовоеИмяТаблицыИлиПараметра;
				ОбновитьНаименованиеЗапроса(ЗапросПакета);
			КонецЕсли; 
		Иначе
			лЧастиОбъединения = Новый Массив;
			лЧастиОбъединения.Добавить(мТекущаяСтрокаЧастиОбъединения);
		КонецЕсли;
		Для Каждого ЧастьОбъединения Из лЧастиОбъединения Цикл
			СоответствиеЗаменПолей = Новый Соответствие;
			Если ГлобальныйОбход Тогда
				Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
					Для Каждого ПараметрТаблицы Из ВыбраннаяТаблица.Параметры Цикл
						Если ЗначениеЗаполнено(ПараметрТаблицы.Определение) Тогда
					        ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, , ЧастьОбъединения, СтароеИмяТаблицыИлиПараметра, НовоеИмяТаблицыИлиПараметра,,,, 0);
							Если мТекущаяСтрокаПараметраТаблицы = ПараметрТаблицы Тогда
								ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст(мТекущаяСтрокаПараметраТаблицы.Определение);
							КонецЕсли; 
						КонецЕсли; 
					КонецЦикла;
					Если ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
						ПереименоватьТаблицуИлиПараметр(ВыбраннаяТаблица.ВложенныйПакет, СтароеИмяТаблицыИлиПараметра, НовоеИмяТаблицыИлиПараметра, пСтароеИмяПоля, пНовоеИмяПоля);
					ИначеЕсли ирОбщий.СтрокиРавныЛкс(ВыбраннаяТаблица.ПолноеИмя, СтароеИмяТаблицыИлиПараметра) Тогда
						ВыбраннаяТаблица.ПолноеИмя = НовоеИмяТаблицыИлиПараметра;
					КонецЕсли;
				КонецЦикла;
				СтрокиВыбранныхТаблиц = ЧастьОбъединения.ВыбранныеТаблицы.НайтиСтроки(Новый Структура("ПолноеИмя", СтароеИмяТаблицыИлиПараметра));
				Если СтрокиВыбранныхТаблиц.Количество() > 0 Тогда
					Для Каждого СтрокаВыбраннойТаблицы Из СтрокиВыбранныхТаблиц Цикл
						СтрокаВыбраннойТаблицы.ПолноеИмя = НовоеИмяТаблицыИлиПараметра;
						Если ЗначениеЗаполнено(пСтароеИмяПоля) Тогда
							СтароеИмя = СтрокаВыбраннойТаблицы.Имя + "." + пСтароеИмяПоля;
							НовоеИмя = СтрокаВыбраннойТаблицы.Имя + "." + пНовоеИмяПоля;
							СоответствиеЗаменПолей[СтароеИмя] = НовоеИмя;
						КонецЕсли; 
					КонецЦикла;
				ИначеЕсли Не ЭтоПереименованиеПараметра Тогда 
					Продолжить;
				КонецЕсли;
			КонецЕсли; 
			Если Не ГлобальныйОбход Или ЭтоПереименованиеПараметра Тогда 
				Если ЗначениеЗаполнено(пСтароеИмяПоля) Тогда
					//СоответствиеЗаменПолей[пСтароеИмяПоля] = пНовоеИмяПоля;
					СтароеИмя = СтароеИмяТаблицыИлиПараметра + "." + пСтароеИмяПоля;
					НовоеИмя = НовоеИмяТаблицыИлиПараметра + "." + пНовоеИмяПоля;
					СоответствиеЗаменПолей[СтароеИмя] = НовоеИмя;
				Иначе
					СоответствиеЗаменПолей[СтароеИмяТаблицыИлиПараметра] = НовоеИмяТаблицыИлиПараметра;
				КонецЕсли; 
			КонецЕсли;
			Для Каждого ЗаменаПолей Из СоответствиеЗаменПолей Цикл
				СтароеИмя = ЗаменаПолей.Ключ;
				НовоеИмя = ЗаменаПолей.Значение;
				Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
					ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, , ЧастьОбъединения, СтароеИмя, НовоеИмя,,,, 0);
					Если мТекущаяСтрокаВыбранногоПоля = ВыбранноеПоле Тогда
						ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(мТекущаяСтрокаВыбранногоПоля.Определение);
					КонецЕсли; 
				КонецЦикла;
				Для Каждого ПолеГруппировки Из ЧастьОбъединения.Группировки Цикл
					ОбновитьВыражениеЗапроса(ПолеГруппировки, ЭлементыФормы.Группировки, , ЧастьОбъединения, СтароеИмя, НовоеИмя,,,, 0);
				КонецЦикла;
				Для Каждого СвязьТаблиц Из ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(ЧастьОбъединения.СвязиТаблиц) Цикл
					Если ирОбщий.СтрокиРавныЛкс(СвязьТаблиц.Таблица, СтароеИмя) Тогда
						СвязьТаблиц.Таблица = НовоеИмя;
					КонецЕсли; 
					Если СвязьТаблиц.Условие = Неопределено Тогда
						Продолжить;
					КонецЕсли; 
					ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи, , ЧастьОбъединения, СтароеИмя, НовоеИмя);
				КонецЦикла;
				//ОбновитьВыраженияОтбора(ЧастьОбъединения.Условие.Отбор, ЭлементыФормы.ДеревоУсловия, , ЧастьОбъединения, СтароеИмя, НовоеИмя);
				ОбновитьВыраженияОтбора(ЧастьОбъединения.Компоновщик.Настройки.Отбор, ЭлементыФормы.ДеревоУсловия, , ЧастьОбъединения, СтароеИмя, НовоеИмя);
				Для Каждого ПолеПорядка Из мТекущаяСтрокаЗапросыПакета.ПоляПорядка Цикл
					ОбновитьВыражениеЗапроса(ПолеПорядка, ЭлементыФормы.ПоляПорядка,,,,,,, Ложь, 0);
				КонецЦикла;
				//Для Каждого ГруппируемоеПолеИтогов Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
				//	ОбновитьВыражениеЗапроса(ГруппируемоеПолеИтогов);
				//КонецЦикла;
				//Для Каждого ГруппирующееПолеИтогов Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
				//	ОбновитьВыражениеЗапроса(ГруппирующееПолеИтогов);
				//КонецЦикла;
				//ОбновитьПоляОбъединенияЗапроса();
				Для Каждого ПолеПостроителя Из ЧастьОбъединения.ПоляВыбораПостроителя Цикл
					ОбновитьВыражениеЗапроса(ПолеПостроителя, ЭлементыФормы.ПоляВыбораПостроителя, , ЧастьОбъединения, СтароеИмя, НовоеИмя,,,, 0);
				КонецЦикла;
				Для Каждого ПолеПостроителя Из ЧастьОбъединения.ПоляОтбораПостроителя Цикл
					ОбновитьВыражениеЗапроса(ПолеПостроителя, ЭлементыФормы.ПоляВыбораПостроителя, , ЧастьОбъединения, СтароеИмя, НовоеИмя,,,, 0);
				КонецЦикла;
			КонецЦикла;
		КонецЦикла; 
	КонецЦикла;
    Состояние("");

КонецПроцедуры

Процедура ДоступныеПоляЛевогоПоляПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если Истина
		И ТекущаяСтрокаУсловияСвязи <> Неопределено
		И Не Элемент.ТекущаяСтрока.Папка
		И ТипЗнч(ТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных")
	Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.ЛевоеЗначение = Элемент.ТекущаяСтрока.Поле;
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.Использование = Истина;
	КонецЕсли; 

КонецПроцедуры

Процедура ДоступныеПоляПравогоПоляПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если Истина
		И ТекущаяСтрокаУсловияСвязи <> Неопределено
		И Не Элемент.ТекущаяСтрока.Папка
		И ТипЗнч(ТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных")
	Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.ПравоеЗначение = Элемент.ТекущаяСтрока.Поле;
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.Использование = Истина;
	КонецЕсли; 

КонецПроцедуры

Процедура ВыборЛевойТаблицыСвязиПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаСвязи = ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока;
	Если ТекущаяСтрокаСвязи <> Неопределено Тогда
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.Таблица <> Элемент.ТекущаяСтрока.Имя Тогда
			ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.ЛеваяТаблица = Элемент.ТекущаяСтрока.Имя;
			//ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока, "ЛеваяТаблица");
			ПриУстановкеЛевойТаблицыСвязи();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура ПриУстановкеЛевойТаблицыСвязи()
	
	// Надо раскрыть ветвь ее доступных полей
	
КонецПроцедуры

Процедура ВыборПравойТаблицыСвязиПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаСвязи = ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока;
	Если ТекущаяСтрокаСвязи <> Неопределено Тогда
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.Таблица <> Элемент.ТекущаяСтрока.Имя Тогда
			ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.Таблица = Элемент.ТекущаяСтрока.Имя;
			//ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока, "ПраваяТаблица");
			ПриУстановкеПравойТаблицыСвязи();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура ПриУстановкеПравойТаблицыСвязи()
	
	// Надо раскрыть ветвь ее доступных полей
	
КонецПроцедуры

Процедура СвязиТаблицПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки.Условие <> Неопределено Тогда
		ОформлениеСтроки.Ячейки.Условие.УстановитьТекст(ДанныеСтроки.Условие.Отбор);
	КонецЕсли; 
	Если ЗначениеЗаполнено(ДанныеСтроки.ТипСвязи) Тогда
		ПредставлениеТипаСвязи = ЭлементыФормы.СвязиТаблиц.Колонки.ТипСвязи.ЭлементУправления.СписокВыбора.НайтиПоЗначению(ДанныеСтроки.ТипСвязи).Представление;
		ОформлениеСтроки.Ячейки.ТипСвязи.УстановитьТекст(ПредставлениеТипаСвязи);
	КонецЕсли; 
	//ОформлениеСтроки.Ячейки.Номер.Значение = СвязиТаблиц.Строки.Индекс(ДанныеСтроки) + 1;
	ОформитьЯчейкуИмениТаблицы(Элемент, ОформлениеСтроки, ДанныеСтроки, "Таблица");
	
КонецПроцедуры

Процедура СохранитьВыбранноеПоле()
	
	Если мТекущаяСтрокаВыбранногоПоля = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ВыбранныеПоля.Индекс(мТекущаяСтрокаВыбранногоПоля) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	мТекущаяСтрокаВыбранногоПоля.Определение = ЭлементыФормы.ВыражениеВыбранногоПоля.ПолучитьТекст();
	ПриИзмененииВыраженияВыбранногоПоля(мТекущаяСтрокаВыбранногоПоля);
	
КонецПроцедуры

Процедура ПриИзмененииВыраженияВыбранногоПоля(ВыбранноеПоле = Неопределено, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	ОбновитьПоляОбъединения = Истина)

	Если ВыбранноеПоле = Неопределено Тогда
		ВыбранноеПоле = мТекущаяСтрокаВыбранногоПоля;
	КонецЕсли; 
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ЕстьАгрегаты = Ложь;
	ОбновитьВыражениеЗапроса(ВыбранноеПоле,,,,,,, ЕстьАгрегаты);
	Попытка
		ВыбранноеПоле.ТипЗначения = ПолучитьТипЗначенияВыражения(ВыбранноеПоле.Токен, ЧастьОбъединения);
	Исключение
		АктивизироватьТабличноеПоле(ЭлементыФормы.ВыбранныеПоля);
		ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока = ВыбранноеПоле;
		ВызватьИсключение;
	КонецПопытки; 
	ВыбранноеПоле.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ВыбранноеПоле.Токен);
	ВыбранноеПоле.ЕстьАгрегаты = ЕстьАгрегаты;
	Если мТекущаяСтрокаВыбранногоПоля = ВыбранноеПоле Тогда
		ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(мТекущаяСтрокаВыбранногоПоля.Определение);
	КонецЕсли; 
	ОбновитьГруппировки();
	Если ОбновитьПоляОбъединения Тогда
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьГруппировки(ЗаполнитьГруппировки = Ложь)
	
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.ТолькоПросмотр = Автогруппировки;
	ЭлементыФормы.Группировки.ТолькоПросмотр = Автогруппировки;
	Если Автогруппировки Тогда
		КопияГруппировок = Группировки.Скопировать();
		Группировки.Очистить();
		// Здесь не учитывается использование агрегатор в выражении WHERE
		// Перенесено в СобратьТекстЧастиОбъединения
		//ЕстьАгрегаты = ВыбранныеПоля.Найти(Истина, "ЕстьАгрегаты") <> Неопределено;
		//Если ЕстьАгрегаты Тогда
		//	Для Каждого ВыбранноеПоле Из ВыбранныеПоля Цикл
		//		Если ВыбранноеПоле.ЕстьАгрегаты Тогда
		//			Продолжить;
		//		КонецЕсли; 
		//		Группировка = Группировки.Найти(ВыбранноеПоле.Определение, "Определение");
		//		Если Группировка = Неопределено Тогда
		//			Группировка = Группировки.Добавить();
		//			Группировка.Определение = ВыбранноеПоле.Определение;
		//			Группировка.Токен = ВыбранноеПоле.Токен; // !Опасно
		//			СтрокаКопииГруппировки = КопияГруппировок.Найти(ВыбранноеПоле.Определение, "Определение"); // Чувствительность к регистру!
		//			Если СтрокаКопииГруппировки <> Неопределено Тогда
		//				Группировка.Комментарий = СтрокаКопииГруппировки.Комментарий;
		//			КонецЕсли; 
		//		КонецЕсли;
		//	КонецЦикла;
		//КонецЕсли;
	ИначеЕсли ЗаполнитьГруппировки Тогда 
		ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока.Автогруппировки = Истина;
		СобратьТекстЧастиОбъединения();
		ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока.Автогруппировки = Ложь;
	КонецЕсли; 
	
КонецПроцедуры

Процедура СохранитьВыражениеУсловияСвязи()
	
	Если Ложь 
		Или мТекущаяСтрокаУсловияСвязи = Неопределено 
		Или ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ОтборКомпоновкиДанных")
	Тогда
		Возврат;
	КонецЕсли; 
	Родитель = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(мТекущаяСтрокаУсловияСвязи, КомпоновщикУсловияСвязи.Настройки.Отбор);
	Если Родитель.Элементы.Индекс(мТекущаяСтрокаУсловияСвязи) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	Если Не ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность Тогда
		Возврат;
	КонецЕсли; 
	мТекущаяСтрокаУсловияСвязи.Представление = ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.ПолучитьТекст();
	//ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловияСвязи, ЭлементыФормы.ДеревоУсловияСвязи);
	Если ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловияСвязи);
	КонецЕсли; 
	
КонецПроцедуры

Процедура СохранитьВыражениеУсловия()
	
	Если Ложь 
		Или мТекущаяСтрокаУсловия = Неопределено 
		Или ТипЗнч(мТекущаяСтрокаУсловия) = Тип("ОтборКомпоновкиДанных")
	Тогда
		Возврат;
	КонецЕсли; 
	Родитель = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(мТекущаяСтрокаУсловия, КомпоновщикЧасти.Настройки.Отбор);
	Если Родитель.Элементы.Индекс(мТекущаяСтрокаУсловия) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	Если Не ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность Тогда
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаУсловия.Представление = ЭлементыФормы.ВыражениеЭлементаУсловия.ПолучитьТекст();
	//ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловия, ЭлементыФормы.ДеревоУсловия);
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловия);
	
КонецПроцедуры

Процедура СохранитьУсловиеСвязи()
	
	Если мТекущаяСтрокаСвязи = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Попытка
		Пустышка = мТекущаяСтрокаСвязи.Родитель;
	Исключение
		// Строка была удалена
		Возврат;
	КонецПопытки;
	СохранитьВыражениеУсловияСвязи();
	мТекущаяСтрокаСвязи.Условие = КомпоновщикУсловияСвязи.ПолучитьНастройки();
	
КонецПроцедуры

Процедура ДеревоУсловияСвязиПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьВыражениеУсловияСвязи();
	ЗагрузитьВыражениеУсловияСвязи();
	Если Истина
		И ТипЗнч(мТекущаяСтрокаУсловияСвязи) <> Тип("ЭлементОтбораКомпоновкиДанных")
		И ЭлементыФормы.СвязиТаблиц.ТекущиеДанные <> Неопределено
		И ЭлементыФормы.СвязиТаблиц.ТекущиеДанные.Родитель <> Неопределено 
	Тогда
		ДоступноеПолеЛевойТаблицы = КомпоновщикУсловияСвязи.Настройки.Отбор.ДоступныеПоляОтбора.Элементы.Найти(ЭлементыФормы.СвязиТаблиц.ТекущиеДанные.Родитель.Таблица);
		Если ДоступноеПолеЛевойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = ДоступноеПолеЛевойТаблицы;
			ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.Развернуть(ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока);
		КонецЕсли; 
		ДоступноеПолеПравойТаблицы = КомпоновщикУсловияСвязи.Настройки.Отбор.ДоступныеПоляОтбора.Элементы.Найти(ЭлементыФормы.СвязиТаблиц.ТекущиеДанные.Таблица);
		Если ДоступноеПолеПравойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = ДоступноеПолеПравойТаблицы;
			ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.Развернуть(ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЗагрузитьВыражениеУсловияСвязи()

	мТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтароеИспользование = мТекущаяСтрокаУсловияСвязи.Использование;
		Если ТипЗнч(мТекущаяСтрокаУсловияСвязи.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			СтрокаВыбораЛевогоПоля = КомпоновщикУсловияСвязи.Настройки.ДоступныеПоляОтбора.НайтиПоле(мТекущаяСтрокаУсловияСвязи.ЛевоеЗначение);
			Если СтрокаВыбораЛевогоПоля <> Неопределено Тогда
				ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = СтрокаВыбораЛевогоПоля;
			КонецЕсли; 
		КонецЕсли; 
		Если ТипЗнч(мТекущаяСтрокаУсловияСвязи.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			СтрокаВыбораПравогоПоля = КомпоновщикУсловияСвязи.Настройки.ДоступныеПоляОтбора.НайтиПоле(мТекущаяСтрокаУсловияСвязи.ПравоеЗначение);
			Если СтрокаВыбораПравогоПоля <> Неопределено Тогда
				ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = СтрокаВыбораПравогоПоля;
			КонецЕсли; 
		КонецЕсли;
		мТекущаяСтрокаУсловияСвязи.Использование = СтароеИспользование;
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст(мТекущаяСтрокаУсловияСвязи.Представление);
		ЭлементыФормы.УсловиеСвязиПанельЭлемента.Доступность = Истина;
		Если мТекущаяСтрокаУсловияСвязи.Представление = "" Тогда
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей.Доступность = Истина;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.ТекущаяСтраница = ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность = Ложь;
			
			// Антибаг платформы. Дерево доступных полей перестает отображаться после того, как страница становилась недоступной
			ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.Доступность = Ложь;
			ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.Доступность = Истина;
			ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.Доступность = Ложь;
			ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.Доступность = Истина;
		Иначе
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность = Истина;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.ТекущаяСтраница = ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей.Доступность = Ложь;
		КонецЕсли; 
	Иначе
		ЭлементыФормы.УсловиеСвязиПанельЭлемента.Доступность = Ложь;
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст("");
	КонецЕсли; 
	
КонецПроцедуры

Процедура УсловияПриАктивизацииСтроки(Элемент)
	
	СохранитьВыражениеУсловия();
	мТекущаяСтрокаУсловия = Элемент.ТекущаяСтрока;
	Если мТекущаяСтрокаУсловия <> Неопределено Тогда
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	//Если Не ОтменаРедактирования Тогда
	//	Элемент.ТекущиеДанные.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,, ПолучитьСловоЯзыкаЗапросов("Table") + "1");
	//	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(Элемент.ТекущиеДанные);
	//КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		Элемент.ТекущиеДанные.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,,
			ПолучитьСловоЯзыкаЗапросов("Field") + "1");
	КонецЕсли; 

КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицОчистка(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	Элемент.Значение = "";
	
КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицПриИзменении(Элемент)
	
	ирОбщий.ПолеВводаСИсториейВыбора_ПриИзмененииЛкс(Элемент, ЭтаФорма);
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Имя.ВидСравнения = ВидСравнения.Содержит;
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Имя.Использование = Истина;

КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицНачалоВыбораИзСписка(Элемент, СтандартнаяОбработка)
	
	ирОбщий.ПолеВводаСИсториейВыбора_НачалоВыбораИзСпискаЛкс(Элемент, ЭтаФорма);

КонецПроцедуры

Процедура ДоступныеТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступнуюТаблицуВВыбранные(ВыбраннаяСтрока);
	СтандартнаяОбработка = Ложь;
	
КонецПроцедуры

Процедура ДоступныеПоляВыбораВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Если Не ПараметрыДиалектаSQL.МногоТаблиц Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли; 
	Если Не Копирование Тогда
		Отказ = Истина;
		ВложенныйПакет = ОткрытьВложенныйПакет();
		Если ВложенныйПакет <> Неопределено Тогда
			ЗаполнитьСтрокуВложенногоПакета(ВложенныйПакет);
		КонецЕсли;
	Иначе
		Если Элемент.ТекущаяСтрока.ВложенныйПакет <> Неопределено Тогда
			Отказ = Истина;
			ВложенныйПакет = СкопироватьВложенныйПакетДляРедактирования(Элемент.ТекущаяСтрока.ВложенныйПакет);
			ВложенныйПакет = ОткрытьВложенныйПакет(ВложенныйПакет);
			Если ВложенныйПакет <> Неопределено Тогда
				ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
				ЗаполнитьЗначенияСвойств(ВыбраннаяТаблица, Элемент.ТекущаяСтрока, , "ВложенныйПакет"); 
				ЗаполнитьСтрокуВложенногоПакета(ВложенныйПакет, ВыбраннаяТаблица);
			КонецЕсли;
		Иначе
			СкопированнаяСтрока = Элемент.ТекущаяСтрока;
			ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
			ЗаполнитьЗначенияСвойств(ВыбраннаяТаблица, СкопированнаяСтрока); 
			ВыбраннаяТаблица.Параметры = СкопированнаяСтрока.Параметры.Скопировать();
			ВыбраннаяТаблица.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, ВыбраннаяТаблица);
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
			ОбновитьКомпоновщикЧастиОбъединения();
			НайтиДобавитьВыбраннуюТаблицуВСвязи(ВыбраннаяТаблица);
			Элемент.ТекущаяСтрока = ВыбраннаяТаблица;
			Отказ = Истина;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЗаполнитьСтрокуВложенногоПакета(ВложенныйПакет, ВыбраннаяТаблица = Неопределено, ИмяТаблицы = "")
	
	Если ВыбраннаяТаблица = Неопределено Тогда
		ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
	КонецЕсли; 
	Если ЗначениеЗаполнено(ИмяТаблицы) Тогда
		ВыбраннаяТаблица.Имя = ИмяТаблицы;
	КонецЕсли; 
	//ИмяТаблицы = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, "ВложенныйЗапрос",,, "ВложенныйПакет");
	ВыбраннаяТаблица.ВложенныйПакет = ВложенныйПакет;
	ВыбраннаяТаблица.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, ВыбраннаяТаблица,,, "ВложенныйЗапрос");
	ВыбраннаяТаблица.Обязательная = Истина;
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
	ОбновитьКомпоновщикЧастиОбъединения();
	НайтиДобавитьВыбраннуюТаблицуВСвязи(ВыбраннаяТаблица);
	ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока = ВыбраннаяТаблица;

КонецПроцедуры

Процедура ВыбранныеПоляПриАктивизацииСтроки(Элемент)
	
	СохранитьВыбранноеПоле();
	ЗагрузитьВыбранноеПоле();

КонецПроцедуры

Процедура ВыбранныеПоляОбновитьКнопки()
	
	ЭлементыФормы.КПВыбранныеПоля.Кнопки.ОтключитьРежимАвтополе.Доступность = Истина
		И ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока <> Неопределено
		И ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Автополе;
	ЭлементыФормы.КПВыбранныеПоля.Кнопки.ОтключитьРежимАвтополе.Пометка = ЭлементыФормы.КПВыбранныеПоля.Кнопки.ОтключитьРежимАвтополе.Доступность;
	
КонецПроцедуры

Процедура ЗагрузитьВыбранноеПоле()

	мТекущаяСтрокаВыбранногоПоля = ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока;
	Если мТекущаяСтрокаВыбранногоПоля <> Неопределено Тогда
		Если мТекущаяСтрокаВыбранногоПоля.Токен = Неопределено Тогда
			ПриИзмененииВыраженияВыбранногоПоля();
		КонецЕсли; 
		ВыражениеПоля = мТекущаяСтрокаВыбранногоПоля.Определение;
		РазрешеноИзменение = Не мТекущаяСтрокаВыбранногоПоля.Автополе;
	Иначе
		ВыражениеПоля = "";
		РазрешеноИзменение = Ложь;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(ВыражениеПоля);
	ЭлементыФормы.ВыражениеВыбранногоПоля.Доступность = РазрешеноИзменение;

КонецПроцедуры

Процедура ВыбранныеПоляПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ОформлениеСтроки.Ячейки.Группировка.ОтображатьФлажок = Истина;
	СтрокаГруппировки = Группировки.Найти(ДанныеСтроки.Определение, "Определение");
	Если СтрокаГруппировки <> Неопределено Тогда
		ОформлениеСтроки.Ячейки.Группировка.Флажок = Истина;
		ОформлениеСтроки.Ячейки.Группировка.ТолькоПросмотр = Ложь
			Или ДанныеСтроки.ЕстьАгрегаты
			Или ДанныеСтроки.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"));
	КонецЕсли;
	Если ДанныеСтроки.Автополе Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаВычисляемогоЗначения");
	КонецЕсли; 
	ОформлениеСтроки.Ячейки.АгрегатнаяФункция.ТолькоПросмотр = Ложь
		Или ДанныеСтроки.Токен = Неопределено 
		Или ДанныеСтроки.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
		Или (Истина
			И ДанныеСтроки.ЕстьАгрегаты
			И ДанныеСтроки.АгрегатнаяФункция = "");
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	ВыбранныеПоляОбновитьКнопки();
	ирОбщий.ТабличноеПолеПриВыводеСтрокиЛкс(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Функция ПолучитьИндексКартинкиВыражения(ВыражениеИлиТокен, ЧастьОбъединения = Неопределено)
	
	ТипЗначения = ПолучитьТипЗначенияВыражения(ВыражениеИлиТокен, ЧастьОбъединения);
	ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаЛкс(ТипЗначения);
	Возврат ИндексКартинки;
	
КонецФункции

Функция ПолучитьТипЗначенияВыражения(ВыражениеИлиТокен, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ТипЗнч(ВыражениеИлиТокен) = Тип("Строка") Тогда
		Токен = РазобратьВыражениеЗапроса(ВыражениеИлиТокен);
	Иначе
		Токен = ВыражениеИлиТокен;
	КонецЕсли; 
	Если ТипЗнч(Токен) = Тип("COMОбъект") Тогда
		Если Токен.Kind = 0 Тогда
			ДанныеТокена = Токен.Data;
			ИмяПравила = ДанныеТокена.RuleText();
			Если ИмяПравила = "<Field>" Тогда
				//ПолноеИмяПоля = ПолучитьТекстИзТокена(Токен);
				ПолноеИмяПоля = СобратьВыражениеЗапроса(Токен,,, ЧастьОбъединения);;
				//ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ПолноеИмяПоля);
				//ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолеКомпоновки); // Так очень долго работает особенно для дочерних полей от многотипных полей
				Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмяПоля);
				Если Фрагменты.Количество() = 2 Тогда // Это приемлемая плата за вспомогательную информацию, которой являются типы значений полей
													  // Если убрать это ограничение, то здесь будут большие задержки
					ДоступноеПолеТаблицы = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы.Найти(Фрагменты[0]);
					Если ДоступноеПолеТаблицы <> Неопределено Тогда
						ДоступноеПоле = ДоступноеПолеТаблицы.Элементы.Найти(ПолноеИмяПоля);
						Если ДоступноеПоле <> Неопределено Тогда
							Результат = ДоступноеПоле.ТипЗначения;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			ИначеЕсли ИмяПравила = "<Parameter>" Тогда
				//ИмяПараметра = ДанныеТокена.Tokens(1).Data.Tokens(0).Data;
				//ПолеКомпоновки = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Результат);
				//ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолноеИмяПоля);
				//Если ДоступноеПоле <> Неопределено Тогда
				//	Результат = ДоступноеПоле.ТипЗначение;
				//КонецЕсли; 
			ИначеЕсли Ложь
				Или ИмяПравила = "<Datetime>"
				Или ИмяПравила = "<DateAdd>"
				Или ИмяПравила = "<BeginOfPeriod>"
				Или ИмяПравила = "<EndOfPeriod>"
			Тогда
				Результат = Новый ОписаниеТипов("Дата");
			ИначеЕсли Ложь
				Или ИмяПравила = "<Substring>"
			Тогда
				Результат = Новый ОписаниеТипов("Строка");
			ИначеЕсли Ложь
				Или ИмяПравила = "<DateDiff>"
				Или ИмяПравила = "<Count>"
			Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли ИмяПравила = "<Cast>" Тогда
				Результат = ПолучитьТипФункцииCast(ДанныеТокена.Tokens(4), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<Type>"
				Или ИмяПравила = "<ValueType>"
			Тогда
				Результат = Новый ОписаниеТипов("Тип");
			ИначеЕсли ИмяПравила = "<Meaning>" Тогда
				ПолноеИмяПредопределенного = СобратьВыражениеЗапроса(ДанныеТокена.Tokens(2));
				Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмяПредопределенного);
				Фрагменты.Удалить(Фрагменты.ВГраница());
				ИмяСсылочногоТипа = ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(Фрагменты, ".");
				Если Фрагменты.Количество() = 2 Тогда
					ИмяСсылочногоТипа = ирОбщий.ИмяТипаИзПолногоИмениТаблицыБДЛкс(ИмяСсылочногоТипа);
				КонецЕсли; 
				Попытка
					Результат = Новый ОписаниеТипов(ИмяСсылочногоТипа);
				Исключение
				КонецПопытки; 
			// Далее идут правила, допускающие напрямую вложенные правила
			ИначеЕсли ДанныеТокена.TokenCount = 1 Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(0), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<AddExpr>" 
			Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(0), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<MultExpr>" 
			Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли Ложь
				Или ИмяПравила = "<NotExpr>" 
				Или ИмяПравила = "<AndExpr>" 
				Или ИмяПравила = "<OrExpr>" 
				Или ИмяПравила = "<CheckNULL>" 
				Или ИмяПравила = "<CheckNotNULL>" 
				Или ИмяПравила = "<CheckLIKE>" 
				Или ИмяПравила = "<CheckValueIn>" 
				Или ИмяПравила = "<CheckExpr>" 
			Тогда
				Результат = Новый ОписаниеТипов("Булево");
			ИначеЕсли ИмяПравила = "<Brackets>" Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(1), ЧастьОбъединения);
			ИначеЕсли ИмяПравила = "<Agregate>" Тогда
				лИмяТокена = ДанныеТокена.Tokens(0).Name;
				Если Ложь
					Или лИмяТокена = "MAX"
					Или лИмяТокена = "MIN"
				Тогда
					Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(2), ЧастьОбъединения);
				ИначеЕсли Ложь
					Или лИмяТокена = "AVG"
					Или лИмяТокена = "SUM"
				Тогда
					Результат = Новый ОписаниеТипов("Число");
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			ИмяТокена = Токен.Name;
			Если ирОбщий.СтрокиРавныЛкс(ИмяТокена, "numLiteral") Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "strLiteral") Тогда
				Результат = Новый ОписаниеТипов("Строка");
			ИначеЕсли Ложь
				Или ирОбщий.СтрокиРавныЛкс(ИмяТокена, "TRUE")
				Или ирОбщий.СтрокиРавныЛкс(ИмяТокена, "FALSE")
			Тогда
				Результат = Новый ОписаниеТипов("Булево");
			ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "NULL") Тогда
				Результат = Новый ОписаниеТипов("Null");
			Иначе
				Результат = Новый ОписаниеТипов();
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Если Результат = Неопределено Тогда
		Результат = Новый ОписаниеТипов();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПолучитьТипФункцииCast(ТокенТипа, ЧастьОбъединения)

	ПервыйТокен = ТокенТипа.Data.Tokens(0);
	Если Истина
		И ПервыйТокен.Kind = 1
		И ПервыйТокен.Data = "(" 
	Тогда
		Результат = ПолучитьТипФункцииCast(ТокенТипа.Data.Tokens(1), ЧастьОбъединения);
	ИначеЕсли ПервыйТокен.Kind = 1 Тогда
		Результат = Новый ОписаниеТипов(ПервыйТокен.Data);
	Иначе
		ИмяПравилаТипа = ПервыйТокен.Data.RuleText();
		Если ИмяПравилаТипа = "<NumericType>" Тогда
			Результат = Новый ОписаниеТипов("Число");
		ИначеЕсли ИмяПравилаТипа = "<StringType>" Тогда
			Результат = Новый ОписаниеТипов("Строка");
		ИначеЕсли ИмяПравилаТипа = "<TableName>" Тогда
			ИмяСсылочногоТипа = СобратьВыражениеЗапроса(ПервыйТокен);
			ИмяСсылочногоТипа = ирОбщий.ИмяТипаИзПолногоИмениТаблицыБДЛкс(ИмяСсылочногоТипа);
			Попытка
				Результат = Новый ОписаниеТипов(ИмяСсылочногоТипа);
			Исключение
			КонецПопытки; 
		ИначеЕсли ИмяПравилаТипа = "<Brackets>" Тогда
		ИначеЕсли ИмяПравилаТипа = "<BinaryType>" Тогда
		Иначе
			ВызватьИсключение "Неизвестный тип " + ИмяПравилаТипа + " в функции CAST";
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(Токен, ЗапросПакета, ЧастьОбъединения)
	
	//Результат = СобратьВыражениеЗапроса(ДанныеТокена);
	ДанныеТокена = Токен.Data;
	Если Токен.Kind = 0 Тогда
		ИмяПравила = ДанныеТокена.RuleText();
		Если ИмяПравила = "<Field>" Тогда
			//Результат = ПолучитьТекстИзТокена(Токен);
			Результат = СобратьВыражениеЗапроса(Токен,,, ЧастьОбъединения);
			Если Найти(Результат, "(") > 0 Тогда
				Возврат Неопределено;
			КонецЕсли; 
			Результат = ПолучитьПолноеИмяПоляВВыражении(Результат, ЗапросПакета, ЧастьОбъединения);
			Результат = Новый ПолеКомпоновкиДанных(Результат);
			Возврат Результат;
		ИначеЕсли ИмяПравила = "<Parameter>" Тогда
			//Результат = ДанныеТокена.Tokens(1).Data.Tokens(0).Data;
			Результат = ДанныеТокена.Tokens(0).Data;
			ПроверитьДобавитьПараметр(Результат);
			Результат = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Результат);
			Возврат Результат;
		ИначеЕсли ИмяПравила = "<Datetime>" Тогда
			Год = ДанныеТокена.Tokens(2).Data;
			Месяц = ДанныеТокена.Tokens(4).Data;
			День = ДанныеТокена.Tokens(6).Data;
			Если ДанныеТокена.TokenCount > 8 Тогда
				Час = ДанныеТокена.Tokens(8).Data;
				Минута = ДанныеТокена.Tokens(10).Data;
				Секунда = ДанныеТокена.Tokens(12).Data;
			Иначе
				Час = 0;
				Минута = 0;
				Секунда = 0;
			КонецЕсли; 
			Результат = Дата(Год, Месяц, День, Час, Минута, Секунда);
			Возврат Результат;
		КонецЕсли; 
	Иначе
		ИмяТокена = Токен.Name;
		Если ирОбщий.СтрокиРавныЛкс(ИмяТокена, "numLiteral") Тогда
			Попытка
				Результат = Вычислить(ДанныеТокена);
			Исключение
				// hex
				Результат = Неопределено;
			КонецПопытки; 
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "strLiteral") Тогда
			Результат = Токен.Data;
			ПозицияНачала = 2;
			Если Лев(Результат, 1) = "N" Тогда
				ПозицияНачала = ПозицияНачала + 1;
			КонецЕсли; 
			Результат = Сред(Результат, ПозицияНачала, СтрДлина(Результат) - ПозицияНачала);
			Результат = СтрЗаменить(Результат, """""", """");
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "TRUE") Тогда
			Результат = Истина;
		ИначеЕсли ирОбщий.СтрокиРавныЛкс(ИмяТокена, "FALSE") Тогда
			Результат = Ложь;
		КонецЕсли; 
		Возврат Результат;
	КонецЕсли; 
	Если ДанныеТокена.TokenCount = 1 Тогда
		Результат = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(ДанныеТокена.Tokens(0), ЗапросПакета, ЧастьОбъединения);
	Иначе
		Результат = Неопределено;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПриИзмененииФлажка(Элемент, Колонка)
	
	Если ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка = Колонка Тогда
		СтрокаГруппировки = Группировки.Найти(ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Определение, "Определение");
		Если СтрокаГруппировки <> Неопределено Тогда
			Группировки.Удалить(СтрокаГруппировки);
		Иначе
			СтрокаГруппировки = Группировки.Добавить();
			СтрокаГруппировки.Определение = ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Определение;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		НовоеИмяПараметра = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,, ПолучитьСловоЯзыкаЗапросов("Parameter") + "1");
		Элемент.ТекущиеДанные.Имя = НовоеИмяПараметра;
		Элемент.ТекущиеДанные.НИмя = НРег(НовоеИмяПараметра);
		Если мТекущееИмяПараметра <> НовоеИмяПараметра Тогда
			ПереименоватьТаблицуИлиПараметр(, ПараметрыДиалектаSQL.ПрефиксПараметра + мТекущееИмяПараметра, ПараметрыДиалектаSQL.ПрефиксПараметра + НовоеИмяПараметра);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеВыбранныеПоляПорядкаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	//СтрокаПорядка = ПоляПорядка.Найти(ВыбраннаяСтрока.Имя, "Определение");
	//Если СтрокаПорядка = Неопределено Тогда
	//	СтрокаПорядка = ПоляПорядка.Добавить();
	//	СтрокаПорядка.Определение = ВыбраннаяСтрока.Имя;
	//	ОбновитьВыражениеЗапроса(СтрокаПорядка,,,,,,,, Ложь);
	//КонецЕсли; 
	//ЭлементыФормы.ПоляПорядка.ТекущаяСтрока = СтрокаПорядка;
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядка);
	
КонецПроцедуры

Процедура ДоступныеПоляПорядкаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	//ПолноеИмяПоля = ПолучитьПолноеИмяДоступногоПоля(ВыбраннаяСтрока);
	//Если ПолноеИмяПоля = Неопределено Тогда
	//	Возврат;
	//КонецЕсли; 
	//СтрокаПорядка = ПоляПорядка.Найти(ПолноеИмяПоля, "Определение");
	//Если СтрокаПорядка = Неопределено Тогда
	//	СтрокаПорядка = ПоляПорядка.Добавить();
	//	СтрокаПорядка.Определение = ПолноеИмяПоля;
	//	ОбновитьВыражениеЗапроса(СтрокаПорядка,,,,,,,, Ложь);
	//КонецЕсли; 
	//ЭлементыФормы.ПоляПорядка.ТекущаяСтрока = СтрокаПорядка;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядка);
	
КонецПроцедуры

Процедура ПорядокВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.ПоляПорядка.Колонки.Направление Тогда
		Если ВыбраннаяСтрока.Направление = НаправлениеСортировки.Убыв Тогда
			ВыбраннаяСтрока.Направление = НаправлениеСортировки.Возр;
		Иначе
			ВыбраннаяСтрока.Направление = НаправлениеСортировки.Убыв;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Функция ЭтоПолеПараметра(Поле) 
	
	НрегПервыйФрагмент = ирОбщий.ПолучитьПервыйФрагментЛкс(НРег(Поле));
	Результат = Ложь
		Или НрегПервыйФрагмент = НРег("ПараметрыДанных")
		Или НрегПервыйФрагмент = НРег("DataParameters")
		;
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПолноеИмяДоступногоПоля(ДоступноеПоле)
	
	Если ЭтоПолеПараметра(ДоступноеПоле.Поле) Тогда
		Результат = ПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПолучитьПоследнийФрагментЛкс(ДоступноеПоле.Поле);
	Иначе
		Результат = "" + ДоступноеПоле.Поле;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура УсловияПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если НоваяСтрока Тогда
		Элемент.ТекущиеДанные.Сравнение = "=";
		Элемент.ТекущиеДанные.ЛевоеВыражение = 1;
		Элемент.ТекущиеДанные.ПравоеВыражение = 1;
		//СвязиТаблицПриАктивизацииСтроки();
	КонецЕсли; 

КонецПроцедуры

Процедура ПередЗакрытием(Отказ, СтандартнаяОбработка)
	
	Если Модифицированность Тогда
		Ответ = Вопрос("Хотите сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			ОсновныеДействияФормыОК();
		ИначеЕсли Ответ = КодВозвратаДиалога.Отмена Тогда
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли; 
	Если Не Отказ Тогда
		ИзменитьСвернутостьПанельЧастей(Истина);
		ИзменитьСвернутостьПанельПакета(Истина);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ИзменитьСвернутостьПанельПакета(Видимость)
	
	ирОбщий.ИзменитьСвернутостьЛкс(Видимость, ЭлементыФормы.ПанельПакета, ЭлементыФормы.вРазделительПанельПакета, Панель, "лево");
	
КонецПроцедуры

Процедура ИзменитьСвернутостьПанельЧастей(Видимость)
	
	ирОбщий.ИзменитьСвернутостьЛкс(Видимость, ЭлементыФормы.ПанельЧастей, ЭлементыФормы.вРазделительПанельЧастей, ЭлементыФормы.ПанельОсновная, "лево");
	
КонецПроцедуры

Процедура ДоступныеТаблицыПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	ПоляДоступнойТаблицы.Очистить();
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(ПолучитьПоляДоступнойТаблицы(ТекущаяСтрока), ПоляДоступнойТаблицы);
	ПоляДоступнойТаблицы.Сортировать("Имя");
	
КонецПроцедуры

Процедура ОткрытьОтладчик(Кнопка)
	
	ВызватьИсключение ирОбщий.ПолучитьПриглашениеОткрытьОтладчикЛкс();
	
КонецПроцедуры

Процедура ДеревоУсловияПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки <> Элемент.Значение Тогда
		ЭтоПроизвольноеУсловие = ДанныеСтроки.Представление <> "";
		ОформлениеСтроки.Ячейки.Произвольное.ОтображатьФлажок = Не ЭтоПроизвольноеУсловие И ТипЗнч(ДанныеСтроки) = Тип("ЭлементОтбораКомпоновкиДанных");
		ОформлениеСтроки.Ячейки.Произвольное.Флажок = ЭтоПроизвольноеУсловие;
		Если ЭтоПроизвольноеУсловие Тогда
			ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДеревоУсловияПриИзмененииФлажка(Элемент, Колонка)
	
	Если Элемент.Колонки.Произвольное = Колонка Тогда
		ПереключитьРежимПроизвольногоВыраженияОтбора(Элемент, Колонка);
		ЗагрузитьВыражениеУсловия();
	КонецЕсли; 

КонецПроцедуры

Процедура ПриПолученииДанныхДоступныхПолей(Элемент, ОформленияСтрок)

	ирОбщий.ПриПолученииДанныхДоступныхПолейКомпоновкиЛкс(ОформленияСтрок);

КонецПроцедуры // ПриПолученииДанныхДоступныхПолей()

Процедура УсловияПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		ОбновитьЭлементОтбораПослеИзменения(Элемент);
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		Если НоваяСтрока Тогда
			мТекущаяСтрокаВыбранногоПоля.ИД = Новый УникальныйИдентификатор();
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОчиститьДанные() Экспорт
	
	ЗапросыПакета.Очистить();
	ЧастиОбъединения.Очистить();
	ВыбранныеПоля.Очистить();
	ПоляПорядка.Очистить();
	Группировки.Очистить();
	ПринимающиеПоля.Очистить();
	СвязиТаблиц.Строки.Очистить();
	Параметры.Очистить();
	ЭтаФорма.ОпцияПервые = Неопределено;
	ЭтаФорма.ОпцияРазличные = Неопределено;
	ЭтаФорма.ОпцияАвтоупорядочивание = Неопределено;
	ЭтаФорма.ОпцияРазрешенные = Неопределено;
	ЭтаФорма.РежимОбъединения = Ложь;
	ЭтаФорма.ЛиПакетныйЗапрос = Ложь;
	ЭтаФорма.ТипЗапроса = 0;
	КомпоновщикЧасти.Настройки.Отбор.Элементы.Очистить();
	
КонецПроцедуры

Процедура ПереключитьРежимРедактированияТекста()
	
	ЭтаФорма.мРежимРедактированияТекста = Не мРежимРедактированияТекста;
	ЭлементыФормы.ПолеТекстаОтображаетПакет.Доступность = Не мРежимРедактированияТекста;
	ЭлементыФормы.КПТекст.Кнопки.Редактировать.Пометка = мРежимРедактированияТекста;
	ЭлементыФормы.КПТекст.Кнопки.ОтменитьРедактирование.Доступность = мРежимРедактированияТекста;
	ЭлементыФормы.ПолеТекстаЗапроса.ТолькоПросмотр = Не мРежимРедактированияТекста;
	Для Каждого Страница Из ЭлементыФормы.ПанельОсновная.Страницы Цикл
		Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> Страница Тогда
			Страница.Доступность = Не мРежимРедактированияТекста;
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры

Процедура КПТекстРедактировать(Кнопка = Неопределено)

	Если мРежимРедактированияТекста Тогда
		Компонента = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ЭлементыФормы.ПолеТекстаЗапроса.Имя];
		Если Компонента.ЗагрузитьТекстВКонструктор(, ЭтаФорма) = Истина Тогда
			ПереключитьРежимРедактированияТекста();
		КонецЕсли; 
	Иначе
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДиалектSQLОчистка(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ЭтаФорма.ДиалектSQL = мДиалектSQL;
	
КонецПроцедуры

Процедура ОбновитьВсеВыраженияСИндикацией()
	
	Состояние("Обновление выражений...");
	ОбновитьВсеВыраженияПакета();
	Состояние("");
	
КонецПроцедуры

// Параметры:
//   РежимОбновленияВыражений - Число
//		1 - пересобрать
//		2 - очистить токен
Функция ОбновитьВсеВыраженияПакета(Пакет = Неопределено, РежимОбновленияВыражений = 1)

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли;
	Для Каждого ЗапросПакета Из Пакет Цикл
		ОбновитьВсеВыраженияЗапроса(ЗапросПакета, РежимОбновленияВыражений);
	КонецЦикла;
	Возврат Неопределено;

КонецФункции

Процедура ОбновитьВсеВыраженияЗапроса(Знач ЗапросПакета, Знач РежимОбновленияВыражений = 1)
	
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		ОбновитьВсеВыраженияЧастиОбъединения(ЗапросПакета, ЧастьОбъединения, РежимОбновленияВыражений);
	КонецЦикла;
	Для Каждого ПолеПорядка Из ЗапросПакета.ПоляПорядка Цикл
		ОбновитьВыражениеЗапроса(ПолеПорядка, ЭлементыФормы.ПоляПорядка, ЗапросПакета,,,,,,, РежимОбновленияВыражений);
	КонецЦикла;
	Для Каждого ГруппируемоеПолеИтогов Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		ОбновитьВыражениеЗапроса(ГруппируемоеПолеИтогов, ЭлементыФормы.ГруппируемыеПоляИтогов, ЗапросПакета,,,,,,, РежимОбновленияВыражений);
	КонецЦикла;
	Для Каждого ГруппирующееПолеИтогов Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		ОбновитьВыражениеЗапроса(ГруппирующееПолеИтогов, ЭлементыФормы.ГруппирующиеПоляИтогов, ЗапросПакета,,,,,,, РежимОбновленияВыражений);
	КонецЦикла;
	Если ТипЗапроса <> 3 Или Не ЗначенияИзВыборки Тогда
		Для Каждого ПринимающееПоле Из ЗапросПакета.ПринимающиеПоля Цикл
			ОбновитьВыражениеЗапроса(ПринимающееПоле, ЭлементыФормы.ПринимающиеПоля, ЗапросПакета,,,,,,, РежимОбновленияВыражений);
		КонецЦикла;
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьВсеВыраженияЧастиОбъединения(Знач ЗапросПакета, Знач ЧастьОбъединения, Знач РежимОбновленияВыражений = 1)
	
	Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		Если ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
			ОбновитьВсеВыраженияПакета(ВыбраннаяТаблица.ВложенныйПакет, РежимОбновленияВыражений);
		КонецЕсли; 
		Для каждого ПараметрТаблицы Из ВыбраннаяТаблица.Параметры Цикл
			Если Не ЗначениеЗаполнено(ПараметрТаблицы.Определение) Тогда
				Продолжить;
			КонецЕсли; 
			ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, ЗапросПакета, ЧастьОбъединения,,,,,, РежимОбновленияВыражений);
		КонецЦикла;
	КонецЦикла;
	Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
		ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, ЗапросПакета, ЧастьОбъединения,,,,,, РежимОбновленияВыражений);
	КонецЦикла;
	Для Каждого ПолеГруппировки Из ЧастьОбъединения.Группировки Цикл
		ОбновитьВыражениеЗапроса(ПолеГруппировки, ЭлементыФормы.Группировки, ЗапросПакета, ЧастьОбъединения,,,,,, РежимОбновленияВыражений);
	КонецЦикла;
	Для Каждого СвязьТаблиц Из ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(ЧастьОбъединения.СвязиТаблиц) Цикл
		Если СвязьТаблиц.Условие <> Неопределено Тогда
			ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи, ЗапросПакета, ЧастьОбъединения,,, РежимОбновленияВыражений);
		КонецЕсли; 
	КонецЦикла;
	//ОбновитьВыраженияОтбора(ЧастьОбъединения.Условие.Отбор, ЭлементыФормы.ДеревоУсловия, ЗапросПакета, ЧастьОбъединения,,, РежимОбновленияВыражений);
	ОбновитьВыраженияОтбора(ЧастьОбъединения.Компоновщик.Настройки.Отбор, ЭлементыФормы.ДеревоУсловия, ЗапросПакета, ЧастьОбъединения,,, РежимОбновленияВыражений);

КонецПроцедуры

// РежимОбновленияВыражений - Число
//		1 - пересобрать
//		2 - очистить токен
Процедура ОбновитьВыраженияОтбора(ГруппаОтбора, ТабличноеПоле = Неопределено,
	Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено, СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", Знач РежимОбновленияВыражений = 1)
	
	Если РежимОбновленияВыражений < 2 Тогда
		Если ЗначениеЗаполнено(НовоеИмяТаблицы) Тогда
			РежимОбновленияВыражений = 0;
		Иначе
			РежимОбновленияВыражений = 1;
		КонецЕсли; 
	КонецЕсли; 
	Для Каждого ЭлементГруппы Из ГруппаОтбора.Элементы Цикл
		Если ТипЗнч(ЭлементГруппы) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ОбновитьВыраженияОтбора(ЭлементГруппы, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, РежимОбновленияВыражений);
		Иначе
			Попытка
				Если ЭлементГруппы.Представление <> "" Тогда
					ОбновитьВыражениеЗапроса(ЭлементГруппы, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы,,,, РежимОбновленияВыражений);
				Иначе
					Если ТипЗнч(ЭлементГруппы.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
						Если ЭтоПолеПараметра(ЭлементГруппы.ЛевоеЗначение) Тогда
							ВыражениеПараметра = ПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПолучитьПоследнийФрагментЛкс(ЭлементГруппы.ЛевоеЗначение);
							Если ирОбщий.СтрокиРавныЛкс(ВыражениеПараметра, СтароеИмяТаблицы) Тогда
								ЭлементГруппы.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Сред(НовоеИмяТаблицы, 2));
							КонецЕсли; 
						Иначе
							ЭлементГруппы.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(
								ПолучитьПолноеИмяПоляВВыражении("" + ЭлементГруппы.ЛевоеЗначение, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы));
						КонецЕсли; 
					КонецЕсли; 
					Если ТипЗнч(ЭлементГруппы.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
						Если ЭтоПолеПараметра(ЭлементГруппы.ПравоеЗначение) Тогда
							ВыражениеПараметра = ПараметрыДиалектаSQL.ПрефиксПараметра + ирОбщий.ПолучитьПоследнийФрагментЛкс(ЭлементГруппы.ПравоеЗначение);
							Если ирОбщий.СтрокиРавныЛкс(ВыражениеПараметра, СтароеИмяТаблицы) Тогда
								ЭлементГруппы.ПравоеЗначение = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Сред(НовоеИмяТаблицы, 2));
							КонецЕсли; 
						Иначе
							ЭлементГруппы.ПравоеЗначение = Новый ПолеКомпоновкиДанных(
								ПолучитьПолноеИмяПоляВВыражении("" + ЭлементГруппы.ПравоеЗначение, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы));
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			Исключение
				АктивизироватьТабличноеПоле(ТабличноеПоле);
				ТабличноеПоле.ТекущаяСтрока = ЭлементГруппы;
				ВызватьИсключение;
			КонецПопытки; 
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьИмяВыбраннойТаблицы(СтрокаВыбраннойТаблицы = Неопределено)

	Если СтрокаВыбраннойТаблицы  = Неопределено Тогда
		СтрокаВыбраннойТаблицы = мТекущаяСтрокаВыбранныеТаблицы;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.Имя) Тогда
		СтрокаВыбраннойТаблицы.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(СтрокаВыбраннойТаблицы.Владелец(), СтрокаВыбраннойТаблицы.ПолноеИмя);
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбраннойТаблицы);
	КонецЕсли;
	Результат = СтрокаВыбраннойТаблицы.Имя;
	Возврат Результат;

КонецФункции

Функция _ПолучитьТекстОператораТокена(Данные, НачальныйИндекс, КонечныйИндекс)

	ТекстОператора = "";
	Для Индекс = НачальныйИндекс По КонечныйИндекс Цикл
		Если ТекстОператора <> "" Тогда
			ТекстОператора = ТекстОператора + " " + ТекстОператора;
		КонецЕсли; 
		ИмяТерминала = Данные.Tokens(Индекс).ParentRule.RuleNonterminal.Name;
		ТекстОператора = ТекстОператора + " " + ПолучитьСловоЯзыкаЗапросов(ИмяТерминала);
	КонецЦикла;

	Возврат Неопределено;

КонецФункции

// РежимОбновленияВыражения - Число
//      0 - собрать из готового токена
//		1 - сформировать токен заново и собрать из него 
//		2 - очистить токен
Функция ОбновитьВыражениеЗапроса(СтрокаТаблицыВыражений, ТабличноеПоле = Неопределено, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено,
	СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", РазрешитьПустое = Ложь, выхЕстьАгрегаты = Ложь, РазрешитьНормализациюИмен = Истина, РежимОбновленияВыражений = 1)

	НачальныйТокенВыражения = Неопределено;
	Если ТипЗнч(СтрокаТаблицыВыражений) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ВыражениеЗапроса = СтрокаТаблицыВыражений.Представление;
		Если РежимОбновленияВыражений = 0 Тогда
			НачальныйТокенВыражения = СтрокаТаблицыВыражений.ПравоеЗначение;
		КонецЕсли; 
	Иначе
		ВыражениеЗапроса = СтрокаТаблицыВыражений.Определение;
		Если РежимОбновленияВыражений = 0 Тогда
			НачальныйТокенВыражения = СтрокаТаблицыВыражений.Токен;
		КонецЕсли; 
	КонецЕсли;
	Если РежимОбновленияВыражений = 2 Тогда
		Результат = ВыражениеЗапроса;
	ИначеЕсли Ложь
		Или (Истина
			И РазрешитьПустое 
			И ПустаяСтрока(ВыражениеЗапроса))
		Или (Истина
			И Не ЗначениеЗаполнено(НовоеИмяТаблицы)
			И ЛиВыражениеЯвляетсяПолем(ВыражениеЗапроса))
	Тогда
		Результат = ВыражениеЗапроса;
		НачальныйТокенВыражения = ВыражениеЗапроса;
	Иначе
		Если ЗапросПакета = Неопределено Тогда
			ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
		КонецЕсли; 
		Если ЧастьОбъединения = Неопределено Тогда
			ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
		КонецЕсли; 
		НужноПересобратьТокены = Неопределено;
		Попытка
			Если ТипЗнч(НачальныйТокенВыражения) <> Тип("COMОбъект") Тогда
				НачальныйТокенВыражения = РазобратьВыражениеЗапроса(ВыражениеЗапроса, ТабличноеПоле = Неопределено);
			КонецЕсли; 
			Результат = СобратьВыражениеЗапроса(НачальныйТокенВыражения, , ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен,
				НужноПересобратьТокены);
		Исключение
			Если ТабличноеПоле <> Неопределено Тогда
				АктивизироватьТабличноеПоле(ТабличноеПоле);
				ТабличноеПоле.ТекущаяСтрока = СтрокаТаблицыВыражений;
				ВызватьИсключение;
			КонецЕсли;
			Возврат Неопределено;
		КонецПопытки; 
		Если НужноПересобратьТокены Тогда
			//НачальныйТокенВыражения = Неопределено;
			НачальныйТокенВыражения = РазобратьВыражениеЗапроса(Результат, ТабличноеПоле = Неопределено);
		КонецЕсли; 
	КонецЕсли; 
	Если ТипЗнч(СтрокаТаблицыВыражений) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ОбновитьЭлементОтбораПроизвольногоВыражения(выхЕстьАгрегаты, Результат, НачальныйТокенВыражения, СтрокаТаблицыВыражений);
	Иначе
		СтрокаТаблицыВыражений.Определение = Результат;
		Попытка
			СтрокаТаблицыВыражений.Токен = НачальныйТокенВыражения;
		Исключение
			// При выборе поля на закладке Индексы
		КонецПопытки;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура АктивизироватьТабличноеПоле(Знач ТабличноеПоле)
	
	// Антибаг платформы 8.3.12+ Не выполняется установка текущим элемента обычной формы на неактивной странице https://partners.v8.1c.ru/forum/t/1757924/m/1757924
	Если ТабличноеПоле = ЭлементыФормы.ВыбранныеПоля Тогда
		ЭтаФорма.ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭтаФорма.ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеПоля
	ИначеЕсли ТабличноеПоле = ЭлементыФормы.ДеревоУсловия Тогда
		ЭтаФорма.ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭтаФорма.ЭлементыФормы.ПанельЧасти.Страницы.ДеревоУсловия;
	ИначеЕсли ТабличноеПоле = ЭлементыФормы.Группировки Тогда
		ЭтаФорма.ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭтаФорма.ЭлементыФормы.ПанельЧасти.Страницы.Группировки;
	КонецЕсли; 
	ЭтаФорма.ТекущийЭлемент = ТабличноеПоле;

КонецПроцедуры

Процедура ДиалектSQLПриИзменении(Элемент = Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	УстановитьДиалектSQL();
	ОбновитьВсеВыраженияСИндикацией();
	ПриИзмененииПараметровСборкиТекста();
	
КонецПроцедуры

Процедура ПриИзмененииПараметровСборкиТекста()
	
	Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Текст Тогда
		ПересобратьВременныйПолныйТекст();
	ИначеЕсли Истина
		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения 
		И ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Текст
	Тогда
		ПересобратьВременныйТекстЧасти();
	КонецЕсли;

КонецПроцедуры

Процедура УстановитьДиалектSQL(НовыйДиалектSQL = Неопределено, ИменованныеПараметры = Неопределено) Экспорт
	
	Если НовыйДиалектSQL <> Неопределено Тогда
		ЭтаФорма.ДиалектSQL = НовыйДиалектSQL;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ДиалектSQL) Тогда
		ЭтаФорма.ДиалектSQL = мДиалектSQL;
	КонецЕсли; 
	Если ДиалектSQL = Неопределено Тогда
		//ДиалектSQL = "MSSQL";
		ВызватьИсключение "Не указан диалект SQL";
	КонецЕсли; 
	ПараметрыДиалектаSQL = мДиалектыSQL.Найти(ДиалектSQL, "Диалект");
	Если ПараметрыДиалектаSQL = Неопределено Тогда
		Сообщить("Неизвестный диалект " + ДиалектSQL + " заменен на MSSQL");
		ПараметрыДиалектаSQL = мДиалектыSQL.Найти("MSSQL", "Диалект");
	КонецЕсли; 
	Если ИменованныеПараметры <> Неопределено Тогда
		ЭтаФорма.ИменованныеПараметры = ИменованныеПараметры;
	Иначе
		ЭтаФорма.ИменованныеПараметры = ПараметрыДиалектаSQL.ИменованныеПараметры;
	КонецЕсли; 
	Если НЕ ПараметрыДиалектаSQL.ВременныеТаблицы Тогда
		ЭтаФорма.ТипЗапроса = 0;
	КонецЕсли; 
	ЭлементыФормы.ПанельОсновная.Страницы.Итоги.Видимость = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.ПанельОсновная.Страницы.Параметры.Видимость = ПараметрыДиалектаSQL.Параметры;
	ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения.Видимость = ПараметрыДиалектаSQL.Объединения;
	ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц.Видимость = ПараметрыДиалектаSQL.МногоТаблиц;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Имя.Видимость = ПараметрыДиалектаSQL.МногоТаблиц;
	ЭлементыФормы.ПанельЧасти.Страницы.Группировки.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.ИзменятьНастройку = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.ИзменятьНастройку = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ТипЗапроса.Доступность = ПараметрыДиалектаSQL.ВременныеТаблицы;
	РазрешеныКомментарии = ЗначениеЗаполнено(ПараметрыДиалектаSQL.СтрочныйКомментарий);
	ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти.Видимость = РазрешеныКомментарии;
	ЭлементыФормы.ВыбранныеТаблицы.Колонки.Комментарий.Видимость = РазрешеныКомментарии;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Комментарий.Видимость = РазрешеныКомментарии;
	ЭлементыФормы.Группировки.Колонки.Комментарий.Видимость = РазрешеныКомментарии;
	ЭлементыФормы.ПоляИндекса.Колонки.Комментарий.Видимость = РазрешеныКомментарии;
	ЭлементыФормы.ГруппируемыеПоляИтогов.Колонки.Комментарий.Видимость = РазрешеныКомментарии;
	ЭлементыФормы.ГруппирующиеПоляИтогов.Колонки.Комментарий.Видимость = РазрешеныКомментарии;
	ЭлементыФормы.ОпцияАвтоупорядочивание.Доступность = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.Английский1С.Доступность = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.ВыбранныеТаблицы.Колонки.УровеньИзоляции.Видимость = ПараметрыДиалектаSQL.УровниИзоляции;
	ЭлементыФормы.УровеньИзоляции.Видимость = ПараметрыДиалектаSQL.УровниИзоляции;
	ЭлементыФормы.ВыбранныеТаблицы.Колонки.ДляИзменения.Видимость = Не ПараметрыДиалектаSQL.УровниИзоляции;
	ЭлементыФормы.ДляИзменения.Видимость = Не ПараметрыДиалектаSQL.УровниИзоляции;
	ЭлементыФормы.ВыбранныеТаблицы.Колонки.Обязательная.Видимость = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.ВыбранныеТаблицы.Колонки.НомерГруппы.Видимость = ПараметрыДиалектаSQL.Это1С;
	
	АгрегатныеФункции = Новый СписокЗначений();
	АгрегатныеФункции.Добавить("SUM(", ПолучитьСловоЯзыкаЗапросов("SUM"));
	АгрегатныеФункции.Добавить("MAX(", ПолучитьСловоЯзыкаЗапросов("MAX"));
	АгрегатныеФункции.Добавить("MIN(", ПолучитьСловоЯзыкаЗапросов("MIN"));
	АгрегатныеФункции.Добавить("AVG(", ПолучитьСловоЯзыкаЗапросов("AVG"));
	АгрегатныеФункции.Добавить("COUNT(", ПолучитьСловоЯзыкаЗапросов("COUNT"));
	АгрегатныеФункции.Добавить("COUNT(DISTINCT ", ПолучитьСловоЯзыкаЗапросов("COUNT") + " " + ПолучитьСловоЯзыкаЗапросов("DISTINCT"));
	ПоляВвводаАгрегатныхФункций = Новый Массив();
	ПоляВвводаАгрегатныхФункций.Добавить(ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.ЭлементУправления);
	ПоляВвводаАгрегатныхФункций.Добавить(ЭлементыФормы.ГруппируемыеПоляИтогов.Колонки.АгрегатнаяФункция.ЭлементУправления);
	Для Каждого ПолеВвводаАгрегатнойФункции Из ПоляВвводаАгрегатныхФункций Цикл
		СписокВыбора = ПолеВвводаАгрегатнойФункции.СписокВыбора;
		СписокВыбора.Очистить();
		Для Каждого АгрегатнаяФункция Из АгрегатныеФункции Цикл
			СписокВыбора.Добавить(АгрегатнаяФункция.Значение, АгрегатнаяФункция.Представление);
		КонецЦикла;
	КонецЦикла;
	
	СписокВыбораТипаЗапроса = ЭлементыФормы.ТипЗапроса.СписокВыбора;
	СписокВыбораТипаЗапроса.Очистить();
	СписокВыбораТипаЗапроса.Добавить(0, "Выборка");
	СписокВыбораТипаЗапроса.Добавить(1, "Создание временной таблицы");
	СписокВыбораТипаЗапроса.Добавить(2, "Уничтожение временной таблицы");
	Если Не ПараметрыДиалектаSQL.Это1С Тогда
		СписокВыбораТипаЗапроса.Добавить(3, "Добавление данных");
		СписокВыбораТипаЗапроса.Добавить(4, "Изменение данных");
		СписокВыбораТипаЗапроса.Добавить(5, "Удаление данных");
		СписокВыбораТипаЗапроса.Добавить(6, "Очистка");
	КонецЕсли; 
		
КонецПроцедуры

Процедура ПересобратьВременныйПолныйТекст()
	
	Текст = СобратьПолныйТекст();
	ирОбщий.УстановитьТекстПоляСохраняяПозициюЛкс(ЭлементыФормы.ПолеТекстаЗапроса, Текст);

КонецПроцедуры

Процедура ПанельОсновнаяПриСменеСтраницы(Элемент = Неопределено, ТекущаяСтраница =  Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	Элемент = ЭлементыФормы.ПанельОсновная;
	ТекущаяСтраница = Элемент.Страницы.Индекс(Элемент.ТекущаяСтраница);
	Если ТипЗапроса <> 2 Тогда
		Если Ложь
			Или мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.Страницы.Параметры
			Или мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения
		Тогда
			ЗагрузитьДоступныеНастройкиКомпоновки();
		КонецЕсли; 
	КонецЕсли; 
	ПанельОсновнаяОбновитьТекущуюСтраницу();
	ЭтаФорма.мСтараяСтраницаПанелиОсновная = Элемент.Страницы[ТекущаяСтраница];
	
КонецПроцедуры

Процедура ПанельОсновнаяОбновитьТекущуюСтраницу()

	лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.ТекущаяСтраница;
	Если лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Текст Тогда
		ПересобратьВременныйПолныйТекст();
	//ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Итоги Тогда
	//	ЭтаФорма.ДоступныеПоляИтогов = ЧастиОбъединения[0].ВыбранныеПоля;
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения Тогда
		ОбновитьТабличноеПолеПоляОбъединения();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Построитель Тогда
		ЭтаФорма.ДоступныеВыбранныеПоляЗапроса = ПоляОбъединения.Скопировать();
		ДоступныеВыбранныеПоляЗапроса.Сортировать("Имя");
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьПоляОбъединенияЗапроса(ЗапросПакета = Неопределено)
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли;
	Если ЗапросПакета = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЗапросПакета.ПоляОбъединения.Очистить();
	Пока ЗапросПакета.ПоляОбъединения.Колонки.Количество() > мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей Цикл
		ЗапросПакета.ПоляОбъединения.Колонки.Удалить(мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей);
	КонецЦикла;
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		КолонкаЧастиИД = ЗапросПакета.ПоляОбъединения.Колонки.Добавить("_" + ЧастьОбъединения.Номер);
		КолонкаЧастиОпределение = ЗапросПакета.ПоляОбъединения.Колонки.Добавить("Определение" + ЧастьОбъединения.Номер);
		НачальноеКоличество = ЧастьОбъединения.ВыбранныеПоля.Количество(); 
		Для Счетчик = 1 По НачальноеКоличество Цикл
			ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[НачальноеКоличество - Счетчик];
			СтрокаПсевдонимаПоля = ЗапросПакета.ПоляОбъединения.Найти(ВыбранноеПоле.Имя, "Имя");
			Если СтрокаПсевдонимаПоля = Неопределено Тогда
				СтрокаПсевдонимаПоля = ЗапросПакета.ПоляОбъединения.Вставить(0);
				СтрокаПсевдонимаПоля.Имя = ВыбранноеПоле.Имя;
				ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПсевдонимаПоля);
			КонецЕсли; 
			СтрокаПсевдонимаПоля[КолонкаЧастиИД.Имя] = ВыбранноеПоле.ИД;
			СтрокаПсевдонимаПоля[КолонкаЧастиОпределение.Имя] = ВыбранноеПоле.Определение;
			//Если ирОбщий.СтрокиРавныЛкс(ВыбранноеПоле.Определение, "NULL") Тогда
			//	ЧастьОбъединения.ВыбранныеПоля.Удалить(ВыбранноеПоле);
			//КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	//ЗапросПакета.ПоляОбъединения.Сортировать("Имя"); // Лучше это делать вручную
	Для Каждого ПолеОбъединения Из ЗапросПакета.ПоляОбъединения Цикл
		ОбновитьТипЗначенияПоляОбъединения(ЗапросПакета, ПолеОбъединения);
	КонецЦикла;
	ОбновитьРолиИтогов(ЗапросПакета);
	
КонецПроцедуры

Функция ОбновитьТабличноеПолеПоляОбъединения()

	ОбновитьПоляОбъединенияЗапроса();
	Пока ЭлементыФормы.ПоляОбъединения.Колонки.Количество() > мЧислоСтатическихКолонокТППоляПсевдонимовПолей Цикл 
		ЭлементыФормы.ПоляОбъединения.Колонки.Удалить(мЧислоСтатическихКолонокТППоляПсевдонимовПолей);
	КонецЦикла;
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		КолонкаТП = ЭлементыФормы.ПоляОбъединения.Колонки.Добавить("Определение" + ЧастьОбъединения.Номер);
		КолонкаТП.ТекстШапки = ЧастьОбъединения.Имя;
		КолонкаТП.Данные = КолонкаТП.Имя;
		КолонкаТП.КартинкиСтрок = ирКэш.КартинкаПоИмениЛкс("ирТипыДоступныхПолейКомпоновки");
		КолонкаТП.ТолькоПросмотр = Истина;
	КонецЦикла;

КонецФункции

Процедура СвязиТаблицПриАктивизацииСтроки(Элемент = Неопределено)
	
	Элемент = ЭлементыФормы.СвязиТаблиц;
	СохранитьУсловиеСвязи();
	ЗагрузитьСвязьТаблицы();
	ЭлементыФормы.СвязиТаблиц.Колонки.ТипСвязи.ЭлементУправления.ТолькоПросмотр = Истина
		И Элемент.ТекущиеДанные <> Неопределено 
		И Элемент.ТекущиеДанные.Уровень() = 0;

КонецПроцедуры

Процедура ЗагрузитьСвязьТаблицы()
	
	Элемент = ЭлементыФормы.СвязиТаблиц;
	мТекущаяСтрокаСвязи = Элемент.ТекущаяСтрока;
	НоваяНастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	Если Истина
		И мТекущаяСтрокаСвязи <> Неопределено 
		И мТекущаяСтрокаСвязи.Родитель <> Неопределено
	Тогда
		Если мТекущаяСтрокаСвязи.Условие <> Неопределено Тогда
			НоваяНастройкаКомпоновки = мТекущаяСтрокаСвязи.Условие; 
		КонецЕсли; 
		Если НоваяНастройкаКомпоновки.Отбор.Элементы.Количество() = 0 Тогда
			ДоступныеПоляОтбора = КомпоновщикУсловияСвязи.Настройки.Отбор.ДоступныеПоляОтбора;
			ДоступноеПолеТаблицыРодителя = ДоступныеПоляОтбора.НайтиПоле(Новый ПолеКомпоновкиДанных(мТекущаяСтрокаСвязи.Родитель.Таблица));
			Если ДоступноеПолеТаблицыРодителя <> Неопределено Тогда
				ГруппаДоступныхПолей = ДоступныеПоляОтбора.НайтиПоле(Новый ПолеКомпоновкиДанных(мТекущаяСтрокаСвязи.Таблица));
				Если ГруппаДоступныхПолей <> Неопределено Тогда
					Для Каждого ДоступноеПолеЛевое Из ГруппаДоступныхПолей.Элементы Цикл
						Для Каждого ДоступноеПолеПравое Из ДоступноеПолеТаблицыРодителя.Элементы Цикл
							Если Истина
								И ирОбщий.ОписанияТиповПересекаютсяЛкс(ДоступноеПолеЛевое.ТипЗначения, ДоступноеПолеПравое.ТипЗначения, Истина)
								И (Ложь
									Или ирОбщий.ПолучитьПоследнийФрагментЛкс(ДоступноеПолеЛевое.Поле) = "Ссылка"
									Или ирОбщий.ПолучитьПоследнийФрагментЛкс(ДоступноеПолеПравое.Поле) = "Ссылка"
									Или ирОбщий.ПолучитьПоследнийФрагментЛкс(ДоступноеПолеЛевое.Поле) = ирОбщий.ПолучитьПоследнийФрагментЛкс(ДоступноеПолеПравое.Поле)
								)
							Тогда
								ЭлементОтбора = ирОбщий.НайтиДобавитьЭлементОтбораКомпоновкиЛкс(НоваяНастройкаКомпоновки, ДоступноеПолеЛевое.Поле, ДоступноеПолеПравое.Поле);
								ЭлементОтбора.Использование = Ложь;
							КонецЕсли; 
						КонецЦикла;
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли; 
	КомпоновщикУсловияСвязи.ЗагрузитьНастройки(НоваяНастройкаКомпоновки);
	Если КомпоновщикУсловияСвязи.Настройки.Отбор.Элементы.Количество() > 0 Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока = КомпоновщикУсловияСвязи.Настройки.Отбор.Элементы[0];
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДеревоУсловияПриАктивизацииСтроки(Элемент = Неопределено)
		
	СохранитьВыражениеУсловия();
	ЗагрузитьВыражениеУсловия();

КонецПроцедуры

Процедура ЗагрузитьВыражениеУсловия()

	мТекущаяСтрокаУсловия = ЭлементыФормы.ДеревоУсловия.ТекущаяСтрока;
	Если ТипЗнч(мТекущаяСтрокаУсловия) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность = мТекущаяСтрокаУсловия.Представление <> "";
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	Иначе
		ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность = Ложь;
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст("");
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияСвязиПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		ОбновитьЭлементОтбораПослеИзменения(Элемент);
		// Зафиксирована 1 раз ошибка "Поле объекта не обнаружено (Представление)". Воспроизвести не сумел
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст(мТекущаяСтрокаУсловияСвязи.Представление);
	КонецЕсли; 

КонецПроцедуры

Процедура Английский1СПриИзменении(Элемент)
	
	ДиалектSQLПриИзменении();

КонецПроцедуры

Процедура ОбъединениеПриИзменении(Элемент)
	
	ИзменитьСвернутостьПанельЧастей(РежимОбъединения);
	
КонецПроцедуры

Процедура СохранитьЧастьОбъединения()
	
	Если мТекущаяСтрокаЧастиОбъединения = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ЧастиОбъединения.Индекс(мТекущаяСтрокаЧастиОбъединения) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьВыбраннуюТаблицу();
	СохранитьВыбранноеПоле();
	СохранитьВыражениеУсловия();
	СохранитьУсловиеСвязи();
	//мТекущаяСтрокаЧастиОбъединения.Условие = КомпоновщикЧасти.ПолучитьНастройки();
	мТекущаяСтрокаЧастиОбъединения.ОпцияРазличные = ОпцияРазличные;
	мТекущаяСтрокаЧастиОбъединения.ОпцияДляИзменения = ОпцияДляИзменения;
	мТекущаяСтрокаЧастиОбъединения.Автогруппировки = Автогруппировки;
	мТекущаяСтрокаЧастиОбъединения.Комментарий = ЭлементыФормы.КомментарийЧасти.ПолучитьТекст();
	мТекущаяСтрокаЧастиОбъединения.КомментарийОтбора = ЭлементыФормы.КомментарийОтбора.ПолучитьТекст();
	Если ВыбранныеПоля.Количество() = 0 Тогда
		Для Каждого СтрокаВыбраннойТаблицы Из ВыбранныеТаблицы Цикл
			СтрокаВыбраннойТаблицы.ВсеПоля = Истина;
			ДобавитьВсеПоляТаблицыВВыбранныеПоля(СтрокаВыбраннойТаблицы.Имя,,,, Истина);
		КонецЦикла;
	КонецЕсли; 
	ОбновитьНаименованиеЧасти(мТекущаяСтрокаЧастиОбъединения);
	
КонецПроцедуры

Процедура СохранитьЗапросПакета()
	
	Если мТекущаяСтрокаЗапросыПакета = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ЗапросыПакета.Индекс(мТекущаяСтрокаЗапросыПакета) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьЧастьОбъединения();
	//мТекущаяСтрокаЗапросыПакета.ПоляПорядка = ПоляПорядка.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ПоляИндекса = ПоляИндекса.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ГруппирующиеПоляИтогов = ГруппирующиеПоляИтогов.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения = ЧастиОбъединения.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ПоляОбъединения = ПоляОбъединения.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ГруппируемыеПоляИтогов = ГруппируемыеПоляИтогов.Скопировать();
	мТекущаяСтрокаЗапросыПакета.ТипЗапроса = ТипЗапроса;
	Если Ложь
		Или ТипЗапроса = 2 
		Или ТипЗапроса = 3 
		Или ТипЗапроса = 6 
	Тогда
		мТекущаяСтрокаЗапросыПакета.Комментарий = ЭлементыФормы.КомментарийЧасти.ПолучитьТекст();
	КонецЕсли; 
	мТекущаяСтрокаЗапросыПакета.ОпцияОбщиеИтоги = ОпцияОбщиеИтоги;
	мТекущаяСтрокаЗапросыПакета.ОпцияАвтоупорядочивание = ОпцияАвтоупорядочивание;
	мТекущаяСтрокаЗапросыПакета.ОпцияПервые = ОпцияПервые;
	мТекущаяСтрокаЗапросыПакета.ОпцияРазрешенные = ОпцияРазрешенные;
	мТекущаяСтрокаЗапросыПакета.ПервыеКоличество = ПервыеКоличество;
	мТекущаяСтрокаЗапросыПакета.ИмяОсновнойТаблицы = ИмяОсновнойТаблицы;
	мТекущаяСтрокаЗапросыПакета.УровеньИзоляции = УровеньИзоляции;
	мТекущаяСтрокаЗапросыПакета.ЗначенияИзВыборки = ЗначенияИзВыборки;
	Если Не ЗначениеЗаполнено(ИмяОсновнойТаблицы) Тогда
		мТекущаяСтрокаЗапросыПакета.ИмяОсновнойТаблицы = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЗапросыПакета, мТекущаяСтрокаЗапросыПакета, "ИмяОсновнойТаблицы");
	КонецЕсли; 
	ОбновитьНаименованиеЗапроса(мТекущаяСтрокаЗапросыПакета);
	
КонецПроцедуры

Процедура ЧастиОбъединенияПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьЧастьОбъединения();
	ЗагрузитьЧастьОбъединения();
	
КонецПроцедуры

Процедура ЗагрузитьЧастьОбъединения()
	
	Элемент = ЭлементыФормы.ЧастиОбъединения;
	мТекущаяСтрокаЧастиОбъединения = Элемент.ТекущаяСтрока;
	мТекущаяСтрокаВыбранногоПоля = Неопределено;
	мТекущаяСтрокаВыбранныеТаблицы = Неопределено;
	мТекущаяСтрокаУсловия = Неопределено;
	мТекущаяСтрокаСвязи = Неопределено;
	мТекущаяСтрокаУсловияСвязи = Неопределено;
	мТекущаяСтрокаПараметраТаблицы = Неопределено;
	мТекущаяСтрокаПараметраТаблицы = Неопределено;
	Если мТекущаяСтрокаЧастиОбъединения <> Неопределено Тогда
		ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст("");
		ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст("");
		ЭлементыФормы.КомментарийЧасти.УстановитьТекст(мТекущаяСтрокаЧастиОбъединения.Комментарий);
		ЭлементыФормы.КомментарийОтбора.УстановитьТекст(мТекущаяСтрокаЧастиОбъединения.КомментарийОтбора);
		//ОбновитьДоступныеВременныеТаблицы();
		ЭтаФорма.ВыбранныеТаблицы = мТекущаяСтрокаЧастиОбъединения.ВыбранныеТаблицы;
		ЭтаФорма.ВыбранныеПоля = мТекущаяСтрокаЧастиОбъединения.ВыбранныеПоля;
		ЭтаФорма.СвязиТаблиц = мТекущаяСтрокаЧастиОбъединения.СвязиТаблиц;
		ЭтаФорма.Группировки = мТекущаяСтрокаЧастиОбъединения.Группировки;
		ЭтаФорма.КомпоновщикЧасти = мТекущаяСтрокаЧастиОбъединения.Компоновщик;
		ЭтаФорма.ПоляВыбораПостроителя = мТекущаяСтрокаЧастиОбъединения.ПоляВыбораПостроителя;
		ЭтаФорма.ПоляОтбораПостроителя = мТекущаяСтрокаЧастиОбъединения.ПоляОтбораПостроителя;
		Если КомпоновщикЧасти.Настройки.Отбор.Элементы.Количество() > 0 Тогда
			ЭлементыФормы.ДеревоУсловия.ТекущаяСтрока = КомпоновщикЧасти.Настройки.Отбор.Элементы[0];
		КонецЕсли; 
		ЗагрузитьДоступныеНастройкиКомпоновки();
		КомпоновщикУсловияСвязи.ЗагрузитьНастройки(Новый НастройкиКомпоновкиДанных);
		ЭтаФорма.ОпцияРазличные = мТекущаяСтрокаЧастиОбъединения.ОпцияРазличные;
		ЭтаФорма.ОпцияДляИзменения = мТекущаяСтрокаЧастиОбъединения.ОпцияДляИзменения;
		ОбновитьВидимостьКолонкиДляИзмененияВыбранныхТаблиц();
		ЭтаФорма.Автогруппировки = мТекущаяСтрокаЧастиОбъединения.Автогруппировки;
		ОбновитьГруппировки();
		ПанельЧастиОбновитьТекущуюСтраницу();
	КонецЕсли; 

КонецПроцедуры

Процедура ЧастиОбъединенияПередУдалением(Элемент, Отказ)
	
	Если Элемент.Значение.Количество() = 1 Тогда
		Отказ = Истина;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЧастиОбъединенияПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	СохранитьЗапросПакета(); // Может уже не надо
	Если Копирование Тогда
		ЧастьОбъединения = СкопироватьЧастьОбъединения(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока, мТекущаяСтрокаЧастиОбъединения);
	Иначе
		ЧастьОбъединения = ДобавитьЧастьОбъединения(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
	КонецЕсли; 
	ЗагрузитьЗапросПакета(); // Может уже не надо
	Элемент.ТекущаяСтрока = ЧастьОбъединения;
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьПолеОбъединенияВГруппирующиеПоля(ВыбраннаяСтрока);

КонецПроцедуры

Процедура ДобавитьПолеОбъединенияВГруппирующиеПоля(ПолеОбъединения)
	
	Если Ложь
		Или ЗначениеЗаполнено(ПолеОбъединения.РольИтога) 
		Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
	Тогда
		Возврат;
	КонецЕсли; 
	ОпределениеПоля = "" + ПолеОбъединения.Имя;
	СтрокаГруппирующегоПоля = ГруппирующиеПоляИтогов.Найти(ОпределениеПоля, "Определение");
	Если СтрокаГруппирующегоПоля = Неопределено Тогда
		СтрокаГруппирующегоПоля = ГруппирующиеПоляИтогов.Добавить();
		СтрокаГруппирующегоПоля.Определение = ОпределениеПоля;
		СтрокаГруппирующегоПоля.ТипИтогов = "Элементы";
		//ПолеОбъединения.РольИтога = 1; // так не будет работать, т.к. при перетаскивании созадается копия строки
		ОбновитьРолиИтогов();
	КонецЕсли; 
	ЭлементыФормы.ГруппирующиеПоляИтогов.ТекущаяСтрока = СтрокаГруппирующегоПоля;

КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если Не ЗначениеЗаполнено(ДанныеСтроки.Имя) Тогда
		ОформлениеСтроки.Ячейки.Имя.УстановитьТекст(ДанныеСтроки.Определение);
		ОформлениеСтроки.Ячейки.Имя.ЦветТекста = Новый Цвет(128, 128, 128);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЛиПакетныйЗапросПриИзменении(Элемент = Неопределено) Экспорт
	
	ИзменитьСвернутостьПанельПакета(ЛиПакетныйЗапрос);

КонецПроцедуры

Процедура ЗапросыПакетаПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	ЗапросПакета = ДобавитьЗапросПакета();
	Если Копирование Тогда
		СкопироватьЗапрос(мТекущаяСтрокаЗапросыПакета, ЗапросПакета);
	КонецЕсли; 
	Элемент.ТекущаяСтрока = ЗапросПакета;

КонецПроцедуры

Процедура ЗапросыПакетаПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьЗапросПакета();
	ЗагрузитьЗапросПакета();

КонецПроцедуры

Процедура ЗагрузитьЗапросПакета()
	
	Элемент = ЭлементыФормы.ЗапросыПакета;
	мТекущаяСтрокаЗапросыПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	мТекущаяСтрокаГруппируемогоПоля = Неопределено;
	Если мТекущаяСтрокаЗапросыПакета <> Неопределено Тогда
		мТекущееИмяОсновнойТаблицы = мТекущаяСтрокаЗапросыПакета.ИмяОсновнойТаблицы;
		ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст("");
		ЭтаФорма.ЧастиОбъединения = мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения;
		ЭтаФорма.ТипЗапроса = мТекущаяСтрокаЗапросыПакета.ТипЗапроса;
		ЭтаФорма.РежимОбъединения = мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения.Количество() > 1;
		ЭтаФорма.ПоляПорядка = мТекущаяСтрокаЗапросыПакета.ПоляПорядка;
		ЭтаФорма.ПоляОбъединения = мТекущаяСтрокаЗапросыПакета.ПоляОбъединения;
		ЭтаФорма.ПоляИндекса = мТекущаяСтрокаЗапросыПакета.ПоляИндекса;
		ЭтаФорма.ПринимающиеПоля = мТекущаяСтрокаЗапросыПакета.ПринимающиеПоля;
		ЭтаФорма.ГруппируемыеПоляИтогов = мТекущаяСтрокаЗапросыПакета.ГруппируемыеПоляИтогов;
		ЭтаФорма.ГруппирующиеПоляИтогов = мТекущаяСтрокаЗапросыПакета.ГруппирующиеПоляИтогов;
		ЭтаФорма.ОпцияРазрешенные = мТекущаяСтрокаЗапросыПакета.ОпцияРазрешенные;
		ЭтаФорма.ОпцияОбщиеИтоги = мТекущаяСтрокаЗапросыПакета.ОпцияОбщиеИтоги;
		ЭтаФорма.ОпцияПервые = мТекущаяСтрокаЗапросыПакета.ОпцияПервые;
		ЭтаФорма.ОпцияАвтоупорядочивание = мТекущаяСтрокаЗапросыПакета.ОпцияАвтоупорядочивание;
		ЭтаФорма.ИмяОсновнойТаблицы = мТекущаяСтрокаЗапросыПакета.ИмяОсновнойТаблицы;
		ЭтаФорма.УровеньИзоляции = мТекущаяСтрокаЗапросыПакета.УровеньИзоляции;
		ЭтаФорма.ЗначенияИзВыборки = мТекущаяСтрокаЗапросыПакета.ЗначенияИзВыборки;
		ЭтаФорма.ПервыеКоличество = мТекущаяСтрокаЗапросыПакета.ПервыеКоличество;
		ЭтаФорма.КомпоновщикЗапроса = мТекущаяСтрокаЗапросыПакета.Компоновщик;
		ЭтаФорма.ПоляПорядкаПостроителя = мТекущаяСтрокаЗапросыПакета.ПоляПорядкаПостроителя;
		ЭтаФорма.ПоляИтоговПостроителя = мТекущаяСтрокаЗапросыПакета.ПоляИтоговПостроителя;
		ДоступныеПоляПсевдонима.Очистить();
		ОбновитьДоступныеВременныеТаблицы();
		ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц();
		ПанельОсновнаяОбновитьТекущуюСтраницу();
		ЗначенияИзВыборкиПриИзменении();
		Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения Тогда
			ОбновитьТабличноеПолеПоляОбъединения();
		КонецЕсли;
		Если Ложь
			Или ТипЗапроса = 2 
			Или ТипЗапроса = 3 
			Или ТипЗапроса = 6
		Тогда
			ЭлементыФормы.КомментарийЧасти.УстановитьТекст(мТекущаяСтрокаЗапросыПакета.Комментарий);
			мТекущаяСтрокаЧастиОбъединения = Неопределено;
		Иначе
			Если ЭтаФорма.ЧастиОбъединения.Количество() = 0 Тогда
				ДобавитьЧастьОбъединения(мТекущаяСтрокаЗапросыПакета);
			КонецЕсли; 
			Если Истина
				И ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = Неопределено 
				И ЧастиОбъединения.Количество() > 0
			Тогда
				ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = ЧастиОбъединения[0];
			Иначе
				ЧастиОбъединенияПриАктивизацииСтроки();
			КонецЕсли; 
		КонецЕсли; 
		ИзменитьСвернутостьПанельЧастей(РежимОбъединения);
	КонецЕсли; 

КонецПроцедуры

Процедура ДоступныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Тип = ДанныеСтроки.Тип;
	ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаТаблицыБДЛкс(Тип);
	ОформлениеСтроки.Ячейки.Имя.ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки.Имя.ИндексКартинки = ИндексКартинки;
	Если ДанныеСтроки.КоличествоСтрок = Неопределено Тогда
		ОформлениеСтроки.Ячейки.КоличествоСтрок.УстановитьТекст("?");
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОформитьЯчейкуИмениТаблицы(Элемент, ОформлениеСтроки, ДанныеСтроки, ИмяЯчейкиТаблицы)
	
	ИндексКартинки = Неопределено;
	СтрокаВыбраннойТаблицы = ВыбранныеТаблицы.Найти(ДанныеСтроки[ИмяЯчейкиТаблицы], "Имя");
	Если СтрокаВыбраннойТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ИндексКартинки = ПолучитьИндексКартинкиВыбраннойТаблицы(СтрокаВыбраннойТаблицы);
	ОформлениеСтроки.Ячейки[ИмяЯчейкиТаблицы].ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки[ИмяЯчейкиТаблицы].ИндексКартинки = ИндексКартинки;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	СтрокаДоступнойТаблицы = Неопределено;
	ИндексКартинки = ПолучитьИндексКартинкиВыбраннойТаблицы(ДанныеСтроки, СтрокаДоступнойТаблицы);
	ОформлениеСтроки.Ячейки.Имя.ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки.Имя.ИндексКартинки = ИндексКартинки;
	Если Истина
		И ДанныеСтроки.ВложенныйПакет = Неопределено
		И СтрокаДоступнойТаблицы = Неопределено 
		И Найти(ДанныеСтроки.ПолноеИмя, ".") > 0
	Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	КонецЕсли; 
	Если ДанныеСтроки.Обязательная Тогда
		ЯчейкаНомерГруппы = ОформлениеСтроки.Ячейки.Найти("НомерГруппы");
		Если ЯчейкаНомерГруппы <> Неопределено Тогда
			ЯчейкаНомерГруппы.ТолькоПросмотр = Истина;
		КонецЕсли; 
	КонецЕсли; 
	Если Ложь
		Или ДанныеСтроки.ВложенныйПакет <> Неопределено 
		Или ДанныеСтроки.Параметры.Количество() > 0
		Или (Истина
			И СтрокаДоступнойТаблицы <> Неопределено
			И (Ложь
				Или СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица"
				Или СтрокаДоступнойТаблицы.Тип = "ВиртуальнаяТаблица"))
	Тогда
		ЯчейкаДляИзменения = ОформлениеСтроки.Ячейки.Найти("ДляИзменения");
		Если ЯчейкаДляИзменения <> Неопределено Тогда
			ЯчейкаДляИзменения.ТолькоПросмотр = Истина;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Функция ПолучитьИндексКартинкиВыбраннойТаблицы(ДанныеСтроки, выхСтрокаДоступнойТаблицы = Неопределено)

	ИндексКартинки = Неопределено;
	Если ДанныеСтроки.ВложенныйПакет <> Неопределено Тогда
		ИндексКартинки = 0;
	КонецЕсли; 
	Если ИндексКартинки = Неопределено Тогда
		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ДанныеСтроки.ПолноеИмя);
		выхСтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
		Если выхСтрокаДоступнойТаблицы <> Неопределено Тогда
			Тип = выхСтрокаДоступнойТаблицы.Тип;
		КонецЕсли; 
	КонецЕсли; 
	Если ИндексКартинки = Неопределено Тогда
		ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаТаблицыБДЛкс(Тип);
	КонецЕсли;
	Возврат ИндексКартинки;

КонецФункции

Процедура ТипЗапросаПриИзменении(Элемент)
	
	ОбновитьНаименованиеЗапроса();

КонецПроцедуры

Процедура ОбновитьНаименованиеЗапроса(ЗапросПакета = Неопределено) Экспорт
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли;
	Если ЗапросПакета.РучноеИмя И ЗначениеЗаполнено(ЗапросПакета.Имя) Тогда
		Возврат;
	КонецЕсли; 
	Если ЗапросПакета.ТипЗапроса = 0 Тогда
		ЗапросПакета.Имя = "" + ЗапросПакета.Индекс;
		Если ЗапросПакета.ЧастиОбъединения.Количество() > 0 Тогда
			ИмяЧастиОбъединения = Сред(ЗапросПакета.ЧастиОбъединения[0].Имя, СтрДлина("" + ЗапросПакета.ЧастиОбъединения[0].Номер + ",") + 1);
			Если Не ПустаяСтрока(ИмяЧастиОбъединения) Тогда
				ЗапросПакета.Имя = ЗапросПакета.Имя + ", " + ИмяЧастиОбъединения;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ЗапросПакета.ТипЗапроса = 1 Тогда
		ЗапросПакета.Имя = "+," + ЗапросПакета.ИмяОсновнойТаблицы;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 2 Тогда
		ЗапросПакета.Имя = "-," + ЗапросПакета.ИмяОсновнойТаблицы;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 3 Тогда
		ЗапросПакета.Имя = "^," + ЗапросПакета.ИмяОсновнойТаблицы;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 4 Тогда
		ЗапросПакета.Имя = "*," + ЗапросПакета.ИмяОсновнойТаблицы;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 5 Тогда
		ЗапросПакета.Имя = "x," + ЗапросПакета.ИмяОсновнойТаблицы;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 6 Тогда
		ЗапросПакета.Имя = "&," + ЗапросПакета.ИмяОсновнойТаблицы;
	Иначе
		ЗапросПакета.Имя = "" + ЗапросПакета.Индекс;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьНаименованиеЧасти(ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ЧастьОбъединения.РучноеИмя И ЗначениеЗаполнено(ЧастьОбъединения.Имя) Тогда
		Возврат;
	КонецЕсли; 
	ИмяЧасти = "";
	Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		ИмяЧасти = ИмяЧасти + ", " + СтрокаВыбраннойТаблицы.Имя;
	КонецЦикла;
	Если Не ЗначениеЗаполнено(ИмяЧасти) И ЧастьОбъединения.ВыбранныеПоля.Количество() > 0 Тогда
		ИмяЧасти = ИмяЧасти + ", "  + ЧастьОбъединения.ВыбранныеПоля[0].Определение;
	КонецЕсли; 
	ИмяЧасти = "" + ЧастьОбъединения.Номер + ИмяЧасти;
	ЧастьОбъединения.Имя = ИмяЧасти;
	ЧастьОбъединения.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЧастьОбъединения.Владелец(), ЧастьОбъединения,, Ложь);
	
КонецПроцедуры

Процедура ВыбранныеТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.ВложенныйПакет <> Неопределено Тогда
		СтандартнаяОбработка = Ложь;
		ОткрытьВложенныйПакет(ВыбраннаяСтрока.ВложенныйПакет, ВыбраннаяСтрока.Имя);
	КонецЕсли; 
	
КонецПроцедуры

Функция _СкопироватьТаблицуВыражений(ТаблицаВыражений)

	КопияТаблицы = ирОбщий.ПолучитьКопиюОбъектаЛкс(ТаблицаВыражений);
	Для Индекс = 0 По КопияТаблицы.Количество() - 1 Цикл
		ЗаполнитьЗначенияСвойств(КопияТаблицы[Индекс], ТаблицаВыражений[Индекс], "Токен"); 
	КонецЦикла;
	Возврат КопияТаблицы;

КонецФункции // СкопироватьТаблицуВыражений()

Функция СкопироватьВложенныйПакетДляРедактирования(Пакет)

	// Удаляем все токены, т.к. для настроек компоновки сериализация всегда выполняется через сериализаторXDTO, который ругается на COM объекты
	ОбновитьВсеВыраженияПакета(Пакет, 2); 
	ПакетКопия = ирОбщий.ПолучитьКопиюОбъектаЛкс(Пакет);
	ЗапросИсточник = Пакет[0];
	ЗапросПриемник = ПакетКопия[0];
	Для Индекс = 0 По ЗапросИсточник.ЧастиОбъединения.Количество() - 1 Цикл
		ЧастьОбъединенияКопия = ЗапросПриемник.ЧастиОбъединения[Индекс];
		ЧастьОбъединенияКопия.Компоновщик.ЗагрузитьНастройки(ЗапросИсточник.ЧастиОбъединения[Индекс].Компоновщик.Настройки); 
		//ЧастьОбъединенияКопия.Условие = ЧастьОбъединенияКопия.Компоновщик.Настройки;
		ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединенияКопия);
	КонецЦикла;
	ОбновитьВсеВыраженияЗапроса(ЗапросПриемник);
	//ОбновитьВсеВыраженияПакета(ПакетКопия);
	Возврат ПакетКопия;
	// Доделать копирования токенов
	//ПараметрыТаблицы.Колонки.Добавить("Токен");
	//ВыбранныеПоля.Колонки.Добавить("Токен");
	//Группировки.Колонки.Добавить("Токен");
	//ПоляПорядка.Колонки.Добавить("Токен");
	//ПоляВыбораПостроителя.Колонки.Добавить("Токен");
	//ПоляОтбораПостроителя.Колонки.Добавить("Токен");
	//ПоляПорядкаПостроителя.Колонки.Добавить("Токен");
	//ПоляИтоговПостроителя.Колонки.Добавить("Токен");
	//ГруппируемыеПоляИтогов.Колонки.Добавить("Токен");
	//ГруппирующиеПоляИтогов.Колонки.Добавить("Токен");

КонецФункции

Функция СкопироватьЗапрос(Знач ЗапросИсточник, ЗапросПриемник = Неопределено)
	
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(ЗапросИсточник);
	ЗапросыИсточника = ЗапросыПакета.Скопировать(МассивСтрок);
	ЗапросыПриемника = СкопироватьВложенныйПакетДляРедактирования(ЗапросыИсточника);
	Если ЗапросПриемник <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(ЗапросПриемник, ЗапросыПриемника[0],, "ИД");
	Иначе
		ЗапросПриемник = ЗапросыПриемника[0];
	КонецЕсли; 
	Возврат ЗапросПриемник;

КонецФункции // СкопироватьПакетДляРедактирования()

Функция СкопироватьЧастьОбъединения(ЗапросПакета, ЧастьОбъединения)

	// Удаляем все токены, т.к. для настроек компоновки сериализация всегда выполняется через сериализаторXDTO, который ругается на COM объекты
	ОбновитьВсеВыраженияЧастиОбъединения(ЗапросПакета, ЧастьОбъединения, 2); 
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(ЧастьОбъединения);
	ЧастьОбъединенияКопия = ДобавитьЧастьОбъединения(ЗапросПакета);
	ЗаполнитьЗначенияСвойств(ЧастьОбъединенияКопия, ирОбщий.ПолучитьКопиюОбъектаЛкс(ЧастьОбъединения.Владелец().Скопировать(МассивСтрок))[0],, "Номер");
	ЧастьОбъединенияКопия.Компоновщик.ЗагрузитьНастройки(ЧастьОбъединения.Компоновщик.Настройки); 
	//ЧастьОбъединенияКопия.Условие = ЧастьОбъединенияКопия.Компоновщик.Настройки;
	ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединенияКопия);
	ОбновитьВсеВыраженияЧастиОбъединения(ЗапросПакета, ЧастьОбъединенияКопия);
	ОбновитьНаименованиеЧасти(ЧастьОбъединенияКопия);
	Возврат ЧастьОбъединенияКопия;
	// Доделать копирования токенов
	//ПараметрыТаблицы.Колонки.Добавить("Токен");
	//ВыбранныеПоля.Колонки.Добавить("Токен");
	//Группировки.Колонки.Добавить("Токен");
	//ПоляПорядка.Колонки.Добавить("Токен");
	//ПоляВыбораПостроителя.Колонки.Добавить("Токен");
	//ПоляОтбораПостроителя.Колонки.Добавить("Токен");
	//ПоляПорядкаПостроителя.Колонки.Добавить("Токен");
	//ПоляИтоговПостроителя.Колонки.Добавить("Токен");
	//ГруппируемыеПоляИтогов.Колонки.Добавить("Токен");
	//ГруппирующиеПоляИтогов.Колонки.Добавить("Токен");

КонецФункции // СкопироватьПакетДляРедактирования()

Функция ОткрытьВложенныйПакет(ВложенныйПакет = Неопределено, Знач ИмяЗапроса = "", ТекстЗапроса = "")
	
	ФормаКонструктора = ПолучитьФорму("КонструкторЗапроса", ЭтаФорма);
	Если Не ЗначениеЗаполнено(ИмяЗапроса) Тогда
		ИмяЗапроса = "<Безымянный>";
	КонецЕсли; 
	ФормаКонструктора.Заголовок = ФормаКонструктора.Заголовок + ". " + ИмяЗапроса;
	ЗаполнитьЗначенияСвойств(ФормаКонструктора, ЭтаФорма, "РасширеннаяПроверка, Английский1С, ТабличноеПолеКорневогоПакета, ПоказыватьИндексы");
	ФормаКонструктора.УстановитьДиалектSQL(ДиалектSQL);
	ФормаКонструктора.Параметры = ЭтаФорма.Параметры;
	Если ВложенныйПакет <> Неопределено Тогда
		ФормаКонструктора.ЗапросыПакета = СкопироватьВложенныйПакетДляРедактирования(ВложенныйПакет);
	ИначеЕсли ЗначениеЗаполнено(ТекстЗапроса) Тогда 
		ФормаКонструктора.ПараметрТекстПакета = ТекстЗапроса;
	КонецЕсли; 
	РезультатФормы = ФормаКонструктора.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Если ВложенныйПакет <> Неопределено Тогда
			СтрокаВыбраннойТаблицы = ВыбранныеТаблицы.Найти(ИмяЗапроса, "Имя");
			// Проверим переименования полей
			Для Каждого СтрокаСтарогоПоля Из ВложенныйПакет[0].ПоляОбъединения Цикл
				СтрокаНовогоПоля = ФормаКонструктора.ЗапросыПакета[0].ПоляОбъединения.Найти(СтрокаСтарогоПоля._1, "_1");
				Если Истина
					И СтрокаНовогоПоля <> Неопределено // Удаление полей пока не учитываем
					И СтрокаСтарогоПоля.Имя <> СтрокаНовогоПоля.Имя 
				Тогда
					ПереименоватьТаблицуИлиПараметр(, СтрокаВыбраннойТаблицы.Имя,  СтрокаВыбраннойТаблицы.Имя, СтрокаСтарогоПоля.Имя, СтрокаНовогоПоля.Имя, Ложь);
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
		ВложенныйПакет = ФормаКонструктора.ЗапросыПакета;
	КонецЕсли; 
	ОбновитьДоступныеВременныеТаблицы();
	Возврат ВложенныйПакет;
	
КонецФункции 

Процедура ИмяОсновнойТаблицыПриИзменении(Элемент)

	НовоеИмя = Элемент.Значение;
	Если мТекущееИмяОсновнойТаблицы = НовоеИмя Тогда
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаЗапросыПакета.ИмяОсновнойТаблицы = НовоеИмя;
	ОбновитьНаименованиеЗапроса(мТекущаяСтрокаЗапросыПакета);
	Для Индекс = ЗапросыПакета.Индекс(мТекущаяСтрокаЗапросыПакета) + 1 По ЗапросыПакета.Количество() - 1 Цикл
		СтрокаЗапроса = ЗапросыПакета[Индекс];
		Если Истина
			И СтрокаЗапроса.ТипЗапроса = 2 // Удаление временной таблицы
			И СтрокаЗапроса.ИмяОсновнойТаблицы = мТекущееИмяОсновнойТаблицы
		Тогда
			СтрокаЗапроса.ИмяОсновнойТаблицы = НовоеИмя;
			ОбновитьНаименованиеЗапроса(СтрокаЗапроса);
			Прервать;
		КонецЕсли; 
		ПереименоватьДоступнуюТаблицуВЗапросеПакета(СтрокаЗапроса, мТекущееИмяОсновнойТаблицы, НовоеИмя);
		ОбновитьНаименованиеЗапроса(СтрокаЗапроса);
	КонецЦикла;
	мТекущееИмяОсновнойТаблицы = НовоеИмя;
	
КонецПроцедуры

Процедура ПереименоватьДоступнуюТаблицуВЗапросеПакета(СтрокаЗапроса, СтароеИмя, НовоеИмя)
	
	Для Каждого ЧастьОбъединения Из СтрокаЗапроса.ЧастиОбъединения Цикл
		Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
			Если СтрокаВыбраннойТаблицы.ПолноеИмя = СтароеИмя Тогда
				СтрокаВыбраннойТаблицы.ПолноеИмя = НовоеИмя;
			ИначеЕсли СтрокаВыбраннойТаблицы.ВложенныйПакет <> Неопределено Тогда 
				ПереименоватьДоступнуюТаблицуВЗапросеПакета(СтрокаВыбраннойТаблицы.ВложенныйПакет[0], СтароеИмя, НовоеИмя);
			КонецЕсли; 
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьНомераЗапросов()
	
	Для Каждого ЗапросПакета Из ЗапросыПакета Цикл
		ЗапросПакета.Индекс = ЗапросыПакета.Индекс(ЗапросПакета); 
		ОбновитьНаименованиеЗапроса(ЗапросПакета);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗапросыПакетаПослеУдаления(Элемент)
	
	ОбновитьНомераЗапросов();
	
КонецПроцедуры

Процедура СохранитьВыбраннуюТаблицу()
	
	Если мТекущаяСтрокаВыбранныеТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ВыбранныеТаблицы.Индекс(мТекущаяСтрокаВыбранныеТаблицы) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьПараметрТаблицы();
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПриАктивизацииСтроки(Элемент)
	
	СохранитьВыбраннуюТаблицу();
	ЗагрузитьВыбраннуюТаблицу();
	
КонецПроцедуры

Процедура ЗагрузитьВыбраннуюТаблицу()
	
	Элемент = ЭлементыФормы.ВыбранныеТаблицы;
	мТекущаяСтрокаВыбранныеТаблицы = Элемент.ТекущаяСтрока;
	НоваяДоступностьКнопки = Истина
		И мТекущаяСтрокаВыбранныеТаблицы <> Неопределено
		И мТекущаяСтрокаВыбранныеТаблицы.ВложенныйПакет <> Неопределено;
	//ЭлементыФормы.КПВыбранныеТаблицы.Кнопки.ПреобразоватьВПодзапрос.Доступность = НоваяДоступностьКнопки;
	ЭлементыФормы.КПВыбранныеТаблицы.Кнопки.ПеренестиВоВременнуюТаблицу.Доступность = НоваяДоступностьКнопки;
	ЭлементыФормы.КПВыбранныеТаблицы.Кнопки.ВстроитьИзПодзапроса.Доступность = НоваяДоступностьКнопки;
	мТекущееИмяВыбраннойТаблицы = Неопределено;
	ЭтаФорма.ПараметрыТаблицы = ПараметрыТаблицы.СкопироватьКолонки(); // Тут нельзя очищать существующую таблицу, т.к. она может принадлежать кому то
	мТекущаяСтрокаПараметраТаблицы = Неопределено;
	ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст("");
	Если мТекущаяСтрокаВыбранныеТаблицы <> Неопределено Тогда
		ОбновитьТекущееИмяТаблицы();
		ЭтаФорма.ПараметрыТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Параметры;
		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя);
		ДоступнаяТаблица = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
		КоличествоПараметровДоступнойТаблицы = 0;
		Если ДоступнаяТаблица <> Неопределено Тогда
			//Если ДоступнаяТаблица.Тип = "ВиртуальнаяТаблица" Тогда
				//МассивЗащитыОтРекурсии.Очистить();
				ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(Элемент.ТекущаяСтрока.ПолноеИмя);
				Если ТаблицаСтруктурТиповКонтекста.Количество() > 0 Тогда
					СтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
					ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
					ИмяВиртуальнойТаблицы = ирОбщий.ПолучитьПоследнийФрагментЛкс(ИмяОбщегоТипа);
					ТипКонтекста = Лев(ИмяОбщегоТипа, СтрДлина(ИмяОбщегоТипа) - СтрДлина(ИмяВиртуальнойТаблицы) - 1);
					СтруктураКлюча = Новый Структура("ТипКонтекста, Слово, ЯзыкПрограммы", ТипКонтекста, ИмяВиртуальнойТаблицы, 1);
					НайденныеСтроки = мПлатформа.ТаблицаПараметров.НайтиСтроки(СтруктураКлюча);
					КоличествоПараметровДоступнойТаблицы = НайденныеСтроки.Количество();
					Для Счетчик = 1 По КоличествоПараметровДоступнойТаблицы Цикл
						СтрокаОписанияПараметра = НайденныеСтроки[Счетчик - 1];
						// Защита от двойных параметров для вирт. таблиц регистра бухгалтерии
						СтрокаПараметра = ПараметрыТаблицы.Найти(СтрокаОписанияПараметра.Параметр, "Имя");
						Если СтрокаПараметра <> Неопределено Тогда
							Продолжить;
						КонецЕсли; 
						Если Счетчик > ПараметрыТаблицы.Количество() Тогда
							СтрокаПараметра = ПараметрыТаблицы.Добавить();
							СтрокаПараметра.Номер = Счетчик;
						Иначе
							СтрокаПараметра = ПараметрыТаблицы[Счетчик - 1];
						КонецЕсли; 
						СтрокаПараметра.Имя = СтрокаОписанияПараметра.Параметр;
					КонецЦикла;
				КонецЕсли; 
			//КонецЕсли; 
		КонецЕсли; 
		Для Индекс = КоличествоПараметровДоступнойТаблицы По ПараметрыТаблицы.Количество() - 1 Цикл
			СтрокаПараметра = ПараметрыТаблицы[Индекс];
			НомерПараметра = Индекс + 1;
			СтрокаПараметра.Имя = "Неизвестный" + (НомерПараметра);
			СтрокаПараметра.Номер = НомерПараметра;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

Функция ОбновитьТекущееИмяТаблицы()

	мТекущееИмяВыбраннойТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Имя;
	Возврат Неопределено;

КонецФункции

Процедура СохранитьПараметрТаблицы()
	
	Если мТекущаяСтрокаПараметраТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ПараметрыТаблицы.Индекс(мТекущаяСтрокаПараметраТаблицы) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаПараметраТаблицы.Определение = ЭлементыФормы.ВыражениеПараметраТаблицы.ПолучитьТекст();
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаПараметраТаблицы,,,,,, Истина);
	
КонецПроцедуры

Процедура ЗагрузитьПараметрТаблицы()
	
	мТекущаяСтрокаПараметраТаблицы = ЭлементыФормы.ПараметрыТаблицы.ТекущаяСтрока;
	Если мТекущаяСтрокаПараметраТаблицы = Неопределено Тогда
		НовыйТекст = "";
	Иначе
		НовыйТекст = мТекущаяСтрокаПараметраТаблицы.Определение;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст(НовыйТекст);
	ПолеВводаЗначенияПараметра = ЭлементыФормы.ПараметрыТаблицы.Колонки.Определение.ЭлементУправления;
	ПолеВводаЗначенияПараметра.СписокВыбора = Новый СписокЗначений;
	Если мТекущаяСтрокаПараметраТаблицы <> Неопределено Тогда
		Если ЭтоПараметрПериодичность1С(мТекущаяСтрокаПараметраТаблицы) Тогда
			ПолеВводаЗначенияПараметра.РежимВыбораИзСписка = Истина;
			СписокПериодичностей = Новый СписокЗначений;
			СписокПериодичностей.Добавить("ЗАПИСЬ", "Запись");
			СписокПериодичностей.Добавить("ПЕРИОД", "Период");
			СписокПериодичностей.Добавить("РЕГИСТРАТОР", "Регистратор");
			СписокПериодичностей.Добавить("СЕКУНДА", "Секунда");
			СписокПериодичностей.Добавить("МИНУТА", "Минута");
			СписокПериодичностей.Добавить("ЧАС", "Час");
			СписокПериодичностей.Добавить("ДЕНЬ", "День");
			СписокПериодичностей.Добавить("МЕСЯЦ", "Месяц");
			СписокПериодичностей.Добавить("ГОД", "Год");
			ПолеВводаЗначенияПараметра.СписокВыбора = СписокПериодичностей;
		ИначеЕсли ЭтоПараметрМетодДополненияПериодов1С(мТекущаяСтрокаПараметраТаблицы) Тогда 
			ПолеВводаЗначенияПараметра.РежимВыбораИзСписка = Истина;
			СписокВыбора = Новый СписокЗначений;
			СписокВыбора.Добавить("Движения");
			СписокВыбора.Добавить("ДвиженияИГраницыПериода");
			ПолеВводаЗначенияПараметра.СписокВыбора = СписокВыбора;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыТаблицыПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьПараметрТаблицы();
	ЗагрузитьПараметрТаблицы();
	
КонецПроцедуры

Функция ЭтоПараметрПериодичность1С(СтрокаПараметраТаблицы)

	Результат = Истина
		И Найти(НРег(СтрокаПараметраТаблицы.Имя), "периодичность") = 1
		И ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С");
	Возврат Результат;

КонецФункции // ЭтоПараметр1СПериодичность()

Функция ЭтоПараметрОтбор1С(СтрокаПараметраТаблицы)

	Результат = Истина
		И Найти(НРег(СтрокаПараметраТаблицы.Имя), "условие") = 1
		И ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С");
	Возврат Результат;

КонецФункции // ЭтоПараметр1СПериодичность()

Функция ЭтоПараметрМетодДополненияПериодов1С(СтрокаПараметраТаблицы)

	Результат = Истина
		И Найти(НРег(СтрокаПараметраТаблицы.Имя), "метод дополнения периодов") = 1
		И ирОбщий.СтрокиРавныЛкс(ДиалектSQL, "1С");
	Возврат Результат;

КонецФункции // ЭтоПараметр1СПериодичность()

Процедура КППараметрыТаблицыПодсказатьПараметр(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ПараметрыТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЭтотОбъект.мНомерПараметра = ТекущаяСтрока.Номер;
	ОткрытьПоискВСинтаксПомощнике(ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока.ПолноеИмя);
	
КонецПроцедуры

Процедура КПДоступныеТаблицыПерейтиКОпределению(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТекущаяСтрока.Тип = "ВременнаяТаблица" Тогда
		ПородившаяСтрокаПакета = ЗапросыПакета.Найти(ТекущаяСтрока.ПородившийЗапрос, "ИД");
		Если ПородившаяСтрокаПакета <> Неопределено Тогда
			ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = ПородившаяСтрокаПакета;
		КонецЕсли; 
	Иначе
		ОткрытьПоискВСинтаксПомощнике(ТекущаяСтрока.ПолноеИмя);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыНайтиВСписке(Кнопка = Неопределено)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока <> Неопределено Тогда
		ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ТекущаяСтрока.ПолноеИмя);
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
		Если СтрокаДоступнойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = СтрокаДоступнойТаблицы;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьТекущуюЧастьПсевдонима()
	
	ТекущаяКолонка = ЭлементыФормы.ПоляОбъединения.ТекущаяКолонка;
	Если ТекущаяКолонка = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ИмяКолонки = ТекущаяКолонка.Данные;
	Если ПоляОбъединения.Колонки.Индекс(ПоляОбъединения.Колонки[ИмяКолонки]) < мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Префикс = "Определение";
	Результат = ЧастиОбъединения.Найти(Число(Сред(ИмяКолонки, СтрДлина(Префикс) + 1)), "Номер");
	Возврат Результат;
	
КонецФункции

Процедура ПсевдонимыПолейПриАктивизацииКолонки(Элемент)
	
	ДоступныеПоляПсевдонима.Очистить();
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Добавить();
	СтрокаДоступногоПоля.Определение = "<Отсутствует>";
	Для Каждого ВыбранноеПоле Из ВыбраннаяЧасть.ВыбранныеПоля Цикл
		СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДоступногоПоля, ВыбранноеПоле); 
	КонецЦикла;
	ПсевдонимыПолейПриАктивизацииСтроки();
	
КонецПроцедуры

Процедура ВыбранныеПоляЧастиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	//Если Истина
	//	И ДанныеСтроки.Имя = "" 
	//	И ДанныеСтроки.Определение <> "<Отсутствует>"
	//Тогда
	//	ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	//КонецЕсли;
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ПолеОбъединения = ПоляОбъединения.Найти(ДанныеСтроки.Имя, "Имя");
	Если Истина
		И ПолеОбъединения <> Неопределено 
		И ПолеОбъединения.Монополе 
	Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеПоляПсевдонимаПриАктивизацииСтроки(Элемент)
	
	Если Элемент.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли;
	СтароеИмяПоля = Элемент.ТекущаяСтрока.Имя;
	СтараяСвязьПоля = ПоляОбъединения.Найти(СтароеИмяПоля, "Имя");
	Если СтараяСвязьПоля = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока Тогда
		Возврат;
	КонецЕсли; 
	Если СтараяСвязьПоля <> Неопределено Тогда
		Если Истина
			И Не СтараяСвязьПоля.Монополе
			И Не Автоотвязка 
		Тогда
			Возврат;
		КонецЕсли; 
		СтараяСвязьПоля["_" + ВыбраннаяЧасть.Номер] = Неопределено;
		СтараяСвязьПоля["Определение" + ВыбраннаяЧасть.Номер] = Неопределено; // <Отсутствует>
		Если Не ПроверитьУдалитьБесполезноеПолеОбъединения(СтараяСвязьПоля) Тогда 
			ОбновитьТипЗначенияПоляОбъединения(, СтараяСвязьПоля);
		КонецЕсли; 
	КонецЕсли; 
	Если ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	НовоеИмя = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока.Имя;
	СтрокаДляОтвязки = ДоступныеПоляПсевдонима.Найти(НовоеИмя, "Имя");
	Если СтрокаДляОтвязки <> Неопределено Тогда 
		ВыбранноеПоле = ВыбраннаяЧасть.ВыбранныеПоля.Найти(СтрокаДляОтвязки.ИД, "ИД");
		Если ирОбщий.СтрокиРавныЛкс(СтрокаДляОтвязки.Определение, "NULL") Тогда
			ВыбраннаяЧасть.ВыбранныеПоля.Удалить(ВыбранноеПоле);
			ДоступныеПоляПсевдонима.Удалить(СтрокаДляОтвязки);
			Если ПроверитьУдалитьБесполезноеПолеОбъединения() Тогда 
				Возврат;
			КонецЕсли; 
		Иначе
			СтрокаНовогоПсевдонима = ПоляОбъединения.Добавить();
			АвтоПсевдонимОтвязанногоПоля = ПолучитьАвтоПсевдонимПоля(СтрокаДляОтвязки, ВыбраннаяЧасть);
			АвтоПсевдонимОтвязанногоПоля = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ПоляОбъединения, АвтоПсевдонимОтвязанногоПоля);
			СтрокаНовогоПсевдонима.Имя = АвтоПсевдонимОтвязанногоПоля;
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаНовогоПсевдонима);
			ЗаполнитьЗначенияСвойств(СтрокаНовогоПсевдонима, ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока, "_" + ВыбраннаяЧасть.Номер + "," + "Определение" + ВыбраннаяЧасть.Номер); 
			СтрокаНовогоПсевдонима.ТипЗначения = ВыбранноеПоле.ТипЗначения;
			СтрокаДляОтвязки.Имя = АвтоПсевдонимОтвязанногоПоля;
			ВыбранноеПоле.Имя = АвтоПсевдонимОтвязанногоПоля;
			ОбновитьТипЗначенияПоляОбъединения(, СтрокаНовогоПсевдонима);
		КонецЕсли; 
	КонецЕсли; 
	Если Элемент.ТекущаяСтрока.Определение <> "<Отсутствует>" Тогда
		Элемент.ТекущаяСтрока.Имя = НовоеИмя; 
	КонецЕсли; 
	СтрокаВыбранногоПоля = ВыбраннаяЧасть.ВыбранныеПоля.Найти(Элемент.ТекущаяСтрока.ИД, "ИД");
	Если СтрокаВыбранногоПоля <> Неопределено Тогда
		СтрокаВыбранногоПоля.Имя = НовоеИмя;
	КонецЕсли; 
	ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока["_" + ВыбраннаяЧасть.Номер] = Элемент.ТекущаяСтрока.ИД;
	ОпределениеПоля = Элемент.ТекущаяСтрока.Определение;
	Если ОпределениеПоля = "<Отсутствует>" Тогда
		ОпределениеПоля = "";
	КонецЕсли; 
	ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока["Определение" + ВыбраннаяЧасть.Номер] = ОпределениеПоля;
	ОбновитьТипЗначенияПоляОбъединения();
	
КонецПроцедуры

Функция ПроверитьУдалитьБесполезноеПолеОбъединения(ПолеОбъединения = Неопределено)
	
	Если ПолеОбъединения = Неопределено Тогда
		ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	УдалитьПоле = Истина;
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		Если Истина
			И Не ирОбщий.СтрокиРавныЛкс(ПолеОбъединения["Определение" + ЧастьОбъединения.Номер], "NULL")
			И ЗначениеЗаполнено(ПолеОбъединения["_" + ЧастьОбъединения.Номер])
		Тогда
			// Если есть связанное со старым полем объединения выбранное поле не NULL
			УдалитьПоле = Ложь;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Если УдалитьПоле И ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока Тогда
		Ответ = Вопрос("У текущего поля объединения не осталось полезных связанных выбранных полей. Хотите удалить его?", РежимДиалогаВопрос.ОКОтмена);
		УдалитьПоле = Ответ = КодВозвратаДиалога.ОК;
	КонецЕсли; 
	Если УдалитьПоле Тогда
		// Удаляем все выбранные поля NULL старого поля объединения
		Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
			Если ЗначениеЗаполнено(ПолеОбъединения["_" + ЧастьОбъединения.Номер]) Тогда
				ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ПолеОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
				Если ВыбранноеПоле <> Неопределено Тогда
					ЧастьОбъединения.ВыбранныеПоля.Удалить(ВыбранноеПоле);
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;
		ПоляОбъединения.Удалить(ПолеОбъединения);
	КонецЕсли;
	Возврат УдалитьПоле;

КонецФункции

Процедура ОбновитьТипЗначенияПоляОбъединения(ЗапросПакета = Неопределено, ПолеОбъединения = Неопределено)
	
	Если ПолеОбъединения = Неопределено Тогда
		ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли;
	КоличествоНеNullПолей = 0;
	РазрядностьЧисла = 1;
	РазрядностьДробнойЧасти = 0;
	ДлинаСтроки = 1;
	МассивТипов = Новый Массив;
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ПолеОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
		Если ВыбранноеПоле <> Неопределено Тогда
			ТипЗначенияПоляЧасти = ВыбранноеПоле.ТипЗначения;
			#Если Сервер И Не Сервер Тогда
			    ТипЗначенияПоляЧасти = Новый ОписаниеТипов;
			#КонецЕсли
			Если Не ирОбщий.СтрокиРавныЛкс(ВыбранноеПоле.Определение, "null") Тогда
				КоличествоНеNullПолей = КоличествоНеNullПолей + 1;
			КонецЕсли; 
			Если ТипЗначенияПоляЧасти.СодержитТип(Тип("Число")) Тогда
				Если ТипЗначенияПоляЧасти.КвалификаторыЧисла.Разрядность = 0 Или РазрядностьЧисла = 0 Тогда
					РазрядностьЧисла = 0;
				Иначе
					РазрядностьЧисла = Макс(РазрядностьЧисла, ТипЗначенияПоляЧасти.КвалификаторыЧисла.Разрядность);
				КонецЕсли; 
				РазрядностьДробнойЧасти = Макс(РазрядностьДробнойЧасти, ТипЗначенияПоляЧасти.КвалификаторыЧисла.РазрядностьДробнойЧасти);
			КонецЕсли; 
			Если ТипЗначенияПоляЧасти.СодержитТип(Тип("Строка")) Тогда
				Если ТипЗначенияПоляЧасти.КвалификаторыСтроки.Длина = 0 Или ДлинаСтроки = 0 Тогда
					ДлинаСтроки = 0;
				Иначе
					ДлинаСтроки = Макс(ДлинаСтроки, ТипЗначенияПоляЧасти.КвалификаторыСтроки.Длина);
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			ТипЗначенияПоляЧасти = Новый ОписаниеТипов("Null");
		КонецЕсли; 
		ирОбщий.СкопироватьУниверсальнуюКоллекциюЛкс(ТипЗначенияПоляЧасти.Типы(), МассивТипов);
	КонецЦикла;
	Результат = Новый ОписаниеТипов(МассивТипов, Новый КвалификаторыЧисла(РазрядностьЧисла, РазрядностьДробнойЧасти), Новый КвалификаторыСтроки(ДлинаСтроки));
	ПолеОбъединения.ТипЗначения = Результат;
	ПолеОбъединения.Монополе = КоличествоНеNullПолей <= 1;
	
КонецПроцедуры

Процедура ПсевдонимыПолейПриАктивизацииСтроки(Элемент = Неопределено)
	
	Элемент = ЭлементыФормы.ПоляОбъединения;
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если Элемент.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	//НоваяДоступность = Истина;
	СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Найти(Элемент.ТекущаяСтрока.Имя, "Имя");
	ИД = Элемент.ТекущаяСтрока["_" + ВыбраннаяЧасть.Номер];
	Если СтрокаДоступногоПоля <> Неопределено Тогда
		Если СтрокаДоступногоПоля.ИД = ИД Тогда
			ЭлементыФормы.ДоступныеПоляПсевдонима.ТекущаяСтрока = СтрокаДоступногоПоля;
			//НоваяДоступность = Не Элемент.ТекущаяСтрока.Монополе Или ВыбраннаяЧасть.Номер > 1;
		КонецЕсли; 
	ИначеЕсли Истина
		И Не ЗначениеЗаполнено(ИД)
		И ДоступныеПоляПсевдонима.Количество() > 0 
	Тогда
		ЭлементыФормы.ДоступныеПоляПсевдонима.ТекущаяСтрока = ДоступныеПоляПсевдонима[0];
	КонецЕсли; 
	//ЭлементыФормы.ДоступныеПоляПсевдонима.Доступность = НоваяДоступность;
	
КонецПроцедуры

Процедура ПсевдонимыПолейИмяПриИзменении(Элемент)
	
	ПриИзмененииИмениПоляОбъединения();
	
КонецПроцедуры

Процедура ПриИзмененииИмениПоляОбъединения(ПолеОбъединения = Неопределено)
	
	Если ПолеОбъединения = Неопределено Тогда
		ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ПолеОбъединения);
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		ИД = ПолеОбъединения["_" + ЧастьОбъединения.Номер];
		Если ЗначениеЗаполнено(ИД) Тогда
			СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Найти(ИД, "ИД");
			СтрокаВыбранногоПоля.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ПоляОбъединения, ПолеОбъединения,, Ложь,
				ПолучитьСловоЯзыкаЗапросов("Field") + "1");
			ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбранногоПоля);
			//Если ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока Тогда
			//	СтрокаВыбранногоПоля = ВыбранныеПоля.Найти(ИД, "ИД");
			//	СтрокаВыбранногоПоля.Имя = Элемент.Значение;
			//КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры


Процедура ДоступныеПоляИндексаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	//СтрокаПоля = ПоляИндекса.Найти(ВыбраннаяСтрока.Имя, "Определение");
	//Если СтрокаПоля = Неопределено Тогда
	//	СтрокаПоля = ПоляИндекса.Добавить();
	//	СтрокаПоля.Определение = ВыбраннаяСтрока.Имя;
	//КонецЕсли; 
	//ЭлементыФормы.ПоляИндекса.ТекущаяСтрока = СтрокаПоля;
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляИндекса);
	
КонецПроцедуры

Процедура ПсевдонимыПолейПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		ИмяКолонки = "Определение" + ЧастьОбъединения.Номер;
		ИДПоля = ДанныеСтроки["_" + ЧастьОбъединения.Номер];
		Если Не ЗначениеЗаполнено(ИДПоля) Тогда
			Продолжить;
		КонецЕсли; 
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ИДПоля, "ИД");
		Если ВыбранноеПоле <> Неопределено Тогда
			ИндексКартинки = ирОбщий.ПолучитьИндексКартинкиТипаЛкс(ВыбранноеПоле.ТипЗначения);
			ОформлениеСтроки.Ячейки[ИмяКолонки].ИндексКартинки = ИндексКартинки;
			ОформлениеСтроки.Ячейки[ИмяКолонки].ОтображатьКартинку = Истина;
			Если ВыбранноеПоле.Автополе Тогда
				ОформлениеСтроки.Ячейки[ИмяКолонки].ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаВычисляемогоЗначения");
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	ирОбщий.ТабличноеПолеПриВыводеСтрокиЛкс(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Процедура ДеревоУсловияСвязиПриИзмененииФлажка(Элемент, Колонка)
	
	Если Элемент.Колонки.Произвольное = Колонка Тогда
		ПереключитьРежимПроизвольногоВыраженияОтбора(Элемент, Колонка);
		ЗагрузитьВыражениеУсловияСвязи();
	КонецЕсли; 

КонецПроцедуры

////////////
// Отбор

Процедура ПереключитьРежимПроизвольногоВыраженияОтбора(ТабличноеПоле, Колонка)

	ТекущееЗначениеФлажка = ТабличноеПоле.ТекущаяСтрока.Представление <> "";
	Если ТекущееЗначениеФлажка Тогда
		ТабличноеПоле.ТекущаяСтрока.Представление = "";
	Иначе
		ТабличноеПоле.ТекущаяСтрока.Представление = ПолучитьВыражениеЭлементаОтбораЛкс(ТабличноеПоле.ТекущаяСтрока);
		ТабличноеПоле.ТекущаяСтрока.ЛевоеЗначение = Неопределено;
		ТабличноеПоле.ТекущаяСтрока.ПравоеЗначение = Неопределено;
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьЭлементОтбораПослеИзменения(Элемент)

	Если ТипЗнч(Элемент.ТекущаяСтрока) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтароеПравоеЗначение = Элемент.ТекущаяСтрока.ПравоеЗначение;
		ПолучитьВыражениеЭлементаОтбораЛкс(Элемент.ТекущаяСтрока);
	КонецЕсли; 

КонецПроцедуры

Процедура КПДоступныеТаблицыОтборБезЗначенияВТекущейКолонке(Кнопка)
	
	ирОбщий.ТабличноеПоле_ОтборБезЗначенияВТекущейКолонке_КнопкаЛкс(ЭлементыФормы.ДоступныеТаблицы);

КонецПроцедуры

Процедура ПараметрыТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Истина
		И Не ЭтоПараметрПериодичность1С(ВыбраннаяСтрока) 
		И Не ЭтоПараметрМетодДополненияПериодов1С(ВыбраннаяСтрока)
	Тогда
		СтандартнаяОбработка = Ложь;
		ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
		ФормаКонструктораВыражения.ТипВыражения = "ПараметрВиртуальнойТаблицы";
		ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Определение;
		ФормаКонструктораВыражения.ШаблонПолноеИмяТаблицы = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока.ПолноеИмя;
		ФормаКонструктораВыражения.ШаблонНомерПараметра = ВыбраннаяСтрока.Номер;
		ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
		Если ЭтоПараметрОтбор1С(ВыбраннаяСтрока) Тогда
			Фрагменты = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ФормаКонструктораВыражения.ШаблонПолноеИмяТаблицы);
			Фрагменты.Удалить(Фрагменты.ВГраница());
			ИмяОсновнойТаблицы = ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(Фрагменты, ".");
			ФормаКонструктораВыражения.ШаблонТекстИз = ИмяОсновнойТаблицы;
			ФормаКонструктораВыражения.КомпоновщикНастроек = ирКэш.КомпоновщикТаблицыМетаданныхЛкс(ИмяОсновнойТаблицы,,,, Истина);
		КонецЕсли; 
		ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
		ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
		РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
		Если РезультатФормы <> Неопределено Тогда
			ВыбраннаяСтрока.Определение = РезультатФормы;
			ЗагрузитьПараметрТаблицы();
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Функция СобратьТекстИЗДляВыраженияУсловия() Экспорт
	
	Результат = "";
	Для Каждого ВыбраннаяТаблица Из ВыбранныеТаблицы Цикл
		Если Результат <> "" Тогда
			Результат = Результат + ",";
		КонецЕсли; 
		ОпределениеТаблицы = ПолучитьОпределениеТаблицы(ВыбраннаяТаблица);
		Результат = Результат + ОпределениеТаблицы;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Процедура ДеревоУсловияВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.Представление = "" Тогда
		Возврат;
	КонецЕсли; 
	СохранитьВыражениеУсловия();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Представление;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Представление = РезультатФормы;
		ЗагрузитьВыражениеУсловия();
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияСвязиВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.Представление = "" Тогда
		Возврат;
	КонецЕсли; 
	СохранитьВыражениеУсловияСвязи();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.АгрегатыЗапрещены = Истина;
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Представление;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Представление = РезультатФормы;
		ЗагрузитьВыражениеУсловияСвязи();
	КонецЕсли; 

КонецПроцедуры

Процедура ПолеТекстаОтображаетПакетПриИзменении(Элемент)
	
	ПересобратьВременныйПолныйТекст();
	ЭлементыФормы.КПТекст.Кнопки.Редактировать.Доступность = ПолеТекстаОтображаетПакет;
	
КонецПроцедуры

Процедура КПТекстОтменитьРедактирование(Кнопка)
	
	ПереключитьРежимРедактированияТекста();
	ПересобратьВременныйПолныйТекст();
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыПеренестиВоВременнуюТаблицу(Кнопка)
	
	ЗапросПакета = ЗапросыПакета.Вставить(ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока));
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЗаполнитьЗначенияСвойств(ЗапросПакета, ТекущаяСтрока.ВложенныйПакет[0]);
	ЗапросПакета.ИмяОсновнойТаблицы = ТекущаяСтрока.Имя;
	ЗапросПакета.ТипЗапроса = 1;
	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	ОбновитьДоступныеВременныеТаблицы();
	ТекущаяСтрока.ПолноеИмя = ТекущаяСтрока.Имя;
	ТекущаяСтрока.ВложенныйПакет = Неопределено;
	ТекущаяСтрока.ДляИзменения = Ложь;
	ОбновитьРежимПакетногоЗапроса();
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговИмяПриИзменении(Элемент)
	
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.ГруппирующиеПоляИтогов.ТекущаяСтрока);
	
КонецПроцедуры

Процедура ОсновныеДействияФормыПроверить(Кнопка)
	
	СохранитьЧастьОбъединения();
	ОбновитьВсеВыраженияСИндикацией();
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыЗаменитьТаблицу(Кнопка)
	
	Если мТекущаяСтрокаВыбранныеТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ТекущаяДоступнаяТаблица = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяДоступнаяТаблица = Неопределено Тогда
		Предупреждение("Необходимо активизировать строку доступной таблицы, на которую заменить", 20);
		Возврат;
	КонецЕсли; 
	Ответ = Вопрос("Вы действительно хотите заменить определение таблицы """ + мТекущаяСтрокаВыбранныеТаблицы.Имя + """
		|с " + мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя + " на " + ТекущаяДоступнаяТаблица.ПолноеИмя + "?", РежимДиалогаВопрос.ОКОтмена);
	Если Ответ = КодВозвратаДиалога.ОК Тогда
		мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя = ТекущаяДоступнаяТаблица.ПолноеИмя;
		мТекущаяСтрокаВыбранныеТаблицы.ВложенныйПакет = Неопределено;
		мТекущаяСтрокаВыбранныеТаблицы.ДляИзменения = Ложь;
		Ответ = Вопрос("Хотите сразу обновить псевдоним на автогенерируемый?", РежимДиалогаВопрос.ДаНет);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			мТекущаяСтрокаВыбранныеТаблицы.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, ТекущаяДоступнаяТаблица.Имя + "Т");
			ВыбранныеТаблицыИмяПриИзменении();
		КонецЕсли; 
		ЗагрузитьВыбраннуюТаблицу();
		ОбновитьКомпоновщикЧастиОбъединения();
		Если мТекущаяСтрокаВыбранныеТаблицы.ВсеПоля Тогда
			УдалитьАвтоПоляТаблицыИзВыбранныхПолей(мТекущаяСтрокаВыбранныеТаблицы.Имя, Ложь);
			ДобавитьВсеПоляТаблицыВВыбранныеПоля(мТекущаяСтрокаВыбранныеТаблицы.Имя);
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередУдалением(Элемент, Отказ)

	Ответ = Вопрос("Вы действительно хотите удалить из выбранных таблиц """ + мТекущаяСтрокаВыбранныеТаблицы.Имя + """?", РежимДиалогаВопрос.ОКОтмена);
	Если Ответ <> КодВозвратаДиалога.ОК Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	СтрокаСвязи = СвязиТаблиц.Строки.Найти(мТекущаяСтрокаВыбранныеТаблицы.Имя, "Таблица", Истина);
	УдалитьСтрокуСвязиТаблиц(СтрокаСвязи);
	НачальноеКоличество = ВыбранныеПоля.Количество(); 
	Для СчетчикВыбранныеПоля = 1 По НачальноеКоличество Цикл
		ВыбранноеПоле = ВыбранныеПоля[НачальноеКоличество - СчетчикВыбранныеПоля];
		Если Истина
			И ЛиВыражениеЯвляетсяПолем(ВыбранноеПоле.Определение)
			И ирОбщий.СтрокиРавныЛкс(ирОбщий.ПолучитьПервыйФрагментЛкс(ВыбранноеПоле.Определение), мТекущаяСтрокаВыбранныеТаблицы.Имя)
		Тогда
			СтрокаПоляОбъединенияПоИмени = ПоляОбъединения.Найти(НРег(ВыбранноеПоле.Имя), "НИмя");
			ПоляОбъединения.Удалить(СтрокаПоляОбъединенияПоИмени);
			ВыбранныеПоля.Удалить(ВыбранноеПоле);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьСтрокуСвязиТаблиц(СтрокаСвязи)
	
	РодительСтроки = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(СтрокаСвязи);
	Если СтрокаСвязи.Строки.Количество() > 0 Тогда
		ТекущийРодительСтроки = РодительСтроки;
		Для Каждого ДочерняяСтрока Из СтрокаСвязи.Строки Цикл
			НоваяСтрока = ТекущийРодительСтроки.Строки.Добавить();
			СкопироватьСтрокуСвязиТаблиц(ДочерняяСтрока, НоваяСтрока);
			ОбновитьТипСвязиТаблицПослеИзмененияИерархии(НоваяСтрока);
			Если ТекущийРодительСтроки = СвязиТаблиц Тогда
				ТекущийРодительСтроки = НоваяСтрока;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	РодительСтроки.Строки.Удалить(СтрокаСвязи);

КонецПроцедуры

Процедура ВыбранныеТаблицыПриИзмененииФлажка(Элемент, Колонка)
	
	Если Колонка = ЭлементыФормы.ВыбранныеТаблицы.Колонки.ВсеПоля Тогда
		Если Элемент.ТекущаяСтрока[Колонка.ДанныеФлажка] Тогда
			ДобавитьВсеПоляТаблицыВВыбранныеПоля(Элемент.ТекущаяСтрока.Имя,,,, Истина);
		Иначе
			УдалитьАвтоПоляТаблицыИзВыбранныхПолей(Элемент.ТекущаяСтрока.Имя);
		КонецЕсли; 
	ИначеЕсли Колонка = ЭлементыФормы.ВыбранныеТаблицы.Колонки.Обязательная Тогда
		Если Элемент.ТекущаяСтрока[Колонка.ДанныеФлажка] Тогда
			Элемент.ТекущаяСтрока.НомерГруппы = 0;
		Иначе
			Элемент.ТекущаяСтрока.НомерГруппы = 1;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура УдалитьАвтоПоляТаблицыИзВыбранныхПолей(Знач ИмяТаблицы, ТолькоОтключить = Истина)
	
	НачальноеКоличество = ВыбранныеПоля.Количество(); 
	Для СчетчикВыбранныеПоля = 1 По НачальноеКоличество Цикл
		ВыбранноеПоле = ВыбранныеПоля[НачальноеКоличество - СчетчикВыбранныеПоля];
		Если Ложь
			Или Не ПараметрыДиалектаSQL.МногоТаблиц 
			Или (Истина
				И ирОбщий.СтрокиРавныЛкс(ирОбщий.ПолучитьПервыйФрагментЛкс(ВыбранноеПоле.Определение), ИмяТаблицы)
				И ВыбранноеПоле.Автополе)
		Тогда
			Если ТолькоОтключить Тогда
				ВыбранноеПоле.Автополе = Ложь;
			Иначе
				ВыбранныеПоля.Удалить(ВыбранноеПоле);
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ВыбранныеПоляПередУдалением(Элемент, Отказ)
	
	Отказ = Элемент.ТекущаяСтрока.Автополе;

КонецПроцедуры

Процедура ВыбранныеПоляПередНачаломИзменения(Элемент, Отказ)
	
	Отказ = Элемент.ТекущаяСтрока.Автополе;

КонецПроцедуры

//Процедура ДоступныеПоляВыбораПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
//	
//	Если ЭтоНедоступноеДоступноеПоле(ДанныеСтроки) Тогда
//		ОформлениеСтроки.Ячейки.Заголовок.УстановитьТекст("<Недоступно>");
//	КонецЕсли; 

//КонецПроцедуры

Функция ЭтоНедоступноеДоступноеПоле(ДоступноеПоле)
	
	Результат = Ложь
		Или ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + ДоступноеПоле.Поле)
		Или (Истина
			И ДоступноеПоле.Родитель <> Неопределено
			И ирОбщий.СтрокиРавныЛкс("СистемныеПоля", "" + ДоступноеПоле.Родитель.Поле));
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	
	
КонецПроцедуры

Процедура ПараметрыТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ТипЗнч(ДанныеСтроки) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если ДанныеСтроки.Представление <> "" Тогда
			Возврат;
		КонецЕсли; 
		Токен = ДанныеСтроки.ПравоеЗначение;
	ИначеЕсли ТипЗнч(ДанныеСтроки) = Тип("СтрокаТаблицыЗначений") Тогда
		Токен = ДанныеСтроки.Токен;
	Иначе
		Возврат;
	КонецЕсли; 
	//Если Токен = Неопределено Тогда
	//	ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаОшибки");
	//КонецЕсли; 

КонецПроцедуры

Процедура ГруппировкиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ПоляПорядкаПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриАктивизацииСтроки(Элемент)
	
	СохранитьГруппируемоеПоле();
	ЗагрузитьГруппируемоеПоле();
	
КонецПроцедуры

Процедура СохранитьГруппируемоеПоле()
	
	Если мТекущаяСтрокаГруппируемогоПоля = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ГруппируемыеПоляИтогов.Индекс(мТекущаяСтрокаГруппируемогоПоля) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаГруппируемогоПоля.Определение = ЭлементыФормы.ВыражениеГруппируемогоПоля.ПолучитьТекст();
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаГруппируемогоПоля,,,,,,,, Ложь);

КонецПроцедуры

Процедура ЗагрузитьГруппируемоеПоле()
	
	мТекущаяСтрокаГруппируемогоПоля = ЭлементыФормы.ГруппируемыеПоляИтогов.ТекущаяСтрока;
	Если мТекущаяСтрокаГруппируемогоПоля = Неопределено Тогда
		ВыражениеПоля = "";
		РазрешеноИзменение = Ложь;
	Иначе
		ВыражениеПоля = мТекущаяСтрокаГруппируемогоПоля.Определение;
		РазрешеноИзменение = Истина;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст(ВыражениеПоля);
	ЭлементыФормы.ВыражениеГруппируемогоПоля.Доступность = РазрешеноИзменение;
	
КонецПроцедуры

Процедура ГруппировкиПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		//ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст(мТекущаяСтрокаГруппируемогоПоля.Представление);
		ОбновитьВыражениеЗапроса(Элемент.ТекущиеДанные);
	КонецЕсли; 
	
КонецПроцедуры

Процедура АвтогруппировкиПриИзменении(Элемент)
	
	ОбновитьГруппировки(Истина);
	
КонецПроцедуры

Процедура ВыбранныеПоляАгрегатнаяФункцияПриИзменении(Элемент)
	
	ТокенАргументаФункции = Неопределено;
	ТекущаяАгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(мТекущаяСтрокаВыбранногоПоля.Токен, ТокенАргументаФункции); 
	Если ТокенАргументаФункции <> Неопределено Тогда
		ВыражениеПоля = СобратьВыражениеЗапроса(ТокенАргументаФункции);
	Иначе
		ВыражениеПоля = мТекущаяСтрокаВыбранногоПоля.Токен;
	КонецЕсли; 
	Если ЗначениеЗаполнено(Элемент.Значение) Тогда
		ВыражениеПоля = Элемент.Значение + ВыражениеПоля + ")";
	КонецЕсли; 
	мТекущаяСтрокаВыбранногоПоля.Определение = ВыражениеПоля;
	ВыбранныеПоляОпределениеПриИзменении();
	
КонецПроцедуры

Процедура ВыбранныеПоляОпределениеПриИзменении(Элемент = Неопределено)
	
	ПриИзмененииВыраженияВыбранногоПоля();
	
КонецПроцедуры

Процедура ОсновныеДействияФормыКонструкторЗапроса(Кнопка)
	
	Если Не мРежимРедактированияТекста Тогда
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	Компонента = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ЭлементыФормы.ПолеТекстаЗапроса.Имя];
	Компонента.ВызватьКонструкторЗапросов(Истина);
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговАгрегатнаяФункцияПриИзменении(Элемент = Неопределено)
	
	ТокенАргументаФункции = Неопределено;
	ТекущаяАгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(мТекущаяСтрокаГруппируемогоПоля.Токен, ТокенАргументаФункции); 
	ВыражениеПоля = СобратьВыражениеЗапроса(ТокенАргументаФункции,,,,,,, Ложь);
	Если ЗначениеЗаполнено(мТекущаяСтрокаГруппируемогоПоля.АгрегатнаяФункция) Тогда
		ВыражениеПоля = мТекущаяСтрокаГруппируемогоПоля.АгрегатнаяФункция + ВыражениеПоля + ")";
	КонецЕсли; 
	мТекущаяСтрокаГруппируемогоПоля.Определение = ВыражениеПоля;
	ПриИзмененииВыраженияГруппируемогоПоля();

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговОпределениеПриИзменении(Элемент)
	
	ПриИзмененииВыраженияГруппируемогоПоля();

КонецПроцедуры

Процедура ПриИзмененииВыраженияГруппируемогоПоля(ГруппируемоеПоле = Неопределено, ЗапросПакета = Неопределено)

	Если ГруппируемоеПоле = Неопределено Тогда
		ГруппируемоеПоле = мТекущаяСтрокаГруппируемогоПоля;
	КонецЕсли; 
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	ЕстьАгрегаты = Ложь;
	ОбновитьВыражениеЗапроса(ГруппируемоеПоле,,,,,,, ЕстьАгрегаты, Ложь);
	//ВыбранноеПоле.ТипЗначения = ПолучитьТипЗначенияВыражения(ГруппируемоеПоле.Токен);
	ГруппируемоеПоле.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ГруппируемоеПоле.Токен);
	//ГруппируемоеПоле.ЕстьАгрегаты = ЕстьАгрегаты;
	ЗагрузитьГруппируемоеПоле();

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)

	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеВГруппируемыеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеВГруппируемыеПоля(ПолеОбъединения)

	Если Ложь
		Или ЗначениеЗаполнено(ПолеОбъединения.РольИтога) 
		Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
	Тогда
		Возврат;
	КонецЕсли; 
	ТабличноеПоле = ЭлементыФормы.ГруппируемыеПоляИтогов;
	СтрокаГруппируемогоПоля = ГруппируемыеПоляИтогов.Найти(ПолеОбъединения.Имя, "Имя");
	Если СтрокаГруппируемогоПоля = Неопределено Тогда
		СтрокаГруппируемогоПоля = ГруппируемыеПоляИтогов.Добавить();
		АгрегатнаяФункция = "COUNT(DISTINCT ";
		Если ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			АгрегатнаяФункция = "SUM(";
		ИначеЕсли Ложь
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Булево"))
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Строка"))
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Дата"))
		Тогда
			АгрегатнаяФункция = "MAX(";
		КонецЕсли; 
		СтрокаГруппируемогоПоля.Определение = АгрегатнаяФункция + ПолеОбъединения.Имя + ")";
		СтрокаГруппируемогоПоля.Имя = ПолеОбъединения.Имя;
		ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаГруппируемогоПоля);
		//ПолеОбъединения.РольИтога = 2; // так не будет работать, т.к. при перетаскивании созадается копия строки
		ОбновитьРолиИтогов();
	КонецЕсли; 
	ТабличноеПоле.ТекущаяСтрока = СтрокаГруппируемогоПоля;
	ПриИзмененииВыраженияГруппируемогоПоля(); // Надо делать после активизации строки

КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПослеУдаления(Элемент)
	
	ОбновитьРолиИтогов();
	
КонецПроцедуры

Процедура ОбновитьРолиИтогов(ЗапросПакета = Неопределено)
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	ЗапросПакета.ПоляОбъединения.ЗаполнитьЗначения(Неопределено, "РольИтога");
	Для Каждого ГруппирующееПоле Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		ПолеОбъединения = ЗапросПакета.ПоляОбъединения.Найти(Нрег(ГруппирующееПоле.Определение), "НИмя");
		Если ПолеОбъединения <> Неопределено Тогда
			ПолеОбъединения.РольИтога = 1;
		КонецЕсли; 
	КонецЦикла;
	Для Каждого ГруппируемоеПоле Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		ПолеОбъединения = ЗапросПакета.ПоляОбъединения.Найти(НРег(ГруппируемоеПоле.Имя), "НИмя");
		Если ПолеОбъединения <> Неопределено Тогда
			ПолеОбъединения.РольИтога = 2;
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ЗначениеЗаполнено(ДанныеСтроки.РольИтога) Тогда
		ОформлениеСтроки.ЦветФона = ирОбщий.ПолучитьЦветСтиляЛкс("ирЦветФонаЧередованияСтрок");
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьПолеОбъединенияВГруппирующиеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура ДоступныеПоляГруппировокВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеВГруппировки(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеВГруппировки(ДоступноеПоле)
	
	Если Автогруппировки Тогда
		Возврат;
	КонецЕсли; 
	//Если ЭтоНедоступноеДоступноеПоле(ВыбраннаяСтрока) Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ДоступноеПоле.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения")) Тогда
		Возврат;
	КонецЕсли; 
	СтандартнаяОбработка = Ложь;
	ОпределениеПоля = ПолучитьПолноеИмяДоступногоПоля(ДоступноеПоле);
	СтрокаГруппировки = Группировки.Найти(ОпределениеПоля, "Определение");
	Если СтрокаГруппировки = Неопределено Тогда
		СтрокаГруппировки = Группировки.Добавить();
		СтрокаГруппировки.Определение = ОпределениеПоля;
		ОбновитьВыражениеЗапроса(СтрокаГруппировки, ЭлементыФормы.Группировки);
	КонецЕсли; 
	ЭлементыФормы.Группировки.ТекущаяСтрока = СтрокаГруппировки;

КонецПроцедуры

Процедура ВыбранныеПоляОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьВыбранноеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ВыбранноеПоле";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПриИзмененииВыраженияВыбранногоПоля();
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьГруппируемоеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ПолеИтога";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЗапроса; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПриИзмененииВыраженияГруппируемогоПоля();
	КонецЕсли; 

КонецПроцедуры

Процедура ВыбранныеПоляПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если Не НоваяСтрока Тогда
		СохранитьВыбранноеПоле();
	КонецЕсли;
	Если НоваяСтрока Тогда
		Элемент.ТекущаяСтрока.ИД = Новый УникальныйИдентификатор;
		ЗагрузитьВыбранноеПоле();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если Не НоваяСтрока Тогда
		СохранитьГруппируемоеПоле();
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ПоляПорядкаПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура КомментарийНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	ирОбщий.ПолеВводаТекста_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка);
	
КонецПроцедуры

Процедура ВыбранныеПоляИмяПриИзменении(Элемент)
	
	СтрокаПоляОбъединенияПоИмени = ПоляОбъединения.Найти(НРег(мТекущаяСтрокаВыбранногоПоля.Имя), "НИмя");
	СтрокаПоляОбъединенияПоИД = ПоляОбъединения.Найти(мТекущаяСтрокаВыбранногоПоля.ИД, "_" + мТекущаяСтрокаЧастиОбъединения.Номер);
	Если СтрокаПоляОбъединенияПоИмени <> СтрокаПоляОбъединенияПоИД Тогда // заработало в 3.19, ранее ошибочно всегда не выполнялось
		Если СтрокаПоляОбъединенияПоИмени = Неопределено Тогда
			// Разделение полей
			НовоеИмя = мТекущаяСтрокаВыбранногоПоля.Имя;
			СтароеИмя = СтрокаПоляОбъединенияПоИД.Имя;
			СтрокаПоляОбъединенияПоИД.Имя = мТекущаяСтрокаВыбранногоПоля.Имя;
			ПриИзмененииИмениПоляОбъединения(СтрокаПоляОбъединенияПоИД);
			Если ТипЗапроса = 1 Тогда // Создание временной таблицы
				ПереименоватьТаблицуИлиПараметр(, ИмяОсновнойТаблицы, ИмяОсновнойТаблицы, СтароеИмя, НовоеИмя, Истина);
			КонецЕсли; 
		Иначе
			// Склеивание полей
			СтрокаПоляОбъединенияПоИмени["_" + мТекущаяСтрокаЧастиОбъединения.Номер] = мТекущаяСтрокаВыбранногоПоля.ИД;
			ОбновитьТипЗначенияПоляОбъединения(, СтрокаПоляОбъединенияПоИмени);
			Если СтрокаПоляОбъединенияПоИД.Монополе Тогда
				ПоляОбъединения.Удалить(СтрокаПоляОбъединенияПоИД);
			Иначе
				СтрокаПоляОбъединенияПоИД["_" + мТекущаяСтрокаЧастиОбъединения.Номер] = Неопределено;
				ОбновитьТипЗначенияПоляОбъединения(, СтрокаПоляОбъединенияПоИД);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура СвязиТаблицПослеУдаления(Элемент)
	
	ЗагрузитьСвязьТаблицы();
	
КонецПроцедуры

// Параметры:
//  Тип - Число -
//           0 - Элемент
//           1 - Выражение
//           2 - Группа-И
//           3 - Группа-Или
//           4 - Группа-Не
//
Процедура ДобавитьСтрокуВТабличноеПолеОтбора(ТабличноеПолеОтбора, Тип = 0)
	
	ТекущаяСтрокаОтбора = ТабличноеПолеОтбора.ТекущаяСтрока;
	Если Тип > 1 Тогда
		ТипСтроки = Тип("ГруппаЭлементовОтбораКомпоновкиДанных");
	Иначе
		ТипСтроки = Тип("ЭлементОтбораКомпоновкиДанных");
	КонецЕсли; 
	Если ТекущаяСтрокаОтбора = Неопределено Тогда
		ТекущаяСтрокаОтбора = ТабличноеПоле.Значение;
	КонецЕсли; 
	Если Ложь
		Или ТипЗнч(ТекущаяСтрокаОтбора) = Тип("ОтборКомпоновкиДанных") 
		Или ТипЗнч(ТекущаяСтрокаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
	Тогда
		НоваяСтрока = ТекущаяСтрокаОтбора.Элементы.Добавить(ТипСтроки);
	Иначе
		Родитель = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(ТекущаяСтрокаОтбора, ТабличноеПолеОтбора.Значение);
		НоваяСтрока = Родитель.Элементы.Добавить(ТипСтроки);
	КонецЕсли;
	Если ТипСтроки = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда 
		Если Тип = 2 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
		ИначеЕсли Тип = 3 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
		ИначеЕсли Тип = 4 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
		КонецЕсли; 
	КонецЕсли; 
	Если Тип = 1 Тогда
		НоваяСтрока.Представление = " ";
	КонецЕсли; 
	ТабличноеПолеОтбора.ТекущаяСтрока = НоваяСтрока;
	ТабличноеПолеОтбора.ИзменитьСтроку();

КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьЭлемент(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 0);

КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьГруппуИ(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 2);
	
КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьГруппуИли(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 3);
	
КонецПроцедуры

Процедура КПДеревоУсловияДобавитьЭлемент(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 0);
	
КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьВыражение(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 1);
	
КонецПроцедуры

Процедура КПДеревоУсловияДобавитьВыражение(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 1);

КонецПроцедуры

Процедура КПДеревоУсловияДобавитьГруппуИ(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 2);

КонецПроцедуры

Процедура КПДеревоУсловияДобавитьГруппуИли(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 3);

КонецПроцедуры

Процедура ПараметрыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.Параметры.Колонки.Значение Тогда
		ирОбщий.ЯчейкаТабличногоПоляРасширенногоЗначения_ВыборЛкс(Элемент, СтандартнаяОбработка);
	КонецЕсли; 
	
КонецПроцедуры

Процедура СтруктураКоманднойПанелиНажатие(Кнопка)
	
	ирОбщий.ОткрытьСтруктуруКоманднойПанелиЛкс(ЭтаФорма, Кнопка);
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыПреобразоватьВПодзапрос(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЗапросыВложенногоПакета = ЗапросыПакета.СкопироватьКолонки();
	ВложенныйЗапрос = ДобавитьЗапросПакета(ЗапросыВложенногоПакета);
	ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(ТекущаяСтрока.ПолноеИмя);
	ДоступнаяТаблица = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
	ЗапросСформирован = Ложь;
	Если Истина
		И ДоступнаяТаблица <> Неопределено
		И ДоступнаяТаблица.Тип = "ВременнаяТаблица" 
	Тогда
		ПородившаяСтрокаПакета = ЗапросыПакета.Найти(ДоступнаяТаблица.ПородившийЗапрос, "ИД");
		Если ПородившаяСтрокаПакета <> Неопределено Тогда
			Ответ = Вопрос("Хотите заменить обращение к временной таблице ее определением?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Нет);
			Если Ответ = КодВозвратаДиалога.Да Тогда
				СкопироватьЗапрос(ПородившаяСтрокаПакета, ВложенныйЗапрос);
				ВложенныйЗапрос.ТипЗапроса = 1;
				ЗапросСформирован = Истина;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	Если Не ЗапросСформирован Тогда
		ВложеннаяЧастьОбъединения = ДобавитьЧастьОбъединения(ВложенныйЗапрос);
		СтрокаВыбраннойТаблицы = ВложеннаяЧастьОбъединения.ВыбранныеТаблицы.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаВыбраннойТаблицы, ТекущаяСтрока); // Опасно. Копируем ссылку на таблицу Параметры
		НайтиДобавитьВыбраннуюТаблицуВСвязи(СтрокаВыбраннойТаблицы, ВложеннаяЧастьОбъединения);
		ОбновитьКомпоновщикЧастиОбъединения(ВложеннаяЧастьОбъединения);
		СтрокаВыбраннойТаблицы.ВсеПоля = Истина;
		ДобавитьВсеПоляТаблицыВВыбранныеПоля(ТекущаяСтрока.Имя, ВложенныйЗапрос, ВложеннаяЧастьОбъединения);
	КонецЕсли;
	ТекущаяСтрока.ВложенныйПакет = ЗапросыВложенногоПакета;
	ТекущаяСтрока.ДляИзменения = Ложь;
	ТекущаяСтрока.ПолноеИмя = "";
	ТекущаяСтрока.Комментарий = "";
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущаяСтрока);
	ТекущаяСтрока.Параметры = ПараметрыТаблицы.СкопироватьКолонки();
	ЗагрузитьВыбраннуюТаблицу();
	ОткрытьВложенныйПакет(ТекущаяСтрока.ВложенныйПакет, ТекущаяСтрока.Имя);
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыВстроитьИзПодзапроса(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЗапросПакета = ТекущаяСтрока.ВложенныйПакет[0];
	ПроверкаУспешна = Истина
		И ЗапросПакета.ЧастиОбъединения.Количество() = 1
		И ЗапросПакета.ЧастиОбъединения[0].ВыбранныеТаблицы.Количество() = 1
		И ЗапросПакета.ЧастиОбъединения[0].ВыбранныеТаблицы[0].ВсеПоля = Истина;
	Если Не ПроверкаУспешна Тогда 
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Допускается встройка только выборки вида ""ВЫБРАТЬ * ИЗ <ОпределениеТаблицы> [[КАК] <ПсевдонимТаблицы>]", МодальныйРежим);
		Возврат;
	КонецЕсли; 
	СтрокаВыбраннойТаблицы = ЗапросПакета.ЧастиОбъединения[0].ВыбранныеТаблицы[0];
	ЗаполнитьЗначенияСвойств(ТекущаяСтрока, СтрокаВыбраннойТаблицы, "ВложенныйПакет, ПолноеИмя, Параметры"); 
	ирОбщий.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущаяСтрока);
	ЗагрузитьВыбраннуюТаблицу();
	
КонецПроцедуры

Процедура КПДоступныеТаблицыДобавить(Кнопка)

	ИмяДоступнойТаблицы = "";
	Если ВвестиСтроку(ИмяДоступнойТаблицы, "Укажите имя временной таблицы") Тогда
		СтрокаДоступнойТаблицы = НайтиДобавитьДоступнуюВременнуюТаблицу(ИмяДоступнойТаблицы);
		ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = СтрокаДоступнойТаблицы;
		ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц()
	
	ЭлементФормы = ЭлементыФормы.ПанельДоступныеТаблицы;
	Для Каждого Страница Из ЭлементФормы.Страницы Цикл
		Если Страница.Имя = "Все" Тогда
			Продолжить;
		КонецЕсли; 
		СтруктураОтбора = Новый Структура("Тип", Страница.Имя);
		Количество = ДоступныеТаблицы.НайтиСтроки(СтруктураОтбора).Количество();
		ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(Страница.Заголовок, , "" + Количество + ")", "(");
	КонецЦикла;

КонецПроцедуры

Процедура ПанельДоступныеТаблицыПриСменеСтраницы(Элемент, ТекущаяСтраница)
	
	ОбновитьОтборПоСтраницеДоступныхТаблиц();
	
КонецПроцедуры

Процедура ОбновитьОтборПоСтраницеДоступныхТаблиц()
	
	ЭлементОтбора = ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Тип;
	ЭлементОтбора.Установить(ЭлементыФормы.ПанельДоступныеТаблицы.ТекущаяСтраница.Имя);
	ЭлементОтбора.Использование = ЭлементыФормы.ПанельДоступныеТаблицы.ТекущаяСтраница <> ЭлементыФормы.ПанельДоступныеТаблицы.Страницы.Все;
	
КонецПроцедуры

Процедура ДоступныеПоляВыбораПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляВыбораПостроителя);

КонецПроцедуры

Процедура ДоступныеПоляУсловияПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляОтбораПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляИтоговПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляИтоговПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляПорядкаПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядкаПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляВыбораПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляВыбораПостроителя);

КонецПроцедуры

Процедура ДоступныеВыбранныеПоляОтбораПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляОтбораПостроителя,,,, "Определение");
	
КонецПроцедуры

Процедура ОбновитьСтрокуПоляПостроителя(СтрокаПоляПостроителя, ЭтоНоваяСтрока = Ложь, РазрешитьНормализациюИмен = Ложь, ТипЗначения = Неопределено)
	
	ОбновитьВыражениеЗапроса(СтрокаПоляПостроителя,,,,,,,, РазрешитьНормализациюИмен);
	Если СтрокаПоляПостроителя.Владелец().Колонки.Найти("ТипЗначения") <> Неопределено Тогда
		Если ТипЗначения = Неопределено Тогда
			ТипЗначения = ПолучитьТипЗначенияВыражения(СтрокаПоляПостроителя.Токен);
		КонецЕсли; 
		СтрокаПоляПостроителя.ТипЗначения = ТипЗначения;
		Если СтрокаПоляПостроителя.Владелец().Колонки.Найти("ИспользоватьДочерние") <> Неопределено Тогда
			Если ЭтоНоваяСтрока Тогда
				Для Каждого Тип Из ТипЗначения.Типы() Цикл
					Если мПлатформа.мМетаданные.НайтиПоТипу(Тип) <> Неопределено Тогда
						СтрокаПоляПостроителя.ИспользоватьДочерние = Истина;
					КонецЕсли; 
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
		
КонецПроцедуры

Процедура ПоляВыбораПостроителяОпределениеПриИзменении(Элемент)
	
	ОбновитьСтрокуПоляПостроителя(ЭлементыФормы.ПоляВыбораПостроителя.ТекущаяСтрока);
	//Если мТекущаяСтрокаВыбранногоПоля = СтрокаПоля Тогда
	//	ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(мТекущаяСтрокаВыбранногоПоля.Определение);
	//КонецЕсли; 
	
КонецПроцедуры

Процедура ПоляПостроителяПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляИтоговПостроителя);

КонецПроцедуры

Процедура ДоступныеПоляПорядкаПостроителяВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(ВыбраннаяСтрока, ЭлементыФормы.ПоляПорядкаПостроителя);

КонецПроцедуры

Процедура ПоляПостроителяПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если РазрешеноПеретаскиваниеВПоля(ЗначениеПеретаскивания[0]) Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеСДочернимиВТабличноеПоле(СтрокаПеретаскивания, Элемент);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура ПоляВыбораПостроителяПриАктивизацииСтроки(Элемент)
	
	ЭлементыФормы.ВыражениеВыбранногоПоляПостроителя.УстановитьТекст(Элемент.ТекущаяСтрока.Определение);
	
КонецПроцедуры

Процедура ПоляОтбораПостроителяПриАктивизацииСтроки(Элемент)
	
	ЭлементыФормы.ВыражениеУсловияПостроителя.УстановитьТекст(Элемент.ТекущаяСтрока.Определение);

КонецПроцедуры

Процедура ПоляОтбораПостроителяОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьВыражениеУсловия();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПоляОтбораПостроителяОпределениеПриИзменении(Элемент);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПоляВыбораПостроителяОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьВыбранноеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ВыбранноеПоле";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПоляВыбораПостроителяОпределениеПриИзменении(Элемент);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПоляОтбораПостроителяОпределениеПриИзменении(Элемент)
	
	ОбновитьСтрокуПоляПостроителя(ЭлементыФормы.ПоляОтбораПостроителя.ТекущаяСтрока);
	
КонецПроцедуры

Процедура КПТекстСравнить(Кнопка)
	
	ирОбщий.СравнитьСодержимоеЭлементаУправленияЛкс(ЭлементыФормы.ПолеТекстаЗапроса);

КонецПроцедуры

Процедура ПриЗакрытии()
	
	//ирОбщий.СохранитьЗначениеЛкс("КонструкторЗапроса.ПоказыватьИндексы", ПоказыватьИндексы);
	ирОбщий.СохранитьЗначениеЛкс("КонструкторЗапроса.ИерархическийСтильЛогическихВыражений", ИерархическийСтильЛогическихВыражений);

	// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
	// Уничтожение всех экземпляров компоненты. Обязательный блок.
	Для Каждого Экземпляр Из ПолеТекстовогоДокументаСКонтекстнойПодсказкой Цикл
		Экземпляр.Значение.Уничтожить();
	КонецЦикла;
	// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой

КонецПроцедуры

Процедура ДеревоУсловияСвязиПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если ТипЗнч(Элемент.ТекущаяСтрока) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если Элемент.ТекущаяСтрока.ЛевоеЗначение = Неопределено Тогда
			Если ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока <> Неопределено Тогда
				Элемент.ТекущаяСтрока.ЛевоеЗначение = ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока.Поле;
			КонецЕсли; 
		КонецЕсли; 
		Если Элемент.ТекущаяСтрока.ПравоеЗначение = Неопределено Тогда
			Если ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока <> Неопределено Тогда
				Элемент.ТекущаяСтрока.ПравоеЗначение = ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока.Поле;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	мТекущееИмяПараметра = Элемент.ТекущиеДанные.Имя;
	
КонецПроцедуры

Процедура ГруппировкиПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	МассивЗначений = Неопределено;
    ТипЗначенияПеретаскивания = Неопределено;
    ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если РазрешеноПеретаскиваниеВПоля(МассивЗначений[0]) Тогда
		СтандартнаяОбработка = Ложь;
		Для Каждого СтрокаПеретаскивания Из МассивЗначений Цикл
			ДобавитьДоступноеПолеВГруппировки(СтрокаПеретаскивания);
		КонецЦикла;  
	КонецЕсли;

КонецПроцедуры

Процедура ГруппировкиПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	Если Автогруппировки Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.НеОбрабатывать;
		Возврат;
	КонецЕсли; 
	МассивЗначений = Неопределено;
    ТипЗначенияПеретаскивания = Неопределено;
    ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если РазрешеноПеретаскиваниеВПоля(МассивЗначений[0]) Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
	КонецЕсли;

КонецПроцедуры

Процедура СвязиТаблицПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
    ТипЗначенияПеретаскивания = Неопределено;
	МассивЗначений = Неопределено;
    ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если ТипЗначенияПеретаскивания = Тип("СтрокаДереваЗначений") Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Перемещение;
		//Если Строка <> Неопределено Тогда
		//	Для Каждого ПеретаскиваемаяСтрока Из МассивЗначений Цикл
		//		ВсеДочениеСтроки = ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(ПеретаскиваемаяСтрока);
		//		Если ВсеДочениеСтроки.Найти(Строка) <> Неопределено Тогда
		//			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.НеОбрабатывать;
		//			ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Отмена;
		//			Прервать;
		//		КонецЕсли; 
		//	КонецЦикла;
		//КонецЕсли; 
	ИначеЕсли ТипЗначенияПеретаскивания = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтандартнаяОбработка = Ложь;
		ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.КопированиеИПеремещение;
	КонецЕсли; 
	
КонецПроцедуры

Процедура СвязиТаблицПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	Элемент = ЭлементыФормы.СвязиТаблиц; // Для подсказки
	//СтандартнаяОбработка = Ложь;
	МассивЗначений = Неопределено;
	ТипЗначенияПеретаскивания = Неопределено;
	ирОбщий.ПолучитьМассивЗначенийПеретаскиванияЛкс(ПараметрыПеретаскивания, МассивЗначений, ТипЗначенияПеретаскивания);
	Если ТипЗначенияПеретаскивания = Тип("СтрокаДереваЗначений") Тогда
		РодительСтроки = Строка;
		Если РодительСтроки = Неопределено Тогда
			РодительСтроки = СвязиТаблиц;
		КонецЕсли; 
		МассивИменТаблиц = Новый Массив;
		Для Каждого ПеретаскиваемаяСтрока Из МассивЗначений Цикл
			МассивИменТаблиц.Добавить(ПеретаскиваемаяСтрока.Таблица);
		КонецЦикла; 
		Для Каждого ИмяПеретаскиваемойТаблицы Из МассивИменТаблиц Цикл
			ПеретаскиваемаяСтрока = СвязиТаблиц.Строки.Найти(ИмяПеретаскиваемойТаблицы, "Таблица", Истина);
			КопияПеретаскиваемойСтроки = СвязиТаблиц.Строки.Добавить();
			//СкопироватьСтрокуСвязиТаблиц(ПеретаскиваемаяСтрока, КопияПеретаскиваемойСтроки, РодительСтроки);
			ЗаполнитьЗначенияСвойств(КопияПеретаскиваемойСтроки, ПеретаскиваемаяСтрока); 
			КлючРодителя = Неопределено;
			Если ТипЗнч(РодительСтроки) = Тип("СтрокаДереваЗначений") Тогда
				КлючРодителя = РодительСтроки.Таблица;
			КонецЕсли; 
			УдалитьСтрокуСвязиТаблиц(ПеретаскиваемаяСтрока);
			Если КлючРодителя = Неопределено Тогда
				РодительСтроки = СвязиТаблиц;
			Иначе
				РодительСтроки = СвязиТаблиц.Строки.Найти(КлючРодителя, "Таблица", Истина);
			КонецЕсли; 
			НоваяСтрока = РодительСтроки.Строки.Добавить();
			//СкопироватьСтрокуСвязиТаблиц(КопияПеретаскиваемойСтроки, НоваяСтрока);
			ЗаполнитьЗначенияСвойств(НоваяСтрока, КопияПеретаскиваемойСтроки); 
			Если КлючРодителя = Неопределено Тогда
				НоваяСтрока.Условие = Новый НастройкиКомпоновкиДанных;
			ИначеЕсли РодительСтроки.Родитель = Неопределено Тогда
				// Перестановка с дочерней строкой
				НоваяСтрока.Условие = РодительСтроки.Условие;
				НоваяСтрока.ТипСвязи = РодительСтроки.ТипСвязи;
				РодительСтроки.Условие = Новый НастройкиКомпоновкиДанных;
			КонецЕсли; 
			ОбновитьТипСвязиТаблицПослеИзмененияИерархии(НоваяСтрока);
			СвязиТаблиц.Строки.Удалить(КопияПеретаскиваемойСтроки);
			Элемент.ТекущаяСтрока = НоваяСтрока;
		КонецЦикла;
	ИначеЕсли ТипЗначенияПеретаскивания = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Для Каждого ПеретаскиваемыйЭлемент Из МассивЗначений Цикл
			Если Истина
				И Строка <> Неопределено 
				И Строка.Условие <> Неопределено
			Тогда
				НовыйЭлементОтбора = Строка.Условие.Отбор.Элементы.Добавить(ТипЗначенияПеретаскивания);
				ЗаполнитьЗначенияСвойств(НовыйЭлементОтбора, ПеретаскиваемыйЭлемент); 
				
				//Если ПараметрыПеретаскивания.Действие = ДействиеПеретаскивания.Перемещение Тогда
				//            РодительЭлемента = ирОбщий.ПолучитьРодителяСтрокиДереваЛкс(ПеретаскиваемыйЭлемент, ЭлементыФормы.УсловиеСвязиПанельЭлемента.Значение);
				//            РодительЭлемента.Удалить(ДействиеПеретаскивания.Перемещение);
				//КонецЕсли; 
				ЭлементыФормы.СвязиТаблиц.ОбновитьСтроки();
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОбновитьТипСвязиТаблицПослеИзмененияИерархии(Знач НоваяСтрока)
    
    Если НоваяСтрока.Родитель = Неопределено Тогда
        НоваяСтрока.ТипСвязи = "";
    ИначеЕсли Не ЗначениеЗаполнено(НоваяСтрока.ТипСвязи) Тогда
        НоваяСтрока.ТипСвязи = "LEFT";
    КонецЕсли;

КонецПроцедуры

Процедура СкопироватьСтрокуСвязиТаблиц(Знач КопируемаяСтрокаСвязиТаблиц, Знач НоваяСтрока, СтопСтрока = Неопределено)
    
	Для Каждого СвязьТаблиц Из ирОбщий.ПолучитьВсеСтрокиДереваЗначенийЛкс(КопируемаяСтрокаСвязиТаблиц) Цикл
		Если СвязьТаблиц.Условие <> Неопределено Тогда
			ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи,,,,, 2);
		КонецЕсли; 
	КонецЦикла;
    ирОбщий.СкопироватьСтрокиДереваЛкс(КопируемаяСтрокаСвязиТаблиц, НоваяСтрока, СтопСтрока);

КонецПроцедуры

Процедура СвязиТаблицПередУдалением(Элемент, Отказ)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура КПВыбранныеПоляОчистить(Кнопка)
	
	Для Каждого СтрокаВыбраннойТаблицы Из ВыбранныеТаблицы Цикл
		СтрокаВыбраннойТаблицы.ВсеПоля = Ложь;
	КонецЦикла;
	Пока ВыбранныеПоля.Количество() > 0 Цикл
		ВыбранныеПоля.Удалить(0);
	КонецЦикла; 
	
КонецПроцедуры

Процедура ИменованныеПараметрыПриИзменении(Элемент)
	
	ОбновитьВсеВыраженияПакета(, 0); 
	
КонецПроцедуры

Процедура ДоступныеПоляПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ЭтоНедоступноеДоступноеПоле(ДанныеСтроки) Тогда
		ОформлениеСтроки.Ячейки.Заголовок.УстановитьТекст("<Недоступно>");
	Иначе
		ЯчейкаТипа = ОформлениеСтроки.Ячейки.Найти("Тип");
		Если ЯчейкаТипа <> Неопределено Тогда
			ОформлениеСтроки.Ячейки.Тип.УстановитьТекст(ДанныеСтроки.ТипЗначения);
		КонецЕсли; 
		Если ДанныеСтроки.Папка Тогда
			СтрокаВыбраннойТаблицы = ВыбранныеТаблицы.Найти(НРег(ДанныеСтроки.Поле), "НИмя");
			Если СтрокаВыбраннойТаблицы <> Неопределено Тогда
				Если СтрокаВыбраннойТаблицы.ВложенныйПакет <> Неопределено Тогда
					КартинкаТипаТаблицы = ирКэш.КартинкаПоИмениЛкс("ирВложенныйЗапрос");
				Иначе
					ТипТаблицы = ирОбщий.ПолучитьТипТаблицыБДЛкс(СтрокаВыбраннойТаблицы.ПолноеИмя);
					КартинкаТипаТаблицы = ирОбщий.ПолучитьКартинкуКорневогоТипаЛкс(ТипТаблицы);
					Если КартинкаТипаТаблицы.Вид = ВидКартинки.Пустая Тогда
						ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаВыбраннойТаблицы.ПолноеИмя);
						СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
						Если СтрокаДоступнойТаблицы <> Неопределено Тогда
							ТипТаблицы = СтрокаДоступнойТаблицы.Тип;
							КартинкаТипаТаблицы = ирОбщий.ПолучитьКартинкуКорневогоТипаЛкс(ТипТаблицы);
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
				#Если Сервер И Не Сервер Тогда
				    КартинкаТипаТаблицы = Новый Картинка;
				#КонецЕсли
				Если КартинкаТипаТаблицы.Вид <> ВидКартинки.Пустая Тогда
					ОформлениеСтроки.Ячейки[0].УстановитьКартинку(КартинкаТипаТаблицы);
				КонецЕсли; 
			ИначеЕсли Найти("" + ДанныеСтроки.Поле, "._Индексы") > 0 Тогда 
				КартинкаТипаТаблицы = ирКэш.КартинкаПоИмениЛкс("ирИндексы");
				ОформлениеСтроки.Ячейки[0].УстановитьКартинку(КартинкаТипаТаблицы);
			КонецЕсли; 
		Иначе
			Если ДанныеСтроки.Родитель <> Неопределено Тогда
				ЭтоИзмерение = Ложь;
				ЭтоИндекс = Ложь;
				ЭтоСистемное = Ложь;
				ПапкаИндексов = ДанныеСтроки.Родитель.Элементы.Найти(ирОбщий.ПолучитьПервыйФрагментЛкс(ДанныеСтроки.Поле) + "._Индексы");
				Если ПапкаИндексов <> Неопределено Тогда
					ИскомаяСтрока = ирОбщий.ПолучитьПоследнийФрагментЛкс(ДанныеСтроки.Поле) + ",";
					Для Каждого ЭлементИндекса Из ПапкаИндексов.Элементы Цикл
						Если Найти(ирОбщий.ПолучитьПоследнийФрагментЛкс(СтрЗаменить(ЭлементИндекса.Поле, "[", "")) + ",", ИскомаяСтрока) = 1 Тогда
							ОформлениеСтроки.ЦветТекста = Новый Цвет(0, 0, 150);
							ЭтоИндекс = Истина;
						КонецЕсли; 
					КонецЦикла;
				КонецЕсли; 
				СтрокаПоля = Неопределено;
				СтрокаВыбраннойТаблицы = ВыбранныеТаблицы.Найти(НРег(ДанныеСтроки.Родитель.Поле), "НИмя");
				Если СтрокаВыбраннойТаблицы <> Неопределено Тогда
					ПолноеИмяДоступнойТаблицы = ПолноеИмяДоступнойТаблицы(СтрокаВыбраннойТаблицы.ПолноеИмя);
					СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяДоступнойТаблицы), "НПолноеИмя");
					Если СтрокаДоступнойТаблицы <> Неопределено Тогда
						ПоляТаблицы = ПолучитьПоляДоступнойТаблицы(СтрокаДоступнойТаблицы);
						СтрокаПоля = ПоляТаблицы.Найти(ирОбщий.ПолучитьПоследнийФрагментЛкс(ДанныеСтроки.Поле), "Имя");
					КонецЕсли; 
				КонецЕсли; 
				ОформитьСтрокуДоступногоПоля(ОформлениеСтроки, СтрокаПоля, СтрокаДоступнойТаблицы, "Заголовок", ЭтоИндекс);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОформитьСтрокуДоступногоПоля(ОформлениеСтроки, СтрокаПоля, Знач СтрокаДоступнойТаблицы, ИмяКолонки, Знач ЭтоИндекс = Ложь)
	
	ЭтоИзмерение = Истина
		И СтрокаПоля <> Неопределено 
		И СтрокаПоля.Метаданные <> Неопределено
		И Найти(СтрокаПоля.Метаданные.ПолноеИмя(), ".Измерение.") > 0;
	ЭтоСистемное = Истина
		И СтрокаПоля <> Неопределено 
		И СтрокаПоля.Метаданные = Неопределено
		И Не СтрокаПоля.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений"))
		И СтрокаДоступнойТаблицы.Тип <> "ВиртуальнаяТаблица"
		И СтрокаДоступнойТаблицы.Тип <> "ВременнаяТаблица"
		И СтрокаДоступнойТаблицы.Тип <> "Константы";
	ТекстВСкобках = "";
	Если ЭтоИзмерение Тогда
		ТекстВСкобках = ТекстВСкобках + ",Измерение";
		ОформлениеСтроки.ЦветФона= Новый Цвет(255, 245, 240);
	КонецЕсли; 
	Если ЭтоСистемное Тогда
		ТекстВСкобках = ТекстВСкобках + ",Системное";
		ОформлениеСтроки.ЦветФона = Новый Цвет(245, 245, 255);
	КонецЕсли; 
	Если ЭтоИндекс Тогда
		ТекстВСкобках = ТекстВСкобках + ",Индекс";
	КонецЕсли; 
	Если ЗначениеЗаполнено(ТекстВСкобках) Тогда
		ТекстВСкобках = " (" + Сред(ТекстВСкобках, 2) + ")";
		ОформлениеСтроки.Ячейки[ИмяКолонки].УстановитьТекст(ОформлениеСтроки.Ячейки[ИмяКолонки].Текст + ТекстВСкобках);
	КонецЕсли;

КонецПроцедуры

Процедура ПервыеКоличествоПриИзменении(Элемент)
	
	ЭтаФорма.ОпцияПервые = ЗначениеЗаполнено(Элемент.Значение);
	
КонецПроцедуры

Процедура ДляИзмененияПриИзменении(Элемент)
	
	ОбновитьВидимостьКолонкиДляИзмененияВыбранныхТаблиц();
	
КонецПроцедуры

Процедура ОбновитьВидимостьКолонкиДляИзмененияВыбранныхТаблиц()

	ЭлементыФормы.ВыбранныеТаблицы.Колонки.ДляИзменения.Видимость = ОпцияДляИзменения;

КонецПроцедуры // ОбновитьВидимостьКолонкиДляИзмененияВыбранныхТаблиц()

Процедура ПараметрыТаблицыОпределениеПриИзменении(Элемент)
	
	ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст(Элемент.Значение);
	
КонецПроцедуры

Процедура ОтборПоТипуДоступнойТаблицыОчистка(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	Элемент.Значение = "";
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Тип.Использование = Ложь;

КонецПроцедуры

Процедура ОтборПоТипуДоступнойТаблицыПриИзменении(Элемент)
	
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Тип.Использование = Истина;
	
КонецПроцедуры

Процедура КПВыбранныеПоляОтключитьРежимАвтополе(Кнопка)
	
	Если ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	НИмяТаблицы = НРег(ирОбщий.ПолучитьПервыйФрагментЛкс(ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Определение));
	СтрокаТаблицы = ВыбранныеТаблицы.Найти(НИмяТаблицы, "НИмя");
	СтрокаТаблицы.ВсеПоля = Ложь;
	УдалитьАвтоПоляТаблицыИзВыбранныхПолей(СтрокаТаблицы.Имя);
	ЭлементыФормы.ВыбранныеПоля.ОбновитьСтроки();
	
КонецПроцедуры

Процедура ПоказыватьИндексыПриИзменении(Элемент)
	
	ОбновитьКомпоновщикЧастиОбъединения();
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыВсеТипыСсылок(Кнопка)
	
	Текст = ирОбщий.ПолучитьТекстЗапросаВсехТиповСсылокЛкс("");
	ИмяТаблицы = "ВсеТипыСсылок";
	ВложенныйПакет = ОткрытьВложенныйПакет(, ИмяТаблицы, Текст);
	Если ВложенныйПакет <> Неопределено Тогда
		ЗаполнитьСтрокуВложенногоПакета(ВложенныйПакет,, ИмяТаблицы);
	КонецЕсли;
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыДатыЗаПериод(Кнопка)
	
	Текст = ирОбщий.ПолучитьТекстЗапросаДатВДиапазонеЛкс("");
	ИмяТаблицы = "ДатыДиапазона";
	ВложенныйПакет = ОткрытьВложенныйПакет(, ИмяТаблицы, Текст);
	Если ВложенныйПакет <> Неопределено Тогда
		ЗаполнитьСтрокуВложенногоПакета(ВложенныйПакет,, ИмяТаблицы);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьТекстЗапросаСВыбромМетаданных(ЛиТаблицыИзменения = Ложь) Экспорт

	Форма = ирКэш.Получить().ПолучитьФорму("ВыборОбъектаМетаданных", ЭтаФорма, ЭтаФорма);
	лСтруктураПараметров = Новый Структура;
	лСтруктураПараметров.Вставить("ОтображатьСсылочныеОбъекты", Истина);
	лСтруктураПараметров.Вставить("ОтображатьВнешниеИсточникиДанных", Истина);
	//лСтруктураПараметров.Вставить("ОтображатьРегистры", Истина);
	лСтруктураПараметров.Вставить("МножественныйВыбор", Истина);
	Форма.НачальноеЗначениеВыбора = лСтруктураПараметров;
	ЗначениеВыбора = Форма.ОткрытьМодально();
	Если ЗначениеВыбора <> Неопределено Тогда
		Текст = ирОбщий.ПолучитьТекстЗапросаПоВыбраннымТаблицамЛкс(ЗначениеВыбора, ?(ЛиТаблицыИзменения, 1, 0));
	КонецЕсли; 
	Возврат Текст;

КонецФункции // ПолучитьТекстЗапросаСВыбромМетаданных()

Процедура КПВыбранныеТаблицыОбъединениеСсылочныхТаблиц(Кнопка)
	
	Текст = ПолучитьТекстЗапросаСВыбромМетаданных();
	Если Не ПустаяСтрока(Текст) Тогда
		ИмяТаблицы = "ОбъединениеСсылок";
		ВложенныйПакет = ОткрытьВложенныйПакет(, ИмяТаблицы, Текст);
		Если ВложенныйПакет <> Неопределено Тогда
			ЗаполнитьСтрокуВложенногоПакета(ВложенныйПакет,, ИмяТаблицы);
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры
 
Процедура КПВыбранныеТаблицыОбъединениеСсылочныхТаблицИзменений(Кнопка)
	
	Текст = ПолучитьТекстЗапросаСВыбромМетаданных();
	Если Не ПустаяСтрока(Текст) Тогда
		ИмяТаблицы = "ОбъединениеИзменений";
		ВложенныйПакет = ОткрытьВложенныйПакет(, ИмяТаблицы, Текст);
		Если ВложенныйПакет <> Неопределено Тогда
			ЗаполнитьСтрокуВложенногоПакета(ВложенныйПакет,, ИмяТаблицы);
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Процедура ОсновныеДействияФормыСтруктураФормы(Кнопка)
	
	ирОбщий.ОткрытьСтруктуруФормыЛкс(ЭтаФорма);
	
КонецПроцедуры

Процедура КПДоступныеТаблицыПоказатьСтруктуруХранения(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Или ТекущаяСтрока.Тип = "ВиртуальнаяТаблица" Тогда
		Возврат;
	КонецЕсли; 
	Форма = ирОбщий.ПолучитьФормуЛкс("Обработка.ирСтруктураХраненияБД.Форма");
	Форма.ПараметрИмяТаблицы = ТекущаяСтрока.ПолноеИмя;
	Форма.ПараметрПоказыватьSDBL = Истина;
	Форма.ПараметрПоказыватьСУБД = Ложь;
	Форма.Открыть();
	
КонецПроцедуры

Процедура ЗапросыПакетаИмяПриИзменении(Элемент)
	
	ТекущаяСтрока = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	ТекущаяСтрока.РучноеИмя = ЗначениеЗаполнено(Элемент.Значение);
	Если ЗначениеЗаполнено(Элемент.Значение) Тогда
		ТекущаяСтрока.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЗапросыПакета, ТекущаяСтрока);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЗапросыПакетаПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки.РучноеИмя Тогда
		ОформлениеСтроки.Ячейки.Имя.ЦветТекста = Новый Цвет(0, 0, 255);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЧастиОбъединенияИмяПриИзменении(Элемент)
	
	ТекущаяСтрока = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	ТекущаяСтрока.РучноеИмя = ЗначениеЗаполнено(Элемент.Значение);
	Если ЗначениеЗаполнено(Элемент.Значение) Тогда
		ТекущаяСтрока.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЧастиОбъединения, ТекущаяСтрока);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЧастиОбъединенияПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки.РучноеИмя Тогда
		ОформлениеСтроки.Ячейки.Имя.ЦветТекста = Новый Цвет(0, 0, 255);
	КонецЕсли; 

КонецПроцедуры

Процедура ОсновныеДействияФормыОПодсистеме(Кнопка)
	
	ирОбщий.ОткрытьСправкуПоПодсистемеЛкс(ЭтаФорма);
	
КонецПроцедуры

Процедура ЗначенияИзВыборкиПриИзменении(Элемент = Неопределено)
	
	ЭлементыФормы.ПринимающиеПоля.Колонки.Определение.Видимость = Не ЗначенияИзВыборки;
	
КонецПроцедуры

Процедура ПринимающиеПоляПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ПоляДоступнойТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.ПоляДоступнойТаблицы.Колонки.ТипЗначения Тогда
		ирОбщий.ОткрытьЗначениеЛкс(ВыбраннаяСтрока.ТипЗначения, Ложь, СтандартнаяОбработка);
	Иначе
		Если ПараметрыДиалектаSQL.МногоТаблиц Или ВыбранныеТаблицы.Количество() = 0 Тогда
			СтрокаВыбраннойТаблицы = ДобавитьДоступнуюТаблицуВВыбранные(ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока, Истина);
			ПолноеИмяПоля = СтрокаВыбраннойТаблицы.Имя + "." + ВыбраннаяСтрока.Имя;
		Иначе
			ПолноеИмяПоля = ВыбраннаяСтрока.Имя;
		КонецЕсли; 
		ДоступноеПоле = КомпоновщикЧасти.Настройки.ДоступныеПоляВыбора.НайтиПоле(Новый ПолеКомпоновкиДанных(ПолноеИмяПоля));
		Если ДоступноеПоле <> Неопределено Тогда
			ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(ДоступноеПоле);
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура ПоляДоступнойТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока <> Неопределено Тогда
		ОформитьСтрокуДоступногоПоля(ОформлениеСтроки, ДанныеСтроки, ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока, "Имя");
	КонецЕсли; 
	ирОбщий.ТабличноеПолеПриВыводеСтрокиЛкс(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Процедура КПТекстНайтиВКонструкторе(Кнопка)
	
	
	
КонецПроцедуры

Процедура ДоступныеТаблицыПередНачаломИзменения(Элемент, Отказ)
	
	Если Элемент.ТекущаяСтрока.Тип <> "ВременнаяТаблица" Тогда
		Отказ = Истина;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеТаблицыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		НовоеИмяТаблицы = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение.Выгрузить(), Элемент.ТекущиеДанные.Имя, "ПолноеИмя",,
			ПолучитьСловоЯзыкаЗапросов("Table") + "1");
		Элемент.ТекущиеДанные.Имя = НовоеИмяТаблицы;
		Элемент.ТекущиеДанные.ПолноеИмя = НовоеИмяТаблицы;
		Элемент.ТекущиеДанные.НПолноеИмя = НРег(НовоеИмяТаблицы);
		Если мТекущееИмяДоступнойТаблицы <> НовоеИмяТаблицы Тогда
			ПереименоватьТаблицуИлиПараметр(, мТекущееИмяДоступнойТаблицы, НовоеИмяТаблицы);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеТаблицыПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	мТекущееИмяДоступнойТаблицы = Элемент.ТекущиеДанные.Имя;

КонецПроцедуры

Процедура КПДоступныеТаблицыВключитьКоличествоСтрок(Кнопка)
	
	Кнопка.Пометка = Не Кнопка.Пометка;
	ЭлементыФормы.ДоступныеТаблицы.Колонки.КоличествоСтрок.Видимость = Кнопка.Пометка;
	Если Кнопка.Пометка Тогда
		Если ирКэш.ПолучитьТаблицуВсехТаблицБДЛкс()[0].КоличествоСтрок = Неопределено Тогда
			Ответ = КодВозвратаДиалога.Да;
		Иначе
			Ответ = Вопрос("Хотите обновить статистику?", РежимДиалогаВопрос.ДаНет);
		КонецЕсли; 
		Если Ответ = КодВозвратаДиалога.Да Тогда
			ирОбщий.ВычислитьКоличествоСтрокТаблицВДеревеМетаданныхЛкс();
		КонецЕсли;
		ТаблицаВсехТаблиц = ирКэш.ПолучитьТаблицуВсехТаблицБДЛкс();
		Для Каждого СтрокаДоступнойТаблицы Из ДоступныеТаблицы Цикл
			ОписаниеТаблицы = ТаблицаВсехТаблиц.Найти(СтрокаДоступнойТаблицы.НПолноеИмя, "НПолноеИмя");
			Если ОписаниеТаблицы <> Неопределено Тогда
				СтрокаДоступнойТаблицы.КоличествоСтрок = ОписаниеТаблицы.КоличествоСтрок;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПоляОбъединенияВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.ПоляОбъединения.Колонки.ТипЗначения Тогда
		ирОбщий.ОткрытьЗначениеЛкс(ВыбраннаяСтрока.ТипЗначения, Ложь, СтандартнаяОбработка);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.ВыбранныеПоля.Колонки.ТипЗначения Тогда
		ирОбщий.ОткрытьЗначениеЛкс(ВыбраннаяСтрока.ТипЗначения, Ложь, СтандартнаяОбработка);
	КонецЕсли; 
		
КонецПроцедуры

Процедура ИерархическийСтильЛогическихВыраженийПриИзменении(Элемент)
	
	ПриИзмененииПараметровСборкиТекста();

КонецПроцедуры

Процедура КПДоступныеТаблицыОткрытьОбъектМетаданных(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Или ТекущаяСтрока.Тип = "ВиртуальнаяТаблица" Тогда
		Возврат;
	КонецЕсли; 
	ирОбщий.ОткрытьОбъектМетаданныхЛкс(ТекущаяСтрока.ПолноеИмя);
	
КонецПроцедуры

Процедура МенюДоступныхПолейПерейтиКВыбраннойТаблице(Кнопка)
	
	Перем ИмяТаблицы;
	ТекущаяСтрока = ТекущийЭлемент.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТекущаяСтрока.Папка Тогда
		ИмяТаблицы = ТекущаяСтрока.Поле;
		ИмяПоля = "";
	Иначе
		ИмяТаблицы = ТекущаяСтрока.Родитель.Поле;
		ИмяПоля = ирОбщий.ПолучитьПоследнийФрагментЛкс(ТекущаяСтрока.Поле);
	КонецЕсли; 
	СтрокаВыбраннойТаблицы = ВыбранныеТаблицы.Найти(Нрег(ИмяТаблицы), "НИмя");
	Если СтрокаВыбраннойТаблицы <> Неопределено Тогда
		ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока = СтрокаВыбраннойТаблицы;
		ЭтаФорма.ТекущийЭлемент = ЭлементыФормы.ВыбранныеТаблицы;
		КПВыбранныеТаблицыНайтиВСписке();
		СтрокаПоляДоступнойТаблицы = ПоляДоступнойТаблицы.Найти(ИмяПоля, "Имя");
		Если СтрокаПоляДоступнойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ПоляДоступнойТаблицы.ТекущаяСтрока = СтрокаПоляДоступнойТаблицы;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура КПВыбранныеПоляНайтиВСписке(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ДоступноеПоле = КомпоновщикЧасти.Настройки.ДоступныеПоляВыбора.НайтиПоле(Новый ПолеКомпоновкиДанных(ТекущаяСтрока.Определение));
	Если ДоступноеПоле <> Неопределено Тогда
		ЭлементыФормы.ДоступныеПоляВыбора.ТекущаяСтрока = ДоступноеПоле;
	КонецЕсли; 
	
КонецПроцедуры

Процедура КПДеревоУсловияНайтиВСписке(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ДеревоУсловия.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Или ТипЗнч(ТекущаяСтрока) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли; 
	ДоступноеПоле = КомпоновщикЧасти.Настройки.ДоступныеПоляОтбора.НайтиПоле(Новый ПолеКомпоновкиДанных(ТекущаяСтрока.ЛевоеЗначение));
	Если ДоступноеПоле <> Неопределено Тогда
		ЭлементыФормы.ДоступныеПоляУсловия.ТекущаяСтрока = ДоступноеПоле;
	КонецЕсли; 

КонецПроцедуры

Процедура КПГруппировкиНайтиВСписке(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.Группировки.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ДоступноеПоле = КомпоновщикЧасти.Настройки.ДоступныеПоляВыбора.НайтиПоле(Новый ПолеКомпоновкиДанных(ТекущаяСтрока.Определение));
	Если ДоступноеПоле <> Неопределено Тогда
		ЭлементыФормы.ДоступныеПоляГруппировок.ТекущаяСтрока = ДоступноеПоле;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПоляОбъединенияПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ПоляОбъединенияПередУдалением(Элемент, Отказ)
	
	ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	УдалитьПоле = Истина;
	//Ответ = Вопрос("У текущего поля объединения не осталось полезных связанных выбранных полей. Хотите удалить его?", РежимДиалогаВопрос.ОКОтмена);
	//УдалитьПоле = Ответ = КодВозвратаДиалога.ОК;
	Если УдалитьПоле Тогда
		// Удаляем все выбранные поля NULL старого поля объединения
		Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
			Если ЗначениеЗаполнено(ПолеОбъединения["_" + ЧастьОбъединения.Номер]) Тогда
				ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ПолеОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
				Если ВыбранноеПоле <> Неопределено Тогда
					ЧастьОбъединения.ВыбранныеПоля.Удалить(ВыбранноеПоле);
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла;
		ПоляОбъединения.Удалить(ПолеОбъединения);
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПослеУдаления(Элемент)
	
	СохранитьЧастьОбъединения();
	
КонецПроцедуры

ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ВыбранныеПоля);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ПоляДоступнойТаблицы);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ПоляВыбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ПоляОтбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПсевдонима);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляУсловия);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПорядкаОбъединения);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПорядкаЧастиОбъединения);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляИтоговОбъединения);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляПорядкаПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляИтоговПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляВыбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеВыбранныеПоляОтбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляИндекса);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляВыбора);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляГруппировок);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляУсловияПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляВыбораПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляПорядкаПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ДоступныеПоляИтоговПостроителя);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи);
ирОбщий.ПодключитьОбработчикиСобытийДоступныхПолейКомпоновкиЛкс(ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи);
ЭлементыФормы.ДоступныеПоляУсловия.Колонки.Заголовок.КартинкиСтрок = ирКэш.КартинкаПоИмениЛкс("ирТипыДоступныхПолейКомпоновки");

ПоляДоступнойТаблицы.Колонки.Добавить("Метаданные");
//ЭлементыФормы.ВыбранныеПоля.Колонки.Определение.КартинкиСтрок = ирКэш.КартинкаПоИмениЛкс("ирТипыДоступныхПолейКомпоновки");
//ЭлементыФормы.ПоляДоступнойТаблицы.Колонки.Имя.КартинкиСтрок = ирКэш.КартинкаПоИмениЛкс("ирТипыДоступныхПолейКомпоновки");
ПоляПорядка.Колонки.Добавить("Направление", Новый ОписаниеТипов("НаправлениеСортировки"));
СвязиТаблиц.Колонки.Добавить("Условие");
СвязиТаблиц.Колонки.Добавить("ПозицияНачалаВИсточнике", Новый ОписаниеТипов("Число"));
СвязиТаблиц.Колонки.Добавить("ПозицияКонцаВИсточнике", Новый ОписаниеТипов("Число"));
//СвязиТаблиц.Колонки.Добавить("НТаблица", Новый ОписаниеТипов("Строка"));
ВыбранныеТаблицы.Колонки.Добавить("ВложенныйПакет");
ВыбранныеТаблицы.Колонки.Добавить("Параметры");
//ВыбранныеТаблицы.Колонки.Добавить("Обязательная", Новый ОписаниеТипов("Булево"));
//ВыбранныеТаблицы.Колонки.Добавить("НомерГруппы", Новый ОписаниеТипов("Число"));
ВыбранныеТаблицы.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляОбъединения.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляОбъединения.Колонки.Добавить("Монополе", Новый ОписаниеТипов("Булево"));
ПоляВыбораПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляОтбораПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляПорядкаПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляИтоговПостроителя.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
Параметры.Колонки.Удалить("Значение");
Параметры.Колонки.Добавить("Значение"); // Очистка описания типов
ПараметрыТаблицы.Колонки.Добавить("Токен");
//ПараметрыТаблицы.Колонки.Добавить("ТекстРасширения");
ВыбранныеПоля.Колонки.Добавить("Токен");
ВыбранныеПоля.Колонки.Добавить("ПозицияНачалаВИсточнике", Новый ОписаниеТипов("Число"));
ВыбранныеПоля.Колонки.Добавить("ПозицияКонцаВИсточнике", Новый ОписаниеТипов("Число"));
Группировки.Колонки.Добавить("Токен");
ПоляПорядка.Колонки.Добавить("Токен");
ПринимающиеПоля.Колонки.Добавить("Токен");
ПоляВыбораПостроителя.Колонки.Добавить("Токен");
ПоляОтбораПостроителя.Колонки.Добавить("Токен");
ПоляПорядкаПостроителя.Колонки.Добавить("Токен");
ПоляИтоговПостроителя.Колонки.Добавить("Токен");
ГруппируемыеПоляИтогов.Колонки.Добавить("Токен");
ГруппируемыеПоляИтогов.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ГруппирующиеПоляИтогов.Колонки.Добавить("Токен");
ГруппирующиеПоляИтогов.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ВыбранныеПоля.Колонки.Добавить("ИД");
ВыбранныеПоля.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ДоступныеПоляПсевдонима.Колонки.Добавить("ИД");
ЧастиОбъединения.Колонки.Добавить("РучноеИмя", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("ВыбранныеТаблицы");
ЧастиОбъединения.Колонки.Добавить("ВыбранныеПоля");
ЧастиОбъединения.Колонки.Добавить("СвязиТаблиц");
ЧастиОбъединения.Колонки.Добавить("Группировки");
//ЧастиОбъединения.Колонки.Добавить("Условие");
ЧастиОбъединения.Колонки.Добавить("КомпоновщикАктуален", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("ПоляВыбораПостроителя");
ЧастиОбъединения.Колонки.Добавить("ПоляОтбораПостроителя");
ЧастиОбъединения.Колонки.Добавить("ОпцияРазличные", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("ОпцияДляИзменения", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("Автогруппировки", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("Компоновщик", Новый ОписаниеТипов("КомпоновщикНастроекКомпоновкиДанных"));
ЧастиОбъединения.Колонки.Добавить("ИсточникНастроек");
ЧастиОбъединения.Колонки.Добавить("ТекстРасширения", Новый ОписаниеТипов("Строка"));
ЧастиОбъединения.Колонки.Добавить("ПозицияНачалаВИсточнике", Новый ОписаниеТипов("Число"));
ЧастиОбъединения.Колонки.Добавить("ПозицияКонцаВИсточнике", Новый ОписаниеТипов("Число"));
ЗапросыПакета.Колонки.Добавить("РучноеИмя", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ИД", Новый ОписаниеТипов("УникальныйИдентификатор"));
ЗапросыПакета.Колонки.Добавить("ЧастиОбъединения");
ЗапросыПакета.Колонки.Добавить("ПоляОбъединения");
ЗапросыПакета.Колонки.Добавить("ГруппирующиеПоляИтогов");
ЗапросыПакета.Колонки.Добавить("ГруппируемыеПоляИтогов");
ЗапросыПакета.Колонки.Добавить("ПоляПорядкаПостроителя");
ЗапросыПакета.Колонки.Добавить("ПоляИтоговПостроителя");
ЗапросыПакета.Колонки.Добавить("Комментарий", Новый ОписаниеТипов("Строка")); // Используется только для УНИЧТОЖИТЬ, т.к. там нет объединения
ЗапросыПакета.Колонки.Добавить("ТекстРасширения", Новый ОписаниеТипов("Строка"));
ЗапросыПакета.Колонки.Добавить("ПоляПорядка");
ЗапросыПакета.Колонки.Добавить("ПоляИндекса");
ЗапросыПакета.Колонки.Добавить("ПринимающиеПоля");
ЗапросыПакета.Колонки.Добавить("ОпцияАвтоупорядочивание", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияОбщиеИтоги", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияПервые", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияРазрешенные", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ТипЗапроса", Новый ОписаниеТипов("Число"));
ЗапросыПакета.Колонки.Добавить("ПервыеКоличество", Новый ОписаниеТипов("Число, Строка"));
ЗапросыПакета.Колонки.Добавить("ИмяОсновнойТаблицы", Новый ОписаниеТипов("Строка"));
ЗапросыПакета.Колонки.Добавить("УровеньИзоляции", Новый ОписаниеТипов("Строка"));
ЗапросыПакета.Колонки.Добавить("ЗначенияИзВыборки", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("Компоновщик");
ЗапросыПакета.Колонки.Добавить("ПозицияНачалаВИсточнике", Новый ОписаниеТипов("Число"));
ЗапросыПакета.Колонки.Добавить("ПозицияКонцаВИсточнике", Новый ОписаниеТипов("Число"));
ЭлементыФормы.ПоляПорядка.Колонки.Направление.Данные = "Направление";
мРежимРедактированияТекста = Ложь;
ПолеТекстаОтображаетПакет = Истина;
Английский1С = ирОбщий.СтрокиРавныЛкс(ТекущийЯзыкСистемы(), "en");
мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей = ПоляОбъединения.Колонки.Количество();
мЧислоСтатическихКолонокТППоляПсевдонимовПолей = ЭлементыФормы.ПоляОбъединения.Колонки.Количество();

СписокВыбораДиалектов = ЭлементыФормы.ДиалектSQL.СписокВыбора;
СписокВыбораДиалектов.Добавить("1С");
СписокВыбораДиалектов.Добавить("WQL");
СписокВыбораДиалектов.Добавить("Oracle");
СписокВыбораДиалектов.Добавить("MSSQL");
СписокВыбораДиалектов.Добавить("DB2");
СписокВыбораДиалектов.Добавить("MSVisualFoxPro");
СписокВыбораДиалектов.Добавить("MSJet");
СписокВыбораДиалектов.Добавить("MySQL");
СписокВыбораДиалектов.Добавить("PostgreSQL");
СписокВыбораДиалектов.Добавить("SQLite");
СписокВыбораДиалектов.СортироватьПоЗначению();

СписокВыбораПервые = ЭлементыФормы.ПервыеКоличество.СписокВыбора;
СписокВыбораПервые.Добавить("1");
СписокВыбораПервые.Добавить("10");
СписокВыбораПервые.Добавить("100");
СписокВыбораПервые.Добавить("1000");
СписокВыбораПервые.Добавить("10000");
СписокВыбораДиалектов.СортироватьПоЗначению();

мТерминалыЯзыкаЗапросов = Новый Соответствие;
мТерминалыЯзыкаЗапросов = ирОбщий.ПолучитьТаблицуИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ТерминалыЯзыкаЗапросов"));
мТерминалыЯзыкаЗапросов.Индексы.Добавить("Ключ");

ирОбщий.ИнициализироватьФормуЛкс(ЭтаФорма, "Обработка.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Форма.КонструкторЗапроса");

// Антибаг платформы. Очищаются свойство данные, если оно указывает на отбор табличной части
ЭлементыФормы.ФильтрДоступныхТаблиц.Данные = "ЭлементыФормы.ДоступныеТаблицы.Отбор.Имя.Значение";
ЭлементыФормы.ФильтрДоступныхТаблиц.КнопкаВыбора = Ложь;
ЭлементыФормы.ФильтрДоступныхТаблиц.КнопкаСпискаВыбора = Истина;
ЭлементыФормы.ОтборПоТипуДоступнойТаблицы.Данные = "ЭлементыФормы.ДоступныеТаблицы.Отбор.Тип.Значение";
ЭлементыФормы.ОтборПоТипуДоступнойТаблицы.КнопкаОчистки = Истина;
