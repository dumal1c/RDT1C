//ирПортативный Перем ирПортативный Экспорт;
//ирПортативный Перем ирОбщий Экспорт;
//ирПортативный Перем ирСервер Экспорт;
//ирПортативный Перем ирКэш Экспорт;
//ирПортативный Перем ирПривилегированный Экспорт;

Функция ВыполнитьРегистрацию() Экспорт

	//http://msdn.microsoft.com/en-us/library/windows/desktop/ms687653%28v=vs.85%29.aspx
	// http://icodeguru.com/VC%26MFC/APracticalGuideUsingVisualCandATL/133.htm
	// Коды ошибок http://msdn.microsoft.com/en-us/library/windows/desktop/dd542647%28v=vs.85%29.aspx
	КаталогПриложений = Новый COMОбъект("COMAdmin.COMAdminCatalog");
	КаталогПриложений.Connect(ИмяКомпьютера());
	ПриложенияСистемы = КаталогПриложений.GetCollection("Applications");
	ПриложенияСистемы.Populate();
	Для Каждого СтрокаТаблицы Из Классы Цикл
		НовыйСборкаПлатформы = СтрокаТаблицы.НовыйСборкаПлатформы;
		Если ЗначениеЗаполнено(НовыйСборкаПлатформы) Тогда
			ЗарегистрироватьCOMКлассСборкиПлатформы(ТипыComКлассов.Найти(СтрокаТаблицы.ТипКласса, "Имя"), СтрокаТаблицы.x64, НовыйСборкаПлатформы);
		КонецЕсли;
	КонецЦикла; 
	Если Не ИзменитьПриложения Тогда
		Возврат Истина;
	КонецЕсли; 
	Если Ложь
		#Если Не Клиент Тогда
		Или ирКэш.Это64битныйПроцессЛкс() 
		#КонецЕсли 
	Тогда
		Сообщить("Изменение COM+ приложений из 64-битного процесса (на сервере) не реализовано");
	Иначе
		Для Каждого СтрокаПриложения Из Приложения Цикл
			СтрокаКласса = Классы.НайтиСтроки(Новый Структура("ИмяКласса, x64", СтрокаПриложения.ИмяКласса, СтрокаПриложения.x64))[0];
			Если Истина
				И ЗначениеЗаполнено(СтрокаКласса.ИмяФайла)
			Тогда
				Если Не ЗначениеЗаполнено(СтрокаПриложения.ИмяПриложения) Тогда
					ПриложениеОбъект = ПриложенияСистемы.Add();
				Иначе
					Для Индекс = 0 По ПриложенияСистемы.Count - 1 Цикл
						лПриложениеОбъект = ПриложенияСистемы.Item(Индекс);
						Если лПриложениеОбъект.Key = СтрокаПриложения.ИдентификаторКласса Тогда
							Если Не СтрокаПриложения.Создать Тогда
								ПриложенияСистемы.Remove(Индекс);
							Иначе
								ПриложениеОбъект = лПриложениеОбъект;
							КонецЕсли; 
							Прервать;
						КонецЕсли; 
					КонецЦикла;
					Если Истина
						И СтрокаПриложения.Создать
						И ПриложениеОбъект = Неопределено 
					Тогда
						ВызватьИсключение "COM+ приложение с именем """ + СтрокаПриложения.ИмяПриложения + """ не найдено. Попробуйте обновить имена.";
					КонецЕсли; 
				КонецЕсли; 
				//http://msdn.microsoft.com/en-us/library/windows/desktop/ms687653%28v=vs.85%29.aspx
				Если ПриложениеОбъект <> Неопределено Тогда
					ИмяПриложения = ПолучитьИмяПриложения(СтрокаКласса.ИзданиеПлатформы);
					//http://msdn.microsoft.com/en-us/library/windows/desktop/ms686107%28v=vs.85%29.aspx
					ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, ИмяПриложения, "Value", "Name");
					//ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, "", "Value", "Description");
					ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, ?(СтрокаПриложения.ОтдельнаяАктивация, 1, 0), "Value", "Activation");
					//ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, СтрокаПриложения.Включено, "Value", "IsEnabled"); 
					ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, Истина, "Value", "IsEnabled"); 
					ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, 100, "Value", "ConcurrentApps"); 
					ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, 1, "Value", "RecycleActivationLimit"); 
					ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, 1440, "Value", "RecycleExpirationTimeout");
					Если ЗначениеЗаполнено(ПриложениеПользовательОС) Тогда
						ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, ПриложениеПользовательОС, "Value", "Identity");
						ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, ПриложениеПарольПользователяОС, "Value", "Password");
					КонецЕсли; 
					//ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(ПриложениеОбъект, Истина, "Value", "RunForever");
				КонецЕсли; 
				Попытка
					ПриложенияСистемы.SaveChanges();
				Исключение
					ОписаниеОшибки = ОписаниеОшибки();
					Если Найти(ОписаниеОшибки, "0x80110414") > 0 Тогда
						ВызватьИсключение "Новые имя или пароль пользователя COM+ приложений указаны неверно";
					ИначеЕсли Найти(ОписаниеОшибки, "0x80070005") > 0 Тогда
						ВызватьИсключение "Нет разрешения на изменение COM+ приложений. Запустите приложение от имени администратора или отключите флажок ""Изменить приложения"".";
					Иначе
						ВызватьИсключение;
					КонецЕсли; 
				КонецПопытки;
				Если ПриложениеОбъект = Неопределено Тогда
					Продолжить;
				КонецЕсли; 
				//Если Истина
				//	И ирКэш.Это64битнаяОСЛкс()
				//	И Не СтрокаПриложения.x64 
				//Тогда
				//	ИмяКоллекцииКомпонент = "LegacyComponents";
				//Иначе
					ИмяКоллекцииКомпонент = "Components";
				//КонецЕсли; 
				Компоненты = ПриложенияСистемы.GetCollection(ИмяКоллекцииКомпонент, ПриложениеОбъект.Key);
				Компоненты.Populate();
				Компонента = Неопределено;
				Для Каждого лКомпонента Из Компоненты Цикл
					//Если ОбщийИис.СтрокиРавныИис(СтрокаПриложения.ИмяКласса + ".1", лКомпонента.Value("ProgID")) Тогда
					Если ирОбщий.СтрокиРавныЛкс(СтрокаКласса.ИдентификаторКласса, лКомпонента.Key) Тогда
						Компонента = лКомпонента;
						Прервать;
					КонецЕсли; 
				КонецЦикла;
				Если Компонента = Неопределено Тогда
					//Компонента = КаталогПриложений.ImportComponent(ПриложениеОбъект.Key, СтрокаПриложения.ИмяКласса);
					Компонента = КаталогПриложений.ImportComponent(ПриложениеОбъект.Key, СтрокаКласса.ИдентификаторКласса);
				КонецЕсли; 
				
				Роли = ПриложенияСистемы.GetCollection("Roles", ПриложениеОбъект.Key);
				Роли.Populate();
				Роль = Неопределено;
				Для Каждого лРоль Из Роли Цикл
					Роль = лРоль;
					Прервать;
				КонецЦикла;
				Если Роль = Неопределено Тогда
					Роль = Роли.Add();
					ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(Роль, "CreatorOwner", "Value", "Name");
					Роли.SaveChanges();
				КонецЕсли; 
				
				Пользователи = Роли.GetCollection("UsersInRole", Роль.Key);
				Пользователи.Populate();
				// Добавляем пользователя "Все" ("Everyone")
				Для Каждого лПользователь Из Пользователи Цикл
					//Если ОбщийИис.СтрокиРавныИис("Everyone", лПользователь.Value("User")) Тогда
					//	Пользователь = лПользователь;
					//	Прервать;
					//КонецЕсли; 
					Пользователи.Remove(0);
				КонецЦикла;
				Пользователь = Пользователи.Add();
				//ИмяПользователяИнициатора = ирОбщий.ПолучитьИмяСистемногоПользователяEveryoneЛкс();
				ИмяПользователяИнициатора = ирОбщий.ИмяСлужебногоПользователяОСAuthenticatedUsersЛкс();
				ирОбщий.УстановитьЗначениеПоФункциональнойСсылкеЛкс(Пользователь, ИмяПользователяИнициатора, "Value", "User");
				Пользователи.SaveChanges();
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли; 
	Результат = Истина;
	Возврат Результат;
		
КонецФункции

Функция ПолучитьИмяПриложения(ИзданиеПлатформы) Экспорт
	
	#Если _ Тогда
	    ИзданиеПлатформы = Справочники.ИзданияПлатформИис.ПустаяСсылка();
	#КонецЕсли
	ИмяПриложения = "1C" + СтрЗаменить(ИзданиеПлатформы, ".", "_") + " ComConnector";
	Возврат ИмяПриложения;
	
КонецФункции

Процедура ЗарегистрироватьCOMКлассСборкиПлатформы(Знач ТипКласса, Знач x64 = Неопределено, Знач СборкаПлатформы = Неопределено) Экспорт 
	
	#Если Сервер И Не Сервер Тогда
	    ТипКласса = ТипыComКлассов.Найти();
	#КонецЕсли
	Если x64 = Неопределено Тогда
		x64 = ирКэш.Это64битныйПроцессЛкс();
	КонецЕсли; 
	ОтборСтрок = Новый Структура("СборкаПлатформы", ирОбщий.ПервыйФрагментЛкс(СборкаПлатформы, " - "));
	Фрагменты = ирОбщий.СтрРазделитьЛкс(СборкаПлатформы, " - ");
	Если Фрагменты.Количество() > 1 Тогда
		ОтборСтрок.Вставить("x64", Фрагменты[1] = "64");
	Иначе
		ОтборСтрок.Вставить("x64", x64);
	КонецЕсли; 
	СтрокиТаблицы = СборкиПлатформы.НайтиСтроки(ОтборСтрок);
	Если СтрокиТаблицы.Количество() > 0 Тогда
		СтрокаТаблицыНовогоРелиза = СтрокиТаблицы[0];
		ЗарегистрироватьCOMКлассИзКаталогаФайлов(ТипКласса, x64, СтрокаТаблицыНовогоРелиза.Каталог + "bin", СборкаПлатформы);
	Иначе
		ВызватьИсключение "Файл регистрации класса " + ТипКласса.Имя + " для сборки платформы " + СборкаПлатформы + " не найден";
	КонецЕсли;

КонецПроцедуры

Функция ЗарегистрироватьCOMКлассИзКаталогаФайлов(ТипКласса, x64 = Неопределено, пКаталогФайла = Неопределено, СборкаПлатформы = Неопределено) Экспорт 
	
	Если Не ЗначениеЗаполнено(пКаталогФайла) Тогда
		КаталогФайла = КаталогПрограммы();
		СборкаПлатформы = ТекущаяСборкаПлатформы;
	Иначе
		КаталогФайла = пКаталогФайла;
	КонецЕсли; 
	Если ТипКласса.Внутрипроцессный Тогда
		Если x64 <> Неопределено И ирКэш.Это64битнаяОСЛкс() Тогда
			Если x64 Тогда
				Команда = "%systemroot%\System32\regsvr32.exe";
			Иначе
				Команда = "%systemroot%\SysWoW64\regsvr32.exe";
			КонецЕсли; 
		Иначе
			Команда = "regsvr32.exe";
		КонецЕсли; 
		Если ТипКласса.Имя = "ComConnector" Тогда
			ПолноеИмяФайла = КаталогФайла + "\" + ТипКласса.КлючевойФайл;
			Команда = Команда + " """ + ПолноеИмяФайла + """ ";
		ИначеЕсли ТипКласса.Имя  = "ServerAdminScope" Тогда
			ПолноеИмяФайла = КаталогФайла + "\" + ТипКласса.КлючевойФайл;
			//Команда = Команда + " """ + ПолноеИмяФайла + """ /n /i:user";
			Команда = Команда + " """ + ПолноеИмяФайла + """ /i:user";
		Иначе
			РезультатКоманды = "Неизвестный тип COM класса """ + ТипКласса.Имя + """ платформы 1С";
		КонецЕсли; 
		Если Не ПоказыватьРезультатРегистрации Тогда
			Команда = Команда + " /s";
		КонецЕсли; 
	Иначе
		#Если Не Клиент Тогда
			Если Не ЗначениеЗаполнено(пКаталогФайла) Тогда
				ВызватьИсключение "Регистрация COM класса типа """ + ТипКласса.Имя + """ отменена, т.к. определение пути к исполняемому файлу клиентского приложения на сервере не реализовано.";
			КонецЕсли; 
		#КонецЕсли
		Если Не ЗначениеЗаполнено(РезультатКоманды) Тогда
			ПолноеИмяФайла = КаталогФайла + "\" + ТипКласса.КлючевойФайл;
			Команда = """" + ПолноеИмяФайла + """ /regserver";
		КонецЕсли; 
	КонецЕсли;
	Если ЗначениеЗаполнено(Команда) Тогда
		Файл = Новый Файл(ПолноеИмяФайла);
		Если Не Файл.Существует() Тогда
			ВызватьИсключение "При регистрации COM класса типа """ + ТипКласса.Имя + """ не найден файл """ + Файл.ПолноеИмя + """
				|Переустановите платформу с необходимой компонентой";
		Иначе
			РезультатКоманды = ирОбщий.ВыполнитьКомандуОСЛкс(Команда,,, Истина); // Тут всегда пустой результат
		КонецЕсли; 
	КонецЕсли;
	#Если Сервер И Не Клиент Тогда
		Текст = "серверном контексте";
	#Иначе
		Текст = "клиентском контексте";
	#КонецЕсли
	ПроцессОС = ирОбщий.ПолучитьПроцессОСЛкс("текущий");
	//#Если Клиент Тогда
	//	Текст = Текст + " из процесса " + ПроцессОС.Name + "(" + XMLСтрока(ПроцессОС.ProcessID) + ")";
	//#КонецЕсли 
	ТекстСообщения = "Выполнена локальная регистрация COM класса """ + ТипКласса.Имя + """ " + СборкаПлатформы + " в " + Текст;
	ирОбщий.СообщитьЛкс(ТекстСообщения);
	//#Если Клиент Тогда
	//	Сообщить("! После регистрации для возможности использовать класс может потребоваться перезапуск процесса 1С !", СтатусСообщения.Внимание);
	//#КонецЕсли 
	Возврат РезультатКоманды;

КонецФункции

Процедура ЗаполнитьКлассыИзКоллекции(Компоненты, x64)

	Компоненты.Populate();
	Для Каждого Компонента Из Компоненты Цикл
		ИмяКласса = Компонента.Name;
		Если Найти(НРег(ИмяКласса), "v8") = 1 Тогда 
			Для Каждого СтрокаТипаКласса Из ТипыComКлассов Цикл
				Если Найти(НРег(ИмяКласса), НРег(СтрокаТипаКласса.ИмяКлассаПослеV8)) = 4 Тогда
					ИдентификаторКомпоненты = Компонента.Key;
					НомерИзданияПлатформы = Число(Сред(ИмяКласса, 3, 1));
					Если СтрокаТипаКласса.Внутрипроцессный Тогда
						ПолноеИмяФайла = Компонента.Value("InprocServer32");
					Иначе
						ПолноеИмяФайла = Компонента.Value("LocalServer32");
					КонецЕсли; 
					ИмяКласса = "V8" + НомерИзданияПлатформы + СтрокаТипаКласса.ИмяКлассаПослеV8;
					СтрокиКлассов = Классы.НайтиСтроки(Новый Структура("ИмяКласса, x64", ИмяКласса, x64));
					Если СтрокиКлассов.Количество() > 0 Тогда
						СтрокаПриложения = СтрокиКлассов[0];
						СтрокаПриложения.ИмяФайла = ПолноеИмяФайла;
						СтрокаПриложения.ИдентификаторКласса = Компонента.Key;
						СтрокаПриложения.Зарегистрирован = Истина;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

Процедура ОбновитьТаблицуКлассов(ЗаполнятьТолькоВнешниеСоединения = Ложь) Экспорт 
	
	Классы.Очистить();
	Приложения.Очистить();
	МассивРазрядностей = Новый Массив();
	МассивРазрядностей.Добавить(Ложь);
	Если ирКэш.Это64битнаяОСЛкс() Тогда
		МассивРазрядностей.Добавить(Истина);
		//Если ЗаполнятьТолькоВнешниеСоединения Тогда 
		//	Если КэшКонтекстаИис.Это64битныйПроцессИис() Тогда
		//		МассивРазрядностей.Удалить(0);
		//	Иначе
		//		МассивРазрядностей.Удалить(1);
		//	КонецЕсли; 
		//КонецЕсли; 
	КонецЕсли; 
	
	ИзданияПлатформы = Новый СписокЗначений;
	Для Счетчик = 1 По 3 Цикл
		ИзданияПлатформы.Добавить("8" + Счетчик, "8." + Счетчик);
	КонецЦикла;
	Для Каждого ИзданиеПлатформы Из ИзданияПлатформы Цикл
		Для Каждого ТипКласса Из ТипыComКлассов Цикл
			Если Истина
				И ЗаполнятьТолькоВнешниеСоединения 
				И ТипКласса.Имя <> "ComConnector"
			Тогда
				Продолжить;
			КонецЕсли; 
			Для Каждого x64 Из МассивРазрядностей Цикл
				Если Не ТипКласса.Внутрипроцессный И x64 И ИзданиеПлатформы.Значение < "83" Тогда
					Продолжить;
				КонецЕсли; 
				ИмяКласса = "V" + ИзданиеПлатформы.Значение + ТипКласса.ИмяКлассаПослеV8;
				СтрокаКласса = Классы.Добавить();
				СтрокаКласса.ИзданиеПлатформы = ИзданиеПлатформы.Представление;
				СтрокаКласса.ИмяКласса = ИмяКласса;
				СтрокаКласса.ВнутриПроцессный = ТипКласса.Внутрипроцессный;
				СтрокаКласса.ТипКласса = ТипКласса.Имя;
				СтрокаКласса.x64 = x64;
			КонецЦикла;
		КонецЦикла;
		СтрокаПриложения = Приложения.Добавить();
		СтрокаПриложения.ИзданиеПлатформы = ИзданиеПлатформы.Значение;
		СтрокаПриложения.ИмяКласса = "V" + ИзданиеПлатформы.Значение + ".ComConnector";
	КонецЦикла; 
	
	КаталогПриложений = Новый COMОбъект("COMAdmin.COMAdminCatalog");
	КаталогПриложений.Connect(ИмяКомпьютера());
	Если ирКэш.Это64битнаяОСЛкс() Тогда
		Компоненты = КаталогПриложений.GetCollection("InprocServers");
		ЗаполнитьКлассыИзКоллекции(Компоненты, Истина);
		Компоненты = КаталогПриложений.GetCollection("WOWLegacyServers");
		ЗаполнитьКлассыИзКоллекции(Компоненты, Ложь);
	КонецЕсли; 
	Компоненты = КаталогПриложений.GetCollection("LegacyServers");
	ЗаполнитьКлассыИзКоллекции(Компоненты, ирКэш.Это64битнаяОСЛкс());

	ПриложенияСистемы = КаталогПриложений.GetCollection("Applications");
	ПриложенияСистемы.Populate();
	Для Каждого Приложение Из ПриложенияСистемы Цикл
		Если Ложь
			Или Приложение.Key = "{9EB3B62C-79A2-11D2-9891-00C04F79AF51}" 
			Или Приложение.Key = "{7B4E1F3C-A702-11D2-A336-00C04F7978E0}" 
			Или Приложение.Key = "{01885945-612C-4A53-A479-E97507453926}" 
			Или Приложение.Key = "{02D4B3F1-FD88-11D1-960D-00805FC79235}" 
		Тогда
			Продолжить;
		КонецЕсли; 
		СтрокаПриложения = Неопределено;
		Компоненты = ПриложенияСистемы.GetCollection("Components", Приложение.Key);
		Попытка
			Компоненты.Populate();
		Исключение
			Компоненты = Неопределено;
			ирОбщий.СообщитьЛкс("Ошибка получения компонент приложения """ + Приложение.Value("Name") + """: " + ОписаниеОшибки(), СтатусСообщения.Внимание);
			Продолжить;
		КонецПопытки; 
		Если Компоненты <> Неопределено Тогда
			Для Каждого Компонента Из Компоненты Цикл
				ИмяКласса = Компонента.Value("ProgID");
				Если Истина
					И Найти(НРег(ИмяКласса), "v8") = 1 
					И Найти(НРег(ИмяКласса), ".comconnector") = 4 
				Тогда
					НомерИзданияПлатформы = Число(Сред(ИмяКласса, 3, 1));
					ИмяКласса = "V8" + НомерИзданияПлатформы + ".ComConnector";
					ПолноеИмяФайла = Компонента.Value("DLL");
					Это64битнаяКомпонента = Найти(НРег(ПолноеИмяФайла), "(x86)") = 0 И ирКэш.Это64битнаяОСЛкс(); // Ненадежно
					СтрокаПриложения = НайтиЗаполнитьСтрокуДоступногоПриложения(ИмяКласса, Приложение, Это64битнаяКомпонента, ПриложенияСистемы);
					СтрокиКлассов = Классы.НайтиСтроки(Новый Структура("ИмяКласса, x64", ИмяКласса, Это64битнаяКомпонента));
					Если СтрокиКлассов.Количество() > 0 Тогда
						СтрокаКласса = СтрокиКлассов[0];
						СтрокаКласса.ИмяФайла = ПолноеИмяФайла;
						СтрокаКласса.ИдентификаторКласса = Компонента.Key;
						СтрокаКласса.Зарегистрирован = Истина;
					КонецЕсли; 
				КонецЕсли; 
				Прервать;
			КонецЦикла;
		КонецЕсли; 
		Если ирКэш.Это64битнаяОСЛкс() Тогда
			Компоненты = ПриложенияСистемы.GetCollection("LegacyComponents", Приложение.Key);
			Компоненты.Populate();
			Для Каждого Компонента Из Компоненты Цикл
				ИмяКласса = Компонента.Value("ProgID");
				Если Истина
					И Найти(НРег(ИмяКласса), "v8") = 1 
					И Найти(НРег(ИмяКласса), ".comconnector") = 4 
				Тогда
					НомерИзданияПлатформы = Число(Сред(ИмяКласса, 3, 1));
					ИмяКласса = "V8" + НомерИзданияПлатформы + ".ComConnector";
					СтрокаПриложения = НайтиЗаполнитьСтрокуДоступногоПриложения(ИмяКласса, Приложение, Ложь, ПриложенияСистемы);
					СтрокиКлассов = Классы.НайтиСтроки(Новый Структура("ИмяКласса, x64", ИмяКласса, Ложь));
					Если СтрокиКлассов.Количество() > 0 Тогда
						СтрокаКласса = СтрокиКлассов[0];
						ПолноеИмяФайла = Компонента.Value("InprocServer32");
						СтрокаКласса.ИдентификаторКласса = Компонента.Key;
						СтрокаКласса.ИмяФайла = ПолноеИмяФайла;
						СтрокаКласса.Зарегистрирован = Истина;
					КонецЕсли; 
				КонецЕсли; 
				Прервать;
			КонецЦикла;
		КонецЕсли; 
		Если СтрокаПриложения = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Если Приложение.Value("Activation") > 0 Тогда
			СтрокаПриложения.ОтдельнаяАктивация = Истина;
		КонецЕсли;
		СтрокаПриложения.Создать = Истина;
		СтрокаПриложения.ВремяОжидания = Приложение.Value("RecycleExpirationTimeout");
		СтрокаПриложения.ИмяПользователя = Приложение.Value("Identity");
		СтрокаПриложения.ПредельноеЧислоАктиваций = Приложение.Value("RecycleActivationLimit");
		СтрокаПриложения.РазмерГруппы = Приложение.Value("ConcurrentApps");
		СтрокаПриложения.Включено = Приложение.Value("IsEnabled");
		НомерИзданияПлатформы = Прав(Приложение.Name, 1);
		Роли = ПриложенияСистемы.GetCollection("Roles", Приложение.Key);
		Роли.Populate();
		Для Каждого Роль Из Роли Цикл
			 Прервать;
		КонецЦикла;
		//Пользователи = Роли.GetCollection("UsersInRole", Роль.Key);
		//Пользователи.Populate();
		//Для Каждого Пользователь Из Пользователи Цикл
		//	 Прервать;
		//КонецЦикла;
		//Прервать;
	КонецЦикла;
	Для Каждого СтрокаТаблицы Из Классы Цикл
		Если ЗначениеЗаполнено(СтрокаТаблицы.ИмяФайла) Тогда
			ФайлWMI = ирОбщий.ПолучитьФайлWMIЛкс(СтрокаТаблицы.ИмяФайла);
			Если ФайлWMI <> Неопределено Тогда
				СтрокаТаблицы.ФайлСуществует = Истина;
			КонецЕсли; 
			Фрагменты = ирОбщий.СтрРазделитьЛкс(СтрЗаменить(СтрокаТаблицы.ИмяФайла, "\\", "\"), "\");
			Фрагменты.Удалить(Фрагменты.ВГраница());
			Фрагменты.Удалить(Фрагменты.ВГраница());
			КаталогСборки = ирОбщий.СтрСоединитьЛкс(Фрагменты, "\") + "\";
			СтрокаСборкиПлатформы = СборкиПлатформы.Найти(НРег(КаталогСборки), "НКаталог");
			Если ЗначениеЗаполнено(СтрокаСборкиПлатформы) Тогда
				СтрокаТаблицы.СборкаПлатформы = ПредставлениеСборкиПлатформы(СтрокаСборкиПлатформы, СтрокаТаблицы.Внутрипроцессный);
			Иначе
				Если ФайлWMI <> Неопределено Тогда
					СтрокаТаблицы.СборкаПлатформы = ФайлWMI.Version;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли; 
	КонецЦикла;
	Классы.Сортировать("ИзданиеПлатформы Убыв, ТипКласса");
	
	Для Каждого СтрокаПриложения Из Приложения Цикл
		НайденныеКлассы = Классы.НайтиСтроки(Новый Структура("ИмяКласса, x64", СтрокаПриложения.ИмяКласса, Ложь));
		Если НайденныеКлассы.Количество() > 0 Тогда
			СтрокаПриложения.Доступен32 = НайденныеКлассы[0].Зарегистрирован;
		КонецЕсли; 
		Если Не СтрокаПриложения.Доступен32 Тогда
			СтрокаПриложения.x64 = ирКэш.Это64битнаяОСЛкс();
		КонецЕсли; 
		Если ирКэш.Это64битнаяОСЛкс() Тогда
			НайденныеКлассы = Классы.НайтиСтроки(Новый Структура("ИмяКласса, x64", СтрокаПриложения.ИмяКласса, Истина));
			Если НайденныеКлассы.Количество() > 0 Тогда
				СтрокаПриложения.Доступен64 = НайденныеКлассы[0].Зарегистрирован;
			КонецЕсли; 
			Если Не СтрокаПриложения.Доступен64 Тогда
				СтрокаПриложения.x64 = Ложь;
			КонецЕсли; 
		КонецЕсли;
		Если Не СтрокаПриложения.ОтдельнаяАктивация Тогда
			СтрокаПриложения.x64 = ирКэш.Это64битныйПроцессЛкс();
		КонецЕсли; 
		НайденныеКлассы = Классы.НайтиСтроки(Новый Структура("ИмяКласса, x64", СтрокаПриложения.ИмяКласса, СтрокаПриложения.x64));
		Если НайденныеКлассы.Количество() > 0 Тогда
			СтрокаПриложения.СборкаПлатформы = НайденныеКлассы[0].СборкаПлатформы;
		КонецЕсли; 
	КонецЦикла;
	Приложения.Сортировать("ИмяКласса Убыв");
	
КонецПроцедуры

Функция НайтиЗаполнитьСтрокуДоступногоПриложения(ИмяКласса, Приложение, x64, УстановленныеПриложения)
	
	СтрокаПриложения = Приложения.НайтиСтроки(Новый Структура("ИмяКласса", ИмяКласса))[0];
	СтрокаПриложения.ИмяПриложения = Приложение.Name;
	СтрокаПриложения.ИдентификаторКласса = Приложение.Key;
	СтрокаПриложения.x64 = x64;
	
	ДоступенПользователям = "";
	Роли = УстановленныеПриложения.GetCollection("Roles", Приложение.Key);
	Роли.Populate();
	Для Каждого Роль Из Роли Цикл
		Пользователи = Роли.GetCollection("UsersInRole", Роль.Key);
		Пользователи.Populate();
		Для Каждого Пользователь Из Пользователи Цикл
			Если ДоступенПользователям <> "" Тогда
				ДоступенПользователям = ДоступенПользователям + ",";
			КонецЕсли; 
			ДоступенПользователям = ДоступенПользователям + Пользователь.Value("User");
		КонецЦикла;
	КонецЦикла;
	СтрокаПриложения.ДоступенПользователям = ДоступенПользователям;
	Возврат СтрокаПриложения;

КонецФункции

Функция ПредставлениеСборкиПлатформы(Знач СтрокаСборки, Знач Внутрипроцессный = Ложь) Экспорт 
	
	ПредставлениеСборки = СтрокаСборки.СборкаПлатформы;
	//Если Не Внутрипроцессный Тогда
	//	ПредставлениеСборки = ПредставлениеСборки + " - " + ?(СтрокаСборки.x64, "64", "32");
	//КонецЕсли;
	Возврат ПредставлениеСборки;

КонецФункции

Функция ЗаполнитьТипыCOMКлассов() Экспорт 
	
	ТабличныйДокумент = ПолучитьМакет("ТипыCOMКлассов");
	Результат = ирОбщий.ТаблицаЗначенийИзТабличногоДокументаЛкс(ТабличныйДокумент);
	ТипыComКлассов.Загрузить(Результат);
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтотОбъект.ТекущаяСборкаПлатформы = СистемнаяИнформация.ВерсияПриложения;
	ЭтотОбъект.ТекущийПользовательОС = ирКэш.ТекущийПользовательОСЛкс();
	ЭтотОбъект.x64Текущая = ирКэш.Это64битныйПроцессЛкс();
	Возврат Результат;
	
КонецФункции

//ирПортативный лФайл = Новый Файл(ИспользуемоеИмяФайла);
//ирПортативный ПолноеИмяФайлаБазовогоМодуля = Лев(лФайл.Путь, СтрДлина(лФайл.Путь) - СтрДлина("Модули\")) + "ирПортативный.epf";
//ирПортативный #Если Клиент Тогда
//ирПортативный 	Контейнер = Новый Структура();
//ирПортативный 	Оповестить("ирПолучитьБазовуюФорму", Контейнер);
//ирПортативный 	Если Не Контейнер.Свойство("ирПортативный", ирПортативный) Тогда
//ирПортативный 		ирПортативный = ВнешниеОбработки.ПолучитьФорму(ПолноеИмяФайлаБазовогоМодуля);
//ирПортативный 		ирПортативный.Открыть();
//ирПортативный 	КонецЕсли; 
//ирПортативный #Иначе
//ирПортативный 	ирПортативный = ВнешниеОбработки.Создать(ПолноеИмяФайлаБазовогоМодуля, Ложь); // Это будет второй экземпляр объекта
//ирПортативный #КонецЕсли
//ирПортативный ирОбщий = ирПортативный.ПолучитьОбщийМодульЛкс("ирОбщий");
//ирПортативный ирКэш = ирПортативный.ПолучитьОбщийМодульЛкс("ирКэш");
//ирПортативный ирСервер = ирПортативный.ПолучитьОбщийМодульЛкс("ирСервер");
//ирПортативный ирПривилегированный = ирПортативный.ПолучитьОбщийМодульЛкс("ирПривилегированный");
