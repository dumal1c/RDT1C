Перем мЛеваяСкобкаПараметра;
Перем мПраваяСкобкаПараметра;
Перем ШаблонИмениПараметра;
Перем ВремИмяПараметра;
Перем мТекущаяСтрокаПараметра;
Перем мИмяОткрытогоФайла;
Перем мРасширениеФайла;
Перем мСтароеИмяПараметра;
Перем мОписаниеРасширенияФайла;
Перем мНайденныеГруппы;
Перем мПлатформа;
Перем RegExp;
Перем RegExpLocal;
Перем шИмя;
Перем мСтарыйПроверочныйТекст;
Перем мСтруктураВосстановления;

Процедура ПриОткрытии()
	
	ТаблицаИзМакета = ирОбщий.ПолучитьТаблицуИзТабличногоДокументаЛкс(ПолучитьМакет("ДоступныеЭлементы"));
	ДоступныеЭлементы.Загрузить(ТаблицаИзМакета);
	Если НачальноеЗначениеВыбора <> Неопределено Тогда
		ЭтаФорма.Выражение = НачальноеЗначениеВыбора.Выражение;
	КонецЕсли; 
	Если ТипЗнч(ВладелецФормы) = Тип("Форма") Тогда
		ВладелецФормы.Панель.Доступность = Ложь;
	КонецЕсли;
	ЭлементыФормы.ПолеТекстаВыражения.Значение = Выражение;
	
	ИмяФайлаВосстановления = ирОбщий.ПроверитьВыбратьФайлВосстановленияКонсолиЛкс(мСтруктураВосстановления);
	Если ИмяФайлаВосстановления <> "" Тогда
		мИмяОткрытогоФайла = ИмяФайлаВосстановления;
		АвтообновлениеПроверочногоТекста = Ложь;
	Иначе
		// Попытаемся загрузить последний открывавшийся файл
		мИмяОткрытогоФайла = ирОбщий.ВосстановитьЗначениеЛкс("ирКонструкторРегулярногоВыражения_ИмяФайла");
		Если мИмяОткрытогоФайла = НеОпределено Тогда
			мИмяОткрытогоФайла = "";
		КонецЕсли;
	КонецЕсли;
	Если ПустаяСтрока(мИмяОткрытогоФайла) Тогда
		СоздатьФайл();
	Иначе
		//ЗагрузитьИзФайла(); // 8.3.14+ показывается пустое поле
		ПодключитьОбработчикОжидания("ЗагрузитьИзФайлаОтложенно", 0.1, Истина);
	КонецЕсли;
	Если ИмяФайлаВосстановления <> "" Тогда
		Модифицированность = Истина;
		УдалитьФайлы(ИмяФайлаВосстановления);
	КонецЕсли; 
	
	ЭлементыФормы.Параметры.ОтборСтрок.ЭтоВариант.Установить(Ложь);

КонецПроцедуры

Функция СоздатьФайл()
	
	мИмяОткрытогоФайла = "";
	ОчиститьПараметры();
	ЭлементыФормы.ПроверочныйТекст.УстановитьТекст("");
	мСтарыйПроверочныйТекст = ПроверочныйТекст();
	ДобавитьПервуюСтроку();
	УстановитьТекущуюСтрокуПараметра();
	ЭтаФорма.ИгнорироватьРегистр = Истина;
	ЭтаФорма.Многострочный = Ложь;
	ЭтаФорма.Модифицированность = Ложь;

КонецФункции

Процедура ДобавитьПервуюСтроку()
	
	СтрокаПараметра = Параметры.Добавить();
	СтрокаПараметра.Имя = "Корень";
	ОбновитьИмяВНижнемРегистре(СтрокаПараметра);

КонецПроцедуры

Процедура ОбновитьИмяВНижнемРегистре(Знач СтрокаПараметра = Неопределено)
	
	Если СтрокаПараметра = Неопределено Тогда
		СтрокаПараметра = ЭлементыФормы.Параметры.ТекущаяСтрока;
	КонецЕсли; 
	СтрокаПараметра.НИмя = НРег(СтрокаПараметра.Имя);

КонецПроцедуры

Процедура ПриЗакрытии()
	
	ирОбщий.УдалитьФайлВосстановленияКонсолиСБлокировкойЛкс(мСтруктураВосстановления);
	ирОбщий.СохранитьЗначениеЛкс("ирКонструкторРегулярногоВыражения_ИмяФайла", мИмяОткрытогоФайла);
	Если ТипЗнч(ВладелецФормы) = Тип("Форма") Тогда
		ВладелецФормы.Панель.Доступность = Истина;
	КонецЕсли;
	
КонецПроцедуры

Функция СохранитьВФайл(ЗапрашиватьСохранение = Ложь, ЗапрашиватьИмяФайла = Ложь, Знач ИмяФайла = Неопределено, СброситьМодифицированность = Истина)

	Если ИмяФайла = Неопределено Тогда
		ИмяФайла = мИмяОткрытогоФайла;
	КонецЕсли; 
	Если ЗапрашиватьСохранение Тогда
		ОбновитьВыражениеПараметра();
		Если Не ПроверитьПрограммныйКод() Тогда 
			Ответ = Вопрос("Выражение содержит ошибки. Продолжить?", РежимДиалогаВопрос.ОКОтмена);
			Если Ответ <> КодВозвратаДиалога.ОК Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	СохраняемыеДанные = Новый Структура;
	СохраняемыеДанные.Вставить("Параметры", Параметры.Выгрузить());
	СохраняемыеДанные.Вставить("ПроверочныйТекст", ЭлементыФормы.ПроверочныйТекст.ПолучитьТекст());
	СохраняемыеДанные.Вставить("Многострочный", Многострочный);
	СохраняемыеДанные.Вставить("ИгнорироватьРегистр", ИгнорироватьРегистр);
	//ирОбщий.СохранитьЗначениеВФайлЛкс(СохраняемыеДанные, ИмяСохраняемогоФайла);
	ДиалогВыбораФайла = ирОбщий.ДиалогВыбораФайлаЛкс(Ложь, мРасширениеФайла, мОписаниеРасширенияФайла);
	ФайлВыбран = ирОбщий.СохранитьФайлВКонсолиСВосстановлениемЛкс(ДиалогВыбораФайла, ИмяФайла, мИмяОткрытогоФайла, СохраняемыеДанные, мСтруктураВосстановления, ЗапрашиватьИмяФайла);
	Если ФайлВыбран Тогда
		мИмяОткрытогоФайла = ДиалогВыбораФайла.ПолноеИмяФайла;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	Если СброситьМодифицированность Тогда
		ЭтаФорма.Модифицированность = Ложь;
	КонецЕсли; 
	Обновить();
	Возврат Истина;

КонецФункции // СохранитьИзменения()

Функция ПроверитьПрограммныйКод()
	
	Возврат Истина;
	
КонецФункции

Процедура ОсновныеДействияФормыОК(Кнопка)
	
	//СохранитьИзменения();
	
КонецПроцедуры

Процедура ПередЗакрытием(Отказ, СтандартнаяОбработка)
	
	Если Не ПроверитьСохранитьПолноеВыражение() Тогда 
		Отказ = Истина;
	КонецЕсли; 
	
КонецПроцедуры

Функция ПроверитьСохранитьПолноеВыражение()
	
	Отказ = Ложь;
	Если Модифицированность Тогда
		Ответ = Вопрос("Выражение было изменено. Сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			Отказ = Не СохранитьВФайл();
		ИначеЕсли Ответ = КодВозвратаДиалога.Отмена Тогда
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Не Отказ;

КонецФункции

Процедура СтруктураКоманднойПанелиНажатие(Кнопка)
	
	ирОбщий.ОткрытьСтруктуруКоманднойПанелиЛкс(ЭтаФорма, Кнопка);
	
КонецПроцедуры

Процедура ОсновныеДействияФормыСтруктураФормы(Кнопка)
	
	ирОбщий.ОткрытьСтруктуруФормыЛкс(ЭтаФорма);
	
КонецПроцедуры

Процедура ПанельДоступныеЭлементыПриСменеСтраницы(Элемент, ТекущаяСтраница)
	
	ЭлементОтбора = ЭлементыФормы.ДоступныеЭлементы.ОтборСтрок.Категория;
	ЭлементОтбора.Установить(ЭлементыФормы.ПанельДоступныеЭлементы.ТекущаяСтраница.Имя);
	ЭлементОтбора.Использование = ЭлементыФормы.ПанельДоступныеЭлементы.ТекущаяСтраница <> ЭлементыФормы.ПанельДоступныеЭлементы.Страницы.Все;
	
КонецПроцедуры

Процедура КПВыражениеВынестиВПараметры(Кнопка)
	
	Перем Значение;
	Фокус = ЭлементыФормы.ПолеТекстаВыражения;
	ВыделенныйТекст = Фокус.ВыделенныйТекст;
	ИзвлечьФорматирование(ВыделенныйТекст);
	Если ПустаяСтрока(ВыделенныйТекст) Тогда
		Возврат;
	КонецЕсли;
	ИмяПараметра = ""; 
	Для каждого СтрокаПараметра Из Параметры Цикл
		//Если Параметр.Пометка Тогда
			Если ирОбщий.СтрокиРавныЛкс(СтрокаПараметра.Значение, ВыделенныйТекст) Тогда
				ИмяПараметра = СтрокаПараметра.Имя;
				Прервать;
			КонецЕсли;
		//КонецЕсли;
	КонецЦикла;
	Если ЗначениеЗаполнено(ИмяПараметра) Тогда
		Ответ = Вопрос("Хотите связать выбранный фрагмент с параметром " + ИмяПараметра + "?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Да);
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			ИмяПараметра = "";
		КонецЕсли;
	КонецЕсли; 
	Если ПустаяСтрока(ИмяПараметра) Тогда
		Если НЕ ВвестиСтроку(ИмяПараметра, ВыделенныйТекст + " - имя?", 0) Тогда
			Возврат;
		КонецЕсли;
		Если Не ирОбщий.ЛиИмяПеременнойЛкс(ИмяПараметра) Тогда
			Предупреждение("Введенная строка не соответствует требованиям имени параметра");
			Возврат;
		КонецЕсли; 
		Если СтрокаПараметраПоИмени(ИмяПараметра) <> Неопределено Тогда
			Предупреждение("Такое имя уже существует.");
			Возврат;
		КонецЕсли;
		СтрокаПараметра = Параметры.Вставить(Параметры.Индекс(мТекущаяСтрокаПараметра) + 1);
		СтрокаПараметра.Имя = ИмяПараметра;
		ОбновитьИмяВНижнемРегистре(СтрокаПараметра);
		СтрокаПараметра.Значение = ВыделенныйТекст;
		ПроверитьСинтаксис(СтрокаПараметра);
	КонецЕсли;
	ЭтаФорма.Модифицированность = Истина;
	ПолноеИмяТэга = мЛеваяСкобкаПараметра + ИмяПараметра + мПраваяСкобкаПараметра;
	ВключитьСтроку(ПолноеИмяТэга);
	ОбновитьВыражениеПараметра();
	
КонецПроцедуры

Функция СтрокаБезФорматирования(Знач Текст)
	
	RegExp.Multiline = Ложь;
	RegExp.Global = Истина;
	RegExp.IgnoreCase = Истина;
	RegExp.Pattern = "\n\s*";
	Результат = RegExp.Replace(Текст, "");
	Возврат Результат;
	
КонецФункции

Функция ИзвлечьФорматирование(ФорматированнаяСтрока)
	
	Перем НачСтр, НачКол, КонСтр, КонКол;
	Форматирование = Новый Массив;
	Вхождения = ирОбщий.НайтиРегулярноеВыражениеЛкс(ФорматированнаяСтрока, "\t|\n",,,, Ложь);
	#Если Сервер И Не Сервер Тогда
	    Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
	#КонецЕсли
	Для каждого СтрокаРезультата Из Вхождения Цикл
		Поз = СтрокаРезультата.Позиция;
		Сим = СтрокаРезультата.Текст;
		Если Сим = Символы.Таб Тогда
			Форматирование.Добавить(Поз);
		Иначе
			Форматирование.Добавить(-Поз);
		КонецЕсли;
	КонецЦикла;
	ФорматированнаяСтрока = СтрЗаменить(ФорматированнаяСтрока, Символы.Таб, "");
	ФорматированнаяСтрока = СтрЗаменить(ФорматированнаяСтрока, Символы.ПС, "");
	Если Форматирование.Количество() <> 0  Тогда
		Форматирование = ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(Форматирование, ",");
	Иначе
		Форматирование = "";
	КонецЕсли;
	Возврат Форматирование;
	
КонецФункции

Функция ИмеетсяФорматирование(ФорматированнаяСтрока)
	
	Форматирование = Новый Массив;
	
	RegExp.Multiline = Ложь;
	RegExp.Global = Истина;
	RegExp.IgnoreCase = Истина;
	RegExp.Pattern = "\t|\n";
	
	Возврат RegExp.Test (ФорматированнаяСтрока);
	
КонецФункции

Процедура ВключитьСтроку(ТекущаяПоследовательность)
	
	Перем НачСтр, НачКол, КонСтр, КонКол;
	//Если ИмеетсяФорматирование(Выражение) Тогда
	//КонецЕсли;
	
	Фокус = ЭлементыФормы.ПолеТекстаВыражения;
	Фокус.ПолучитьГраницыВыделения(НачСтр, НачКол, КонСтр, КонКол);
	ЭтаФорма.ТекущийЭлемент = Фокус;
	
	
	ВыделенныйТекст = Фокус.ВыделенныйТекст;
	Переформатировать = ИмеетсяФорматирование(ВыделенныйТекст);
	Если Переформатировать Тогда
		ИзвлечьФорматирование(ВыделенныйТекст);
		КонСтр = НачСтр;
		КонКол = НачКол + СтрДлина(ВыделенныйТекст);
		
		Фокус.ВыделенныйТекст = ВыделенныйТекст;
		Фокус.УстановитьГраницыВыделения(НачСтр, НачКол, КонСтр, КонКол);
	КонецЕсли;
	
	Поз = Найти(ТекущаяПоследовательность, "#");
	Если Поз = 0 Тогда
		Поз = СтрДлина(ТекущаяПоследовательность);
	Иначе
		ТекущаяПоследовательность = СтрЗаменить(ТекущаяПоследовательность, "#", "");
		Поз = Поз - 1;
	КонецЕсли;
	КонКол = НачКол + Поз;
	
	Фокус.ВыделенныйТекст = ТекущаяПоследовательность;
	Фокус.УстановитьГраницыВыделения(НачСтр, КонКол, КонСтр, КонКол);
	
	//Если Переформатировать Тогда
	//	ОтформатироватьВыражение();
	//КонецЕсли;

КонецПроцедуры

Процедура КПВыражениеКопироватьРезультат(Кнопка)
	
	
	
КонецПроцедуры

Процедура КПВыражениеСгенерироватьПрограммныйКод(Кнопка)
	
	ПрограммныйКод = "";
	ПрограммныйКод = ПрограммныйКод + "// {Шаблон.Начало}" + Символы.ПС;
	Для ИндексПараметра = 0 По Параметры.Количество() - 1 Цикл
		СтрокаПараметра = Параметры[Параметры.Количество() - 1 - ИндексПараметра];
		ПрограммныйКод = ПрограммныйКод + "// " + ?(СтрокаПараметра.ЭтоВариант, "-", "+") + " " + мЛеваяСкобкаПараметра + СтрокаПараметра.Имя + мПраваяСкобкаПараметра + " = " 
			+ СтрокаБезФорматирования(СтрокаПараметра.Значение) + Символы.ПС;
	КонецЦикла;
	ПрограммныйКод = ПрограммныйКод + "// {Шаблон.Конец}" + Символы.ПС;
	// ть34що9ш40
	Переменные = Новый Массив;
	СтрокиПараметров = Параметры.НайтиСтроки(Новый Структура("ЭтоВариант", Ложь));
	Для Счетчик = СтрокиПараметров.Найти(ЭлементыФормы.Параметры.ТекущаяСтрока) + 1 По СтрокиПараметров.Количество() Цикл
		ИндексРодителя = СтрокиПараметров.Количество() - Счетчик;
		СтрокаРодителя = СтрокиПараметров[ИндексРодителя];
		РезультатРодителя = СтрокаРодителя.Значение;
		РезультатРодителя = СтрЗаменить(РезультатРодителя, """", """""");
		Для ИндексПараметра = ИндексРодителя + 1 По СтрокиПараметров.Количество() - 1 Цикл
			СтрокаПараметра = СтрокиПараметров[ИндексПараметра];
			РезультатРодителя = СтрЗаменить(РезультатРодителя, мЛеваяСкобкаПараметра + СтрокаПараметра.Имя + мПраваяСкобкаПараметра, """" + " + " + СтрокаПараметра.Имя + " + """);
		КонецЦикла;
		ПрограммныйКод = ПрограммныйКод + СтрокаРодителя.Имя + " = """ + СтрокаБезФорматирования(РезультатРодителя) + """;" + Символы.ПС;
		Переменные.Добавить(СтрокаРодителя.Имя);
	КонецЦикла;
	ПрограммныйКод = ПрограммныйКод + "// {ОписаниеРегулярногоВыражения.Конец}" + Символы.ПС;
	
	// Независимое выполнение
	ПрограммныйКод = ПрограммныйКод + "
	|// Независимое выполнение
	|RegExp = Новый COMОбъект(""VBScript.RegExp"");
	|RegExp.Global = Истина;
	|RegExp.Multiline = " + ?(Многострочный, "ИСТИНА", "ЛОЖЬ") + ";
	|RegExp.IgnoreCase = " + ?(ИгнорироватьРегистр, "ИСТИНА", "ЛОЖЬ") + ";
	|RegExp.Pattern = " + Параметры[0].Имя + ";
	|Вхождения = RegExp.Execute(ТекстГдеИскать);
	|Для каждого Вхождение Из Вхождения Цикл
	|	Начало = Вхождение.FirstIndex;
	|	Длина = Вхождение.Length;
	|	Значение = Вхождение.Value;
	|";
	Для Каждого СтрокаПодгруппы Из Подгруппы Цикл
		Если СтрокаПодгруппы.Индекс < 0 Тогда
			Продолжить;
		КонецЕсли; 
		ПрограммныйКод = ПрограммныйКод + "	" + СтрокаПодгруппы.Имя + "Значение = Вхождение.SubMatches(" + СтрокаПодгруппы.Индекс + ");" + Символы.ПС;
	КонецЦикла; 
	ПрограммныйКод = ПрограммныйКод + "КонецЦикла;" + Символы.ПС;
	
	// Выполнение в ИР
	ИменаПодгрупп = Подгруппы.ВыгрузитьКолонку("Имя");
	ИменаПодгрупп.Удалить(0);
	ПрограммныйКод = ПрограммныйКод + "
	|// Выполнение в подсистеме ""Инструменты разработчика""
	|Вхождения = ирОбщий.НайтиРегулярноеВыражениеЛкс(ТекстГдеИскать, " + Параметры[0].Имя + ", """ + ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(ИменаПодгрупп) + """);
	|	#Если Сервер И Не Сервер Тогда
	|	    Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
	|	#КонецЕсли
	|Для каждого Вхождение Из Вхождения Цикл
	|	Начало = Вхождение.ПозицияВхождения;
	|	Длина = Вхождение.ДлинаВхождения;
	|	Значение = Вхождение.ТекстВхождения;
	|";
	Для Каждого СтрокаПодгруппы Из Подгруппы Цикл
		Если СтрокаПодгруппы.Индекс < 0 Тогда
			Продолжить;
		КонецЕсли; 
		ПрограммныйКод = ПрограммныйКод + "	" + СтрокаПодгруппы.Имя + "Значение = Вхождение." + ИменаПодгрупп[СтрокаПодгруппы.Индекс] + ";" + Символы.ПС;
	КонецЦикла; 
	ПрограммныйКод = ПрограммныйКод + "КонецЦикла;" + Символы.ПС;

	ПрограммныйКод = "// Перем " + ирОбщий.ПолучитьСтрокуСРазделителемИзМассиваЛкс(Переменные) + ";" + Символы.ПС + ПрограммныйКод;
	ПрограммныйКод = "// {ОписаниеРегулярногоВыражения.Начало} конструктор из подсистемы ""Инструменты разработчика"" (http://devtool1c.ucoz.ru)" + Символы.ПС + ПрограммныйКод;
	ирОбщий.ОперироватьСтруктуройЛкс(ПрограммныйКод,, Новый Структура("ТекстГдеИскать", ПроверочныйТекст()));

КонецПроцедуры

Процедура КПВыражениеТестироватьRegexBuddy(Кнопка)
	
	ирОбщий.ПоместитьТекстВБуферОбменаОСЛкс(РазвернутоеВыражение());
	ИсполняемыйФайлRegexBuddy = ирОбщий.ВосстановитьЗначениеЛкс("ИсполняемыйФайлRegexBuddy");
	Если Не ЗначениеЗаполнено(ИсполняемыйФайлRegexBuddy) Тогда
		ДействияФормыНастройки();
		Сообщить("Необходимо указать исполняемый файл RegexBuddy в настройках");
		Возврат;
	КонецЕсли; 
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ПроверочныйТекст());
	ИмяФайлаПроверочногоТекста = ПолучитьИмяВременногоФайла("txt");
	ТекстовыйДокумент.Записать(ИмяФайлаПроверочногоТекста);
	ЗапуститьПриложение("""" + ИсполняемыйФайлRegexBuddy + """ -appname ""1С"" -getfromclipboard -testfile """ + ИмяФайлаПроверочногоТекста + """");
	
КонецПроцедуры

Процедура ПараметрыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ОформлениеСтроки.Ячейки.КолонкаРавно.УстановитьТекст("=");
	Если Не ДанныеСтроки.Корректно Тогда
		ОформлениеСтроки.Ячейки.Значение.ЦветТекста = WebЦвета.Красный;
	КонецЕсли; 
	ОформлениеСтроки.Ячейки.Варианты.Значение = Параметры.НайтиСтроки(Новый Структура("Имя", ДанныеСтроки.Имя)).Количество();
	Если Параметры.НайтиСтроки(Новый Структура("Имя, Корректно", ДанныеСтроки.Имя, Ложь)).Количество() > 0 Тогда
		ОформлениеСтроки.Ячейки.Варианты.ЦветТекста = WebЦвета.Красный;
	КонецЕсли; 
	
КонецПроцедуры

Процедура КПВыражениеВставитьВыражение1С(Кнопка)
	
	Текст = ирОбщий.ПолучитьТекстИзБуфераОбменаОСЛкс();
	Если Не ЗначениеЗаполнено(Текст) Тогда
		Возврат;
	КонецЕсли; 
	Текст = ирОбщий.СтрокаИзВыраженияВстроенногоЯзыкаЛкс(Текст);
	ЗаменитьИВыделитьВыделенныйТекстВыражения(Текст);
	
КонецПроцедуры

Процедура ЗаменитьИВыделитьВыделенныйТекстВыражения(Знач Текст)
	
	ирОбщий.ЗаменитьИВыделитьВыделенныйТекстПоляЛкс(ЭтаФорма, ЭлементыФормы.ПолеТекстаВыражения, Текст);
	ОбновитьВыражениеПараметра();

КонецПроцедуры

Процедура УстановитьТекущуюСтрокуПараметра()
	
	ЭлементыФормы.Параметры.ТекущаяСтрока = Параметры[0];

КонецПроцедуры

Процедура ОчиститьПараметры()
	
	мТекущаяСтрокаПараметра = Неопределено;
	Параметры.Очистить();

КонецПроцедуры

Процедура ПараметрыПриАктивизацииСтроки(Элемент = Неопределено)
	
	Если мТекущаяСтрокаПараметра <> Неопределено Тогда
		мТекущаяСтрокаПараметра.Значение = ЭлементыФормы.ПолеТекстаВыражения.Значение;
	КонецЕсли; 
	мТекущаяСтрокаПараметра = ЭлементыФормы.Параметры.ТекущаяСтрока;
	Если мТекущаяСтрокаПараметра = Неопределено Тогда
		ЭлементыФормы.ПолеТекстаВыражения.Значение = "";
		ЭлементыФормы.ПолеТекстаВыражения.Доступность = Ложь;
		Возврат;
	КонецЕсли; 
	ЭлементыФормы.ПолеТекстаВыражения.Доступность = Истина;
	ЭлементыФормы.ПолеТекстаВыражения.Значение = мТекущаяСтрокаПараметра.Значение;
	ЭлементыФормы.Варианты.ОтборСтрок.НИмя.Установить(ЭлементыФормы.Параметры.ТекущаяСтрока.НИмя);
	ЭлементыФормы.Варианты.ТекущаяСтрока = ЭлементыФормы.Параметры.ТекущаяСтрока;
	ИспользуетсяВ.Очистить();
	ОбращениеКПараметру = мЛеваяСкобкаПараметра + мТекущаяСтрокаПараметра.Имя + мПраваяСкобкаПараметра;
	Для Каждого СтрокаПараметра Из Параметры Цикл
		ПозицияОбращения = Найти(НРег(СтрокаПараметра.Значение), НРег(ОбращениеКПараметру));
		Если ПозицияОбращения = 0 Тогда
			Продолжить;
		КонецЕсли;
		Если ИспользуетсяВ.Найти(СтрокаПараметра.Имя, "Имя") = Неопределено Тогда
			ЗаполнитьЗначенияСвойств(ИспользуетсяВ.Добавить(), СтрокаПараметра, "Имя, Корректно"); 
		КонецЕсли; 
	КонецЦикла;
	ИспользуетсяВ.Сортировать("Имя");
	ОбновитьВыражениеПараметра();

КонецПроцедуры

Процедура КПВариантыДобавить(Кнопка)
	
	СтрокаПараметра = Параметры.Вставить(Параметры.Индекс(мТекущаяСтрокаПараметра) + 1);
	ЗаполнитьЗначенияСвойств(СтрокаПараметра, ЭлементыФормы.Параметры.ТекущаяСтрока); 
	СтрокаПараметра.ЭтоВариант = Истина;
	
КонецПроцедуры

Процедура ВариантыПриАктивизацииСтроки(Элемент)
	
	Если ЭлементыФормы.Варианты.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если мТекущаяСтрокаПараметра <> Неопределено И мТекущаяСтрокаПараметра.Имя = ЭлементыФормы.Варианты.ТекущаяСтрока.Имя Тогда
		мТекущаяСтрокаПараметра.ЭтоВариант = Истина;
	КонецЕсли;
	ЭлементыФормы.Варианты.ТекущаяСтрока.ЭтоВариант = Ложь;
	ЭлементыФормы.Параметры.ТекущаяСтрока = ЭлементыФормы.Варианты.ТекущаяСтрока;
	
КонецПроцедуры

Процедура ПанельВыражениеПриСменеСтраницы(Элемент, ТекущаяСтраница)
	
	ОбновитьВыражениеПараметра();
	
КонецПроцедуры

Процедура ОбновитьВыражениеПараметра()
	
	СтрокаРодителя = ЭлементыФормы.Параметры.ТекущаяСтрока;
	СтрокаРодителя.Значение = ЭлементыФормы.ПолеТекстаВыражения.Значение;
	ЭтаФорма.Подгруппы = ОбновитьСтрокуПараметра(СтрокаРодителя);
	СчетчикиПараметров = Новый Соответствие;
	Для Каждого СтрокаПодгруппы Из Подгруппы Цикл
		НомерПодгруппы = СчетчикиПараметров[СтрокаПодгруппы.Имя];
		Если НомерПодгруппы = Неопределено Тогда
			НомерПодгруппы = 0;
		Иначе
			НомерПодгруппы = НомерПодгруппы + 1;
		КонецЕсли; 
		СчетчикиПараметров[СтрокаПодгруппы.Имя] = НомерПодгруппы;
		СтрокаПодгруппы.Параметр = СтрокаПодгруппы.Имя;
		СтрокаПодгруппы.Имя = СтрокаПодгруппы.Имя + ?(НомерПодгруппы = 0, "", НомерПодгруппы);
	КонецЦикла;
	ЭлементыФормы.Подгруппы.ТекущаяСтрока = Подгруппы[0];
	ЭтаФорма.РазвернутоеВыражение = РазвернутоеВыражение();
	ПроверитьСинтаксис(, Ложь);
	Если АвтообновлениеПроверочногоТекста Тогда
		ОбновитьПроверочныйТекст();
	КонецЕсли; 

КонецПроцедуры

Функция ОбновитьСтрокуПараметра(Знач СтрокаРодителя, Счетчик = Неопределено, Подгруппы = Неопределено, РазвернутыйСчетчик = 0)
	
	ЗначениеПараметра = СтрокаБезФорматирования(СтрокаРодителя.Значение);
	Если Подгруппы = Неопределено Тогда
		Подгруппы = ЭтаФорма.Подгруппы;
		Подгруппы.Очистить();
		СтрокаГруппы = Подгруппы.Добавить();
		СтрокаГруппы.Индекс = -1;
		СтрокаГруппы.Имя = "<Группа>";
		СтрокаГруппы.НачальнаяПозиция = 1;
		СтрокаГруппы.НачальнаяПозицияРазвернутая = 1;
		Счетчик = 1;
		РазвернутыйСчетчик = 1;
	КонецЕсли; 
	СчетчикПодгрупп = 1;
	ПропускаемСимвол = Ложь;
	Пока Счетчик <= СтрДлина(ЗначениеПараметра) Цикл
		ТекущийСимвол = Сред(ЗначениеПараметра, Счетчик, 1);
		Счетчик = Счетчик + 1;
		РазвернутыйСчетчик = РазвернутыйСчетчик + 1;
		Если ПропускаемСимвол Тогда 
			ПропускаемСимвол = Ложь;
			Продолжить;
		КонецЕсли; 
		Если ТекущийСимвол = "\" Тогда
			ПропускаемСимвол = Истина;
			Продолжить;
		КонецЕсли; 
		ПропускаемСимвол = Ложь;
		Если ТекущийСимвол = "(" Тогда
			НачальнаяПозиция = Счетчик - 1;
			НачальнаяПозицияРазвернутая = РазвернутыйСчетчик - 1;
			ЭтоФиксируемаяПодгруппа = Сред(ЗначениеПараметра, Счетчик, 1) <> "?";
			ОбновитьСтрокуПараметра(СтрокаРодителя, Счетчик, Подгруппы, РазвернутыйСчетчик);
			Если ЭтоФиксируемаяПодгруппа Тогда
				СтрокаПодгруппы = Подгруппы.Добавить();
				СтрокаПодгруппы.Индекс = Подгруппы.Количество() - 2;
				СтрокаПодгруппы.Имя = СтрокаРодителя.Имя;
				СтрокаПодгруппы.НомерВнутриРодителя = СчетчикПодгрупп;
				СтрокаПодгруппы.НачальнаяПозиция = НачальнаяПозиция;
				СтрокаПодгруппы.КонечнаяПозиция = Счетчик - 1;
				СтрокаПодгруппы.НачальнаяПозицияРазвернутая = НачальнаяПозицияРазвернутая;
				СтрокаПодгруппы.КонечнаяПозицияРазвернутая = РазвернутыйСчетчик - 1;
				СтрокаПодгруппы.Параметр = СтрокаРодителя.Имя;
				СчетчикПодгрупп = СчетчикПодгрупп + 1;
			КонецЕсли; 
		ИначеЕсли ТекущийСимвол = ")" Тогда
			Возврат Подгруппы;
		ИначеЕсли ТекущийСимвол = мЛеваяСкобкаПараметра Тогда
			ИмяДочернегоПараметра = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(Сред(ЗначениеПараметра, Счетчик), , мПраваяСкобкаПараметра, Ложь);
			Если Не ЗначениеЗаполнено(ИмяДочернегоПараметра) Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаПараметра = СтрокаПараметраПоИмени(ИмяДочернегоПараметра);
			Если СтрокаПараметра <> Неопределено Тогда
				Счетчик = Счетчик + СтрДлина(ИмяДочернегоПараметра) + 1; // 1 = СтрДлина(мПраваяСкобкаПараметра)
				РазвернутыйСчетчик = РазвернутыйСчетчик - 1;
				ОбновитьСтрокуПараметра(СтрокаПараметра, 1, Подгруппы, РазвернутыйСчетчик);
				Если Параметры.Индекс(СтрокаПараметра) < Параметры.Индекс(СтрокаРодителя) Тогда
					Параметры.Сдвинуть(СтрокаРодителя, Параметры.Индекс(СтрокаПараметра) - Параметры.Индекс(СтрокаРодителя));
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Если СтрокаГруппы <> Неопределено Тогда
		СтрокаГруппы.КонечнаяПозиция = РазвернутыйСчетчик - 1;
	КонецЕсли; 
	Возврат Подгруппы;

КонецФункции

Процедура ОбновитьПроверочныйТекст(РазрешитьАвтовыделение = Истина)
	
	АвтосохранениеДляВосстановления();
	ИндексПодгруппы = ЭлементыФормы.Подгруппы.ТекущаяСтрока.Индекс;
	Подгруппы.ЗаполнитьЗначения(0, "Найдено");
	Текст = ПроверочныйТекст();
	мНайденныеГруппы.Очистить();
	Если ЗначениеЗаполнено(РазвернутоеВыражение) Тогда
		Вхождения = ирОбщий.НайтиРегулярноеВыражениеЛкс(Текст, РазвернутоеВыражение,,, ИгнорироватьРегистр, Многострочный, Ложь);
		#Если Сервер И Не Сервер Тогда
			Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
		#КонецЕсли
		Если ТипЗнч(Вхождения) = Тип("Строка") Тогда
			Возврат;
		КонецЕсли; 
		НомерВхождения = 0;
		Для каждого Вхождение Из Вхождения Цикл
			НомерВхождения = НомерВхождения + 1;
			Начало = Вхождение.ПозицияВхождения;
			Длина = Вхождение.ДлинаВхождения;
			Конец = Начало + Длина;
			ЗначениеГруппы = Вхождение.ТекстВхождения;
			НайденнаяГруппа = мНайденныеГруппы.Добавить();
			НайденнаяГруппа.Номер = НомерВхождения;
			НайденнаяГруппа.Позиция = Начало;
			НайденнаяГруппа.Длина = Длина;
			НайденнаяГруппа.Значение = ЗначениеГруппы;
			НайденнаяГруппа.ПозицияПодгруппы = Начало;
			НайденнаяГруппа.ДлинаПодгруппы = Длина;
			Для ИндексПодгруппы = 0 По Вхождение.Подгруппы.Количество() - 1 Цикл
				ЗначениеПодгруппы = Вхождение.Подгруппы[ИндексПодгруппы];
				ПредставлениеПодстроки = ПрижатьВлево(ЗначениеПодгруппы);
				НайденнаяГруппа.Подстрока.Добавить(Вхождение.Подгруппы[ИндексПодгруппы], ПредставлениеПодстроки);
				Если ПредставлениеПодстроки <> Неопределено Тогда
					СтрокаПодгруппы = Подгруппы.Найти(ИндексПодгруппы, "Индекс");
					СтрокаПодгруппы.Найдено = СтрокаПодгруппы.Найдено + 1;
				КонецЕсли; 
				Если ИндексПодгруппы = ЭлементыФормы.Подгруппы.ТекущаяСтрока.Индекс Тогда
					НайденнаяГруппа.ПозицияПодгруппы = Начало + Найти(ЗначениеГруппы, ЗначениеПодгруппы) - 1;
					НайденнаяГруппа.ДлинаПодгруппы = СтрДлина(ЗначениеПодгруппы);
				КонецЕсли; 
			КонецЦикла;
		КонецЦикла;
		СтрокаПодгруппы = Подгруппы.Найти(-1, "Индекс");
		СтрокаПодгруппы.Найдено = Вхождения.Количество();
	КонецЕсли; 
	РаскрашенныйТекст = ЗаполнитьРаскраску(Текст);
	ДокументHtml = ЭлементыФормы.ПроверочныйТекст.Документ;
	ВыделениеВТексте = ПолучитьВыделениеВПроверочномТексте();
	ДокументHtml.body.innerHTML = РаскрашенныйТекст;
	Если Автовыделение И РазрешитьАвтовыделение Тогда
		Если ирКэш.НомерВерсииПлатформыЛкс() >= 803014 Тогда
			ТекущееВыделение = ДокументHtml.getSelection();
			ТекущееВыделение.removeAllRanges();
		Иначе
			ТекстовыйДиапазон = ДокументHtml.body.createTextRange();
			ТекстовыйДиапазон.collapse();
			ТекстовыйДиапазон.select();
		КонецЕсли; 
		СледующееВхождениеНажатие(, Ложь);
	Иначе
		УстановитьВыделениеВПроверочномТексте(ВыделениеВТексте);
	КонецЕсли; 
	НовыйПроверочныйТекст = ПроверочныйТекст();
	Если Не ЭтаФорма.Модифицированность И мСтарыйПроверочныйТекст <> НовыйПроверочныйТекст Тогда
		ЭтаФорма.Модифицированность = Истина;
	КонецЕсли; 
	мСтарыйПроверочныйТекст = НовыйПроверочныйТекст;

КонецПроцедуры

Функция ПрижатьВлево(Знач Строка) 
	
	RegExpLocal.Multiline = Ложь;
	RegExpLocal.Global = Истина;
	RegExpLocal.IgnoreCase = Истина;
	RegExpLocal.Pattern = "(^[ \s]*(?=[^ \s]))";
	//Возврат RegExpLocal.Replace (Стр, "...");
	Результат = Строка;
	Найдено = RegExpLocal.Execute(Строка);
	Для каждого Вхождение Из Найдено Цикл
		Длина = Вхождение.Length;
		Если Длина <> 0  Тогда
			Результат = "•" + Сред(Результат, Длина+1);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция ЗаполнитьРаскраску(Текст)
	
	ИндексПодгруппы = ЭлементыФормы.Подгруппы.ТекущаяСтрока.Индекс;
	РаскрашенныйТекст = "<pre style=""FONT-SIZE: 10pt; FONT-FAMILY: Courier New; color: #000000;";
	Если ПереносСлов Тогда
		РаскрашенныйТекст = РаскрашенныйТекст + " word-wrap: break-word;";
	КонецЕсли; 
	РаскрашенныйТекст = РаскрашенныйТекст + """>";
	МаркерКонецПодгруппы = "</SPAN>";
	Результат = Новый ЗаписьXML;
	Результат.УстановитьСтроку("");
	Старт = Истина;
	Финиш = 0;
	ЗначениеЧередования = Ложь;
	МаксРаскашиваемыхВхождений = 1000;
	РаскрашеноВхождений = 0;
	Для каждого Группа Из мНайденныеГруппы Цикл
		Если Группа.ПозицияПодгруппы = Неопределено Или РаскрашеноВхождений > МаксРаскашиваемыхВхождений Тогда
			Продолжить;
		КонецЕсли; 
		ТекстПодгруппы = ТекстПодгруппы(Группа);
		Если ТекстПодгруппы = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		ПозицияПодгруппы = Группа.ПозицияПодгруппы;
		ДлинаПодгруппы = Группа.ДлинаПодгруппы;
		Если Старт Тогда
			Если Группа.ПозицияПодгруппы <> 0 Тогда
				Результат.ЗаписатьБезОбработки(ирОбщий.КодироватьТекстВXMLЛкс(Сред(Текст, 1, ПозицияПодгруппы)));
			КонецЕсли;
			Старт = Ложь;
		ИначеЕсли Финиш <> 0 Тогда
			Результат.ЗаписатьБезОбработки(ирОбщий.КодироватьТекстВXMLЛкс(Сред(Текст, Финиш, ПозицияПодгруппы - Финиш + 1)));
		КонецЕсли;
		ЗначениеПодгруппы = ирОбщий.КодироватьТекстВXMLЛкс(ТекстПодгруппы);
		Результат.ЗаписатьБезОбработки(НачальнаяМеткаSPAN(Группа.Номер, ИндексПодгруппы, ЗначениеЧередования) + ЗначениеПодгруппы + "</SPAN>");
		РаскрашеноВхождений = РаскрашеноВхождений + 1;
		Финиш = ПозицияПодгруппы + ДлинаПодгруппы + 1;
		ЗначениеЧередования = Не ЗначениеЧередования;
	КонецЦикла;
	Результат.ЗаписатьБезОбработки(ирОбщий.КодироватьТекстВXMLЛкс(Сред(Текст, Финиш)));
	Результат = Результат.Закрыть();
	
	//ТекстовыйДокумент = Новый ТекстовыйДокумент;
	//ТекстовыйДокумент.УстановитьТекст(Результат);
	//НовыйРезультат = "";
	//Для Сч = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
	//	Рстр = ТекстовыйДокумент.ПолучитьСтроку(Сч);
	//	RegExpLocal.Multiline = Ложь;
	//	RegExpLocal.Global = Истина;
	//	RegExpLocal.IgnoreCase = Истина;
	//	RegExpLocal.Pattern = "^(\t*).*$";
	//	Результат = RegExpLocal.Execute (Рстр);
	//	Для каждого Стр Из Результат Цикл
	//		Таб = Стр.SubMatches(0);
	//		КвоТаб = СтрДлина(Таб);
	//		Если КвоТаб <> 0  Тогда
	//			Префикс = "<p style=""MARGIN-LEFT: " + 20 * КвоТаб + "pt;"">";
	//			Рстр = Префикс + Сред(Рстр, КвоТаб+1);
	//		Иначе
	//			Рстр = "<p>" + Сред(Рстр, КвоТаб+1);
	//		КонецЕсли;
	//	КонецЦикла;
	//	НовыйРезультат = НовыйРезультат + Рстр + Символы.ПС;
	//КонецЦикла;
	//Результат = НовыйРезультат;
	
	РаскрашенныйТекст = РаскрашенныйТекст + Результат;
	РаскрашенныйТекст = "<HTML><HEAD><BODY>" + РаскрашенныйТекст + "</BODY></HEAD></HTML>";
	Возврат РаскрашенныйТекст;
	
КонецФункции

Функция ТекстПодгруппы(Знач Группа)
	
	ИндексПодгруппы = ЭлементыФормы.Подгруппы.ТекущаяСтрока.Индекс;
	Если ИндексПодгруппы = -1 Тогда
		ЗначениеПодгруппы = Группа.Значение;
	Иначе
		ЗначениеПодгруппы = Группа.Подстрока[ИндексПодгруппы].Значение;
	КонецЕсли;
	Возврат ЗначениеПодгруппы;

КонецФункции

Функция ИДПодгруппыВПроверочномТексте(Знач НомерГруппы, Знач ИндексПодгруппы = Неопределено)
	
	Если ИндексПодгруппы = Неопределено Тогда
		ИндексПодгруппы = ЭлементыФормы.Подгруппы.ТекущаяСтрока.Индекс;
	КонецЕсли; 
	Возврат "Match" + НомерГруппы + "_SubMatch" + ИндексПодгруппы;

КонецФункции

Функция ПроверочныйТекст()
	
	Если ирКэш.НомерВерсииПлатформыЛкс() < 803014 Тогда
		Текст = ЭлементыФормы.ПроверочныйТекст.ПолучитьТекст();
		ДокументHtml = ирОбщий.ПолучитьHtmlFileИзТекстаHtmlЛкс(Текст); // Тут переносы строк другое количество символов дают
	Иначе
		ДокументHtml = ЭлементыФормы.ПроверочныйТекст.Документ;
	КонецЕсли; 
	Текст = ДокументHtml.documentElement.innerText;
	Возврат Текст;

КонецФункции

&НаКлиенте
Функция НачальнаяМеткаSPAN(Знач НомерГруппы, ИндексПодгруппы, ЗначениеЧередования = Истина)
	
	//МассивЦветов = Новый Массив;
	//МассивЦветов.Добавить("yellow");
	//МассивЦветов.Добавить("cyan");
	//МассивЦветов.Добавить("#CCFF66"); // светло-зеленый
	//МассивЦветов.Добавить("orange");
	Если ЗначениеЧередования Тогда
		ИмяЦвета = "cyan";
	Иначе
		ИмяЦвета = "yellow";
	КонецЕсли; 
	Возврат "<SPAN id=""" + ИДПодгруппыВПроверочномТексте(НомерГруппы, ИндексПодгруппы) + """ style=""background-color: " + ИмяЦвета + """>";

КонецФункции

Функция РазвернутоеВыражение(ТекущаяСтрока = Неопределено)
	
	Если ТекущаяСтрока = Неопределено Тогда
		ТекущаяСтрока = ЭлементыФормы.Параметры.ТекущаяСтрока;
	КонецЕсли; 
	Результат = Неопределено;
	ДоступныеПараметры.Очистить();
	// ть34що9ш40
	СтрокиПараметров = Параметры.НайтиСтроки(Новый Структура("ЭтоВариант", Ложь));
	Для ИндексРодителя = СтрокиПараметров.Найти(ТекущаяСтрока) По СтрокиПараметров.Количество() - 1 Цикл
		СтрокаРодителя = СтрокиПараметров[ИндексРодителя];
		Если Результат = Неопределено Тогда
			Результат = ТекущаяСтрока.Значение;
			Для ИндексПараметра = ИндексРодителя + 1 По СтрокиПараметров.Количество() - 1 Цикл
				СтрокаПараметра = СтрокиПараметров[ИндексПараметра];
				СтрокаПоиска = мЛеваяСкобкаПараметра + СтрокаПараметра.Имя + мПраваяСкобкаПараметра;
				ДоступныйПараметр = ДоступныеПараметры.Добавить();
				ЗаполнитьЗначенияСвойств(ДоступныйПараметр, СтрокаПараметра, "Имя, Корректно"); 
				ДоступныйПараметр.Использован = Найти(Результат, СтрокаПоиска) > 0;
			КонецЦикла;
		КонецЕсли;
		Для ИндексПараметра = ИндексРодителя + 1 По СтрокиПараметров.Количество() - 1 Цикл
			СтрокаПараметра = СтрокиПараметров[ИндексПараметра];
			СтрокаПоиска = мЛеваяСкобкаПараметра + СтрокаПараметра.Имя + мПраваяСкобкаПараметра;
			Результат = СтрЗаменить(Результат, СтрокаПоиска, СтрокаПараметра.Значение);
		КонецЦикла;
	КонецЦикла;
	ДоступныеПараметры.Сортировать("Имя");
	Результат = СтрокаБезФорматирования(Результат);
	Возврат Результат;
	
КонецФункции

Процедура ПолеТекстаВыраженияАвтоПодборТекста(Элемент, Текст, ТекстАвтоПодбора, СтандартнаяОбработка)
	
	ОбновитьВыражениеПараметра();

КонецПроцедуры

Процедура ПолеТекстаВыраженияПриИзменении(Элемент)
	
	ОбновитьВыражениеПараметра();

КонецПроцедуры

Процедура КПВыражениеСправкаПоСинтаксису(Кнопка)
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("chm");
	ПолучитьМакет("СправкаRegexp").Записать(ИмяВременногоФайла);
	ЗапуститьПриложение(ИмяВременногоФайла);

КонецПроцедуры

Процедура ДействияФормыНовоеОкно(Кнопка)
	
	ирОбщий.ОткрытьНовоеОкноОбработкиЛкс(ЭтотОбъект);
	
КонецПроцедуры

Процедура ДействияФормыНовыйФайл(Кнопка)
	
	Если ПроверитьСохранитьПолноеВыражение() Тогда
		СоздатьФайл();
	КонецЕсли;

КонецПроцедуры

Процедура ДействияФормыСохранитьФайл(Кнопка)
	
	СохранитьВФайл();
	
КонецПроцедуры

Процедура ДействияФормыСохранитьКак(Кнопка)
	
	СохранитьВФайл(, Истина);
	
КонецПроцедуры

Процедура ДействияФормыОткрытьФайл(Кнопка)
	
	Если Не ПроверитьСохранитьПолноеВыражение() Тогда
		Возврат;
	КонецЕсли; 
	ИмяВыбранногоФайла = "";
	Если Не ЗначениеЗаполнено(ИмяВыбранногоФайла) Тогда
		ИмяВыбранногоФайла = ирОбщий.ВыбратьФайлЛкс(, мРасширениеФайла, мОписаниеРасширенияФайла);
		Если ИмяВыбранногоФайла = Неопределено Тогда
			Возврат;
		КонецЕсли; 
	КонецЕсли;
	ЗагрузитьИзФайла(ИмяВыбранногоФайла);
	
КонецПроцедуры

Процедура ЗагрузитьИзФайлаОтложенно()
	ЗагрузитьИзФайла();
КонецПроцедуры

Процедура ЗагрузитьИзФайла(ИмяВыбранногоФайла = "")
	
	Если Не ЗначениеЗаполнено(ИмяВыбранногоФайла) Тогда
		ИмяВыбранногоФайла = мИмяОткрытогоФайла;
	КонецЕсли; 
	//ЗагружаемыеДанные = ирОбщий.ЗагрузитьЗначениеИзФайлаЛкс(ИмяВыбранногоФайла);
	ЗагружаемыеДанные = ирОбщий.ПрочитатьЗначениеИзФайлаСКонтролемПотерьЛкс(ИмяВыбранногоФайла);
	Если ЗагружаемыеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	#Если Сервер И Не Сервер Тогда
		ЗагружаемыеДанные = Новый Структура;
	#КонецЕсли
	мИмяОткрытогоФайла = ИмяВыбранногоФайла;
	ОчиститьПараметры();
	Параметры.Загрузить(ЗагружаемыеДанные.Параметры);
	Если ЗагружаемыеДанные.Свойство("ПроверочныйТекст") Тогда
		ЭлементыФормы.ПроверочныйТекст.УстановитьТекст(ЗагружаемыеДанные.ПроверочныйТекст);
	Иначе
		ЭлементыФормы.ПроверочныйТекст.УстановитьТекст("");
	КонецЕсли; 
	Если ЗагружаемыеДанные.Свойство("ИгнорироватьРегистр") Тогда
		ЭтаФорма.ИгнорироватьРегистр = ЗагружаемыеДанные.ИгнорироватьРегистр;
	Иначе
		ЭтаФорма.ИгнорироватьРегистр = Истина;
	КонецЕсли; 
	Если ЗагружаемыеДанные.Свойство("Многострочный") Тогда
		ЭтаФорма.Многострочный = ЗагружаемыеДанные.Многострочный;
	Иначе
		ЭтаФорма.Многострочный = Истина;
	КонецЕсли; 
	мСтарыйПроверочныйТекст = ПроверочныйТекст();
	Если Параметры.Количество() > 0 Тогда
		ЭлементыФормы.Параметры.ТекущаяСтрока = Параметры[0];
	КонецЕсли; 

КонецПроцедуры

Процедура АвтосохранениеДляВосстановления()
	
	//ОбновитьВыражениеПараметра(); // Рекурсия
	СохранитьВФайл(,, мСтруктураВосстановления.ФайлВосстановления.ПолноеИмя, Ложь);
	
КонецПроцедуры

Процедура ДействияФормыОПодсистеме(Кнопка)
	
	ирОбщий.ОткрытьСправкуПоПодсистемеЛкс(ЭтотОбъект);

КонецПроцедуры

Процедура ОбновлениеОтображения()
	
	ирОбщий.ОбновитьЗаголовокФормыСОткрытымФайломЛкс(ЭтаФорма, мИмяОткрытогоФайла);
	ирОбщий.ОбновитьЗаголовкиСтраницПанелейЛкс(ЭтаФорма);
	
	//// Этот способ почему то выдавал количество без учета отбора
	//ПостроительТабличногоПоля = ирОбщий.ПолучитьПостроительТабличногоПоляСОтборомКлиентаЛкс(ЭлементыФормы.Варианты);
	//#Если Сервер И Не Сервер Тогда
	//    ПостроительТабличногоПоля = Новый ПостроительЗапроса;
	//#КонецЕсли
	//КоличествоВариантов = ПостроительТабличногоПоля.Результат.Выбрать().Количество();
	//
	КоличествоВариантов = 0;
	Если мТекущаяСтрокаПараметра <> Неопределено Тогда
		КоличествоВариантов = Параметры.НайтиСтроки(Новый Структура("НИмя", мТекущаяСтрокаПараметра.НИмя)).Количество();
	КонецЕсли; 
	
	ирОбщий.ОбновитьТекстПослеМаркераВСтрокеЛкс(ЭлементыФормы.ПанельВыражение.Страницы.Варианты.Заголовок, , "" + КоличествоВариантов + ")", "(");
	
КонецПроцедуры

Процедура ДействияФормыНастройки(Кнопка = Неопределено)
	
	ФормаНастроек = ПолучитьФорму("Настройки");
	ФормаНастроек.Открыть();
	
КонецПроцедуры

Процедура ДоступныеЭлементыНачалоПеретаскивания(Элемент, ПараметрыПеретаскивания, Выполнение)
	
	ТекстВставки = ТекстВставкиДоступногоЭлемента();
	//ТекстВставки = СтрЗаменить(ТекстВставки, "шаблон", "");
	ПараметрыПеретаскивания.Значение = ТекстВставки;
	
КонецПроцедуры

Функция ТекстВставкиДоступногоЭлемента()
	
	ТекстВставки = ЭлементыФормы.ДоступныеЭлементы.ТекущаяСтрока.ТекстВставки;
	Если Не ЗначениеЗаполнено(ТекстВставки) Тогда
		ТекстВставки = ЭлементыФормы.ДоступныеЭлементы.ТекущаяСтрока.Текст;
	КонецЕсли;
	Возврат ТекстВставки;

КонецФункции

Процедура ДоступныеЭлементыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ВыделенныйТекст = ЭлементыФормы.ПолеТекстаВыражения.ВыделенныйТекст;
	ТекстВставки = ТекстВставкиДоступногоЭлемента();
	ТекстВставки = СтрЗаменить(ТекстВставки, "шаблон", ВыделенныйТекст);
	ЗаменитьИВыделитьВыделенныйТекстВыражения(ТекстВставки);
	
КонецПроцедуры

Процедура КПВыражениеУстановитьФокус(Кнопка)
	
	ЭтаФорма.ТекущийЭлемент = ЭлементыФормы.ПолеТекстаВыражения;
	
КонецПроцедуры

Процедура КПВыражение1ПроверитьСинтаксис(Кнопка)
	
	ПроверитьСинтаксис(, Истина);
	
КонецПроцедуры

Функция ПроверитьСинтаксис(ТекущаяСтрока = Неопределено, СообщатьРезультат = Ложь)
	
	Если ТекущаяСтрока = Неопределено Тогда
		ТекущаяСтрока = ЭлементыФормы.Параметры.ТекущаяСтрока;
	КонецЕсли; 
	Успех = Истина;
	ОписаниеОшибки = "";
	RegExpLocal.Pattern = РазвернутоеВыражение(ТекущаяСтрока);
	Попытка
		RegExpLocal.Execute("");
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке.Причина);
		Успех = Ложь;
	КонецПопытки;
	ТекущаяСтрока.Корректно = Успех;
	Если ТекущаяСтрока = ЭлементыФормы.Параметры.ТекущаяСтрока Тогда
		Если Успех Тогда
			ЭлементыФормы.ПолеТекстаВыражения.ЦветТекстаПоля = Новый Цвет;
		Иначе
			ЭлементыФормы.ПолеТекстаВыражения.ЦветТекстаПоля = WebЦвета.Красный;
		КонецЕсли; 
		Если СообщатьРезультат Тогда
			Если Не Успех Тогда
				Сообщить(ОписаниеОшибки, СтатусСообщения.Внимание);
			Иначе
				Сообщить("Выражение корректно");
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Успех;

КонецФункции 

Процедура НадписьПроверочныйТекстНажатие(Элемент)
	
	ОбновитьПроверочныйТекст();
	
КонецПроцедуры

Процедура АвтообновлениеПроверочногоТекстаПриИзменении(Элемент = Неопределено)
	
	Если АвтообновлениеПроверочногоТекста Тогда
		ОбновитьПроверочныйТекст();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПодгруппыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ОбновитьПроверочныйТекст();
	Если Колонка = ЭлементыФормы.Подгруппы.Колонки.Параметр И ВыбраннаяСтрока.Индекс >= 0 Тогда
		КлючПоиска = Новый Структура("Параметр, НомерВнутриРодителя", ВыбраннаяСтрока.Параметр, ВыбраннаяСтрока.НомерВнутриРодителя);
		ПерейтиКПараметру(ВыбраннаяСтрока.Параметр);
		ВыбраннаяСтрока = Подгруппы.НайтиСтроки(КлючПоиска)[0];
		ЭлементыФормы.Подгруппы.ТекущаяСтрока = ВыбраннаяСтрока;
		ЭлементыФормы.ПолеТекстаВыражения.УстановитьГраницыВыделения(ВыбраннаяСтрока.НачальнаяПозиция, ВыбраннаяСтрока.КонечнаяПозиция + 1);
		ЭтаФорма.ТекущийЭлемент = ЭлементыФормы.ПолеТекстаВыражения;
	КонецЕсли; 
	Если ВыбраннаяСтрока.Индекс >= 0 Тогда
		Попытка
			ЭлементыФормы.РазвернутоеВыражение.УстановитьГраницыВыделения(ВыбраннаяСтрока.НачальнаяПозицияРазвернутая, ВыбраннаяСтрока.КонечнаяПозицияРазвернутая + 1);
		Исключение
			// Временно до исправления ошибок вычисления позиций подгрупп
		КонецПопытки; 
		Если Колонка <> ЭлементыФормы.Подгруппы.Колонки.Параметр Тогда
			ЭтаФорма.ТекущийЭлемент = ЭлементыФормы.РазвернутоеВыражение;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	мСтароеИмяПараметра = ЭлементыФормы.Параметры.ТекущаяСтрока.Имя;
	Если НоваяСтрока Тогда
		ЭлементыФормы.Параметры.ТекущаяСтрока.Имя = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииЛкс(Параметры, "Параметр");
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыПередУдалением(Элемент, Отказ)
	
	Отказ = Истина;
	Если ИспользуетсяВ.Количество() > 0 Тогда
		Сообщить("Параметр используется в других параметрах");
	Иначе
		СтрокиКУдалению = Параметры.НайтиСтроки(Новый Структура("Имя", мТекущаяСтрокаПараметра.Имя));
		мТекущаяСтрокаПараметра = Неопределено;
		Для Каждого СтрокаПараметра Из СтрокиКУдалению Цикл
			Параметры.Удалить(СтрокаПараметра);
		КонецЦикла;
		Если Параметры.Количество() = 0 Тогда
			ДобавитьПервуюСтроку();
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеПараметрыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ПерейтиКПараметру(ВыбраннаяСтрока.Имя);
	
КонецПроцедуры

Процедура ПараметрыПрочееПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ОформитьСтрокуПараметраОбщее(ОформлениеСтроки);
	
КонецПроцедуры

Процедура ИспользуетсяВВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ПерейтиКПараметру(ВыбраннаяСтрока.Имя);

КонецПроцедуры

Процедура ПараметрыПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		НовоеИмяПараметра = ирОбщий.ПолучитьАвтоУникальноеИмяВКоллекцииЛкс(Параметры, ЭлементыФормы.Параметры.ТекущаяСтрока);
		Если НовоеИмяПараметра <> мСтароеИмяПараметра Тогда
			Для Каждого ВариантПараметра Из Параметры.НайтиСтроки(Новый Структура("НИмя", НРег(мСтароеИмяПараметра))) Цикл
				ВариантПараметра.Имя = НовоеИмяПараметра;
				ОбновитьИмяВНижнемРегистре(ВариантПараметра);
			КонецЦикла;
			ОбновитьИмяВНижнемРегистре();
			ОбращениеКПараметруНовое = мЛеваяСкобкаПараметра + НовоеИмяПараметра + мПраваяСкобкаПараметра;
			ОбращениеКПараметруСтарое = мЛеваяСкобкаПараметра + мСтароеИмяПараметра + мПраваяСкобкаПараметра;
			Для Каждого СтрокаПараметра Из Параметры Цикл
				Пока Истина Цикл
					ПозицияОбращения = Найти(НРег(СтрокаПараметра.Значение), НРег(ОбращениеКПараметруСтарое));
					Если ПозицияОбращения = 0 Тогда
						Прервать;
					КонецЕсли;
					СтрокаПараметра.Значение = Лев(СтрокаПараметра.Значение, ПозицияОбращения - 1) + ОбращениеКПараметруНовое + Сред(СтрокаПараметра.Значение, ПозицияОбращения + СтрДлина(ОбращениеКПараметруСтарое));
				КонецЦикла; 
			КонецЦикла;
			ПараметрыПриАктивизацииСтроки();
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура КПВыражениеПерейтиКОпределению(Кнопка)
	
	НачальнаяПозиция = 0;
	КонечнаяПозиция = 0;
	ТекстВыражения = ЭлементыФормы.ПолеТекстаВыражения.Значение;
	ЭлементыФормы.ПолеТекстаВыражения.ПолучитьГраницыВыделения(НачальнаяПозиция, КонечнаяПозиция, НачальнаяПозиция, КонечнаяПозиция);
	НачалоСтроки = Лев(ТекстВыражения, КонечнаяПозиция - 1);
	КонецСтроки = Сред(ТекстВыражения, КонечнаяПозиция);
	Результат = ирОбщий.НайтиРегулярноеВыражениеЛкс(НачалоСтроки, мЛеваяСкобкаПараметра + "(" + шИмя + ")?$",, Ложь);
	#Если Сервер И Не Сервер Тогда
	    Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
	#КонецЕсли
	Если Результат.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	НачалоИмени = Результат[0].Подгруппы[0];
	Результат = ирОбщий.НайтиРегулярноеВыражениеЛкс(КонецСтроки, "^(" + шИмя + ")?" + мПраваяСкобкаПараметра,, Ложь);
	#Если Сервер И Не Сервер Тогда
	    Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
	#КонецЕсли
	Если Результат.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	КонецИмени = Результат[0].Подгруппы[0];
	ТекущееИмя = НачалоИмени + КонецИмени;
	Если ЗначениеЗаполнено(ТекущееИмя) Тогда
		ПерейтиКПараметру(ТекущееИмя);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПерейтиКПараметру(Знач ТекущееИмя)
	
	ЭлементыФормы.Параметры.ТекущаяСтрока = СтрокаПараметраПоИмени(ТекущееИмя);

КонецПроцедуры

Функция СтрокаПараметраПоИмени(Знач ТекущееИмя)
	
	Результат = Неопределено;
	НайденныеСтроки = Параметры.НайтиСтроки(Новый Структура("НИмя, ЭтоВариант", НРег(ТекущееИмя), Ложь));
	Если НайденныеСтроки.Количество() > 0 Тогда
		Результат = НайденныеСтроки[0];
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ПредыдущееВхождениеНажатие(Элемент = Неопределено, ОбновитьПроверочныйТекст = Ложь)
	
	Если ОбновитьПроверочныйТекст <> Ложь Тогда
		ОбновитьПроверочныйТекст(Ложь);
	КонецЕсли; 
	ВыделениеВТексте = ПолучитьВыделениеВПроверочномТексте();
	ВыбраннаяГруппа = Неопределено;
	ИнвертироватьПоиск = Ложь;
	Для Каждого Группа Из мНайденныеГруппы Цикл
		Если Группа.ПозицияПодгруппы = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		Если Группа.ПозицияПодгруппы < ВыделениеВТексте.Начало Тогда
			ВыбраннаяГруппа = Группа;
		Иначе
			ИнвертироватьПоиск = Группа.ПозицияПодгруппы > ВыделениеВТексте.Начало + 2; // 2 - Крайний перенос строки 
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Если ВыбраннаяГруппа <> Неопределено Тогда
		ВыделитьГруппуВПроверочномТексте(ВыбраннаяГруппа);
	ИначеЕсли ИнвертироватьПоиск Тогда 
		СледующееВхождениеНажатие();
	КонецЕсли; 
	
КонецПроцедуры

Процедура СледующееВхождениеНажатие(Элемент = Неопределено, ОбновитьПроверочныйТекст = Ложь)
	
	Если ОбновитьПроверочныйТекст <> Ложь Тогда
		ОбновитьПроверочныйТекст(Ложь);
	КонецЕсли; 
	ВыделениеВТексте = ПолучитьВыделениеВПроверочномТексте();
	ВыбраннаяГруппа = Неопределено;
	ИнвертироватьПоиск = Ложь;
	Для Каждого Группа Из мНайденныеГруппы Цикл
		Если Группа.ПозицияПодгруппы = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		ИнвертироватьПоиск = Группа.ПозицияПодгруппы < ВыделениеВТексте.Начало;
		Если Истина
			И Группа.ПозицияПодгруппы >= ВыделениеВТексте.Начало
			И Группа.ПозицияПодгруппы + Группа.ДлинаПодгруппы > ВыделениеВТексте.Конец + 2 // 2 - Крайний перенос строки 
		Тогда
			ВыбраннаяГруппа = Группа;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Если ВыбраннаяГруппа <> Неопределено Тогда
		ВыделитьГруппуВПроверочномТексте(ВыбраннаяГруппа);
	ИначеЕсли ИнвертироватьПоиск Тогда 
		ПредыдущееВхождениеНажатие(, ОбновитьПроверочныйТекст);
	КонецЕсли; 
	
КонецПроцедуры

Функция ПолучитьВыделениеВПроверочномТексте()
	
	ВыделениеВТексте = Новый Структура;
	ДокументHtml = ЭлементыФормы.ПроверочныйТекст.Документ;
	ТелоДокумента = ДокументHtml.body;
	Если ирКэш.НомерВерсииПлатформыЛкс() < 803014 Тогда
		ТекущееВыделение = ДокументHtml.Selection.createRange();
		Диапазон = ТелоДокумента.createTextRange();
		Диапазон.setEndPoint("EndToStart", ТекущееВыделение);
		ВыделениеВТексте.Вставить("Начало", СтрДлина(Диапазон.Text));
		ВыделениеВТексте.Вставить("НачалоБезПереносов", СтрДлина(СтрЗаменить(Диапазон.Text, Символы.ПС, "")));
		Диапазон.setEndPoint("EndToEnd", ТекущееВыделение);
		ВыделениеВТексте.Вставить("Конец", СтрДлина(Диапазон.Text));
		ВыделениеВТексте.Вставить("КонецБезПереносов", СтрДлина(СтрЗаменить(Диапазон.Text, Символы.ПС, "")));
	Иначе
		//ТекущееВыделение = ДокументHtml.window.getSelection();
		ТекущееВыделение = ДокументHtml.getSelection();
		Начало = 0;
		НачалоБезПереносов = 0;
		Конец = 0;
		КонецБезПереносов = 0;
		Если ТекущееВыделение <> Неопределено Тогда
			//ВыделенныйТекст = Диапазон.toString(); // Для отладки
			ТекстовыеУзлы = ТекстовыеУзлыВнутри(ТелоДокумента);
			НачалоНайдено = Ложь;
			ОбратныйПорядок = Ложь;
			СчетчикСимволов = 0;
			СчетчикСимволовБезПереносов = 0;
			Для Каждого ТекстовыйУзел из ТекстовыеУзлы Цикл 
				Если Не НачалоНайдено Тогда 
					Если ТекстовыйУзел = ТекущееВыделение.anchorNode Тогда 
						НачалоБезПереносов = СчетчикСимволовБезПереносов + ТекущееВыделение.anchorOffset;
						Начало = СчетчикСимволов + ТекущееВыделение.anchorOffset;
						НачалоНайдено = Истина;
					ИначеЕсли ТекстовыйУзел = ТекущееВыделение.focusNode Тогда 
						НачалоБезПереносов = СчетчикСимволовБезПереносов + ТекущееВыделение.focusOffset;
						Начало = СчетчикСимволов + ТекущееВыделение.focusOffset;
						НачалоНайдено = Истина;
						ОбратныйПорядок = Истина;
					КонецЕсли; 
				КонецЕсли; 
				Если НачалоНайдено Тогда 
					Если ОбратныйПорядок И ТекстовыйУзел = ТекущееВыделение.anchorNode Тогда 
						КонецБезПереносов = СчетчикСимволовБезПереносов + ТекущееВыделение.anchorOffset;
						Конец = СчетчикСимволов + ТекущееВыделение.anchorOffset;
						Прервать;
					ИначеЕсли Не ОбратныйПорядок И ТекстовыйУзел = ТекущееВыделение.focusNode Тогда 
						КонецБезПереносов = СчетчикСимволовБезПереносов + ТекущееВыделение.focusOffset;
						Конец = СчетчикСимволов + ТекущееВыделение.focusOffset;
						Прервать;
					КонецЕсли; 
				КонецЕсли; 
				СчетчикСимволов = СчетчикСимволов + СтрДлина(ТекстовыйУзел.textContent);
				СчетчикСимволовБезПереносов = СчетчикСимволовБезПереносов + СтрДлина(СтрЗаменить(ТекстовыйУзел.data, Символы.ПС, ""));
			КонецЦикла; 
		КонецЕсли; 
		ВыделениеВТексте.Вставить("Начало", Начало);
		ВыделениеВТексте.Вставить("НачалоБезПереносов", НачалоБезПереносов);
		ВыделениеВТексте.Вставить("Конец", Конец);
		ВыделениеВТексте.Вставить("КонецБезПереносов", КонецБезПереносов);
	КонецЕсли; 
	Возврат ВыделениеВТексте;

КонецФункции

Процедура УстановитьВыделениеВПроверочномТексте(Знач ВыделениеВТексте, Знач РодительскийУзел = Неопределено)
	
	ДокументHtml = ЭлементыФормы.ПроверочныйТекст.Документ;
	ТелоДокумента = ДокументHtml.body;
	Если РодительскийУзел = Неопределено Тогда
		РодительскийУзел = ТелоДокумента;
	КонецЕсли; 
	Если ирКэш.НомерВерсииПлатформыЛкс() >= 803014 Тогда
		//ВыделенныйТекст = Диапазон.toString(); // Для отладки
		Диапазон = ДокументHtml.createRange();
		Диапазон.selectNodeContents(РодительскийУзел);
		ТекстовыеУзлы = ТекстовыеУзлыВнутри(РодительскийУзел);
		НачалоНайдено = Ложь;
		СчетчикСимволов = 0;
		СчетчикУзлов = 0;
		Для Каждого ТекстовыйУзел Из ТекстовыеУзлы Цикл 
			endCharCount = СчетчикСимволов + СтрДлина(ТекстовыйУзел.data);
			Если Истина
				И Не НачалоНайдено 
				И ВыделениеВТексте.Начало >= СчетчикСимволов
				И (Ложь
					Или ВыделениеВТексте.Начало < endCharCount 
					Или (ВыделениеВТексте.Начало = endCharCount И СчетчикУзлов <= ТекстовыеУзлы.Количество()))
			Тогда 
				Диапазон.setStart(ТекстовыйУзел, ВыделениеВТексте.Начало - СчетчикСимволов);
				НачалоНайдено = Истина;
			КонецЕсли; 
			Если НачалоНайдено И ВыделениеВТексте.Конец <= endCharCount Тогда 
				Диапазон.setEnd(ТекстовыйУзел, ВыделениеВТексте.Конец - СчетчикСимволов);
				Прервать;
			КонецЕсли; 
			СчетчикСимволов = endCharCount;
			СчетчикУзлов = СчетчикУзлов + 1;
		КонецЦикла; 
		ТекущееВыделение = ДокументHtml.getSelection();
		ТекущееВыделение.removeAllRanges();
		ТекущееВыделение.addRange(Диапазон);
	Иначе
		Диапазон = РодительскийУзел.createTextRange();
		Диапазон.Collapse();
		Диапазон.moveStart("character", ВыделениеВТексте.НачалоБезПереносов);
		Диапазон.moveEnd("character", ВыделениеВТексте.КонецБезПереносов - ВыделениеВТексте.НачалоБезПереносов);
		Диапазон.select();
	КонецЕсли;
	
КонецПроцедуры

Функция ТекстовыеУзлыВнутри(Узел, ТекстовыеУзлы = Неопределено)
	Если ТекстовыеУзлы = Неопределено Тогда
		ТекстовыеУзлы = Новый Массив;
	КонецЕсли; 
	Если Узел.nodeType = 3 Тогда 
		ТекстовыеУзлы.Добавить(Узел);
	Иначе
		Потомки = Узел.childNodes;
		Для Каждого Потомок Из Потомки Цикл
			ТекстовыеУзлыВнутри(Потомок, ТекстовыеУзлы);
		КонецЦикла;
	КонецЕсли; 
	Возврат ТекстовыеУзлы;
КонецФункции

Процедура ВыделитьГруппуВПроверочномТексте(Знач ВыбраннаяГруппа)
	
	ДокументHtml = ЭлементыФормы.ПроверочныйТекст.Документ;
	ТелоДокумента = ДокументHtml.body;
	ИДНужныйУзел = ИДПодгруппыВПроверочномТексте(ВыбраннаяГруппа.Номер);
	ТегГруппы = Неопределено;
	//ТегГруппы = ДокументHtml.getElementByID(ИДНужныйУзел); // начиная с 8.3.14 так не работает
	Для Каждого Узел Из ДокументHtml.all Цикл
		Если Узел.id = ИДНужныйУзел Тогда
			ТегГруппы = Узел;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	Если ТегГруппы <> Неопределено Тогда
		Если ирКэш.НомерВерсииПлатформыЛкс() >= 803014 Тогда
			ВыделениеВТексте = Новый Структура;
			ВыделениеВТексте.Вставить("Начало", 0);
			ВыделениеВТексте.Вставить("НачалоБезПереносов", 0);
			ВыделениеВТексте.Вставить("Конец", ВыбраннаяГруппа.Длина);
			ВыделениеВТексте.Вставить("КонецБезПереносов", 0);
			УстановитьВыделениеВПроверочномТексте(ВыделениеВТексте, ТегГруппы);
		Иначе
			Диапазон = ТелоДокумента.createTextRange();
			Диапазон.moveToElementText(ТегГруппы);
			Диапазон.scrollIntoView();
			Диапазон.Select();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура КПВыражениеЭкранироватьТекст(Кнопка)
	
	ВыделенныйТекст = ЭлементыФормы.ПолеТекстаВыражения.ВыделенныйТекст;
	ТекстВставки = ирОбщий.ПреобразоватьТекстДляРегулярныхВыраженийЛкс(ВыделенныйТекст);
	ЗаменитьИВыделитьВыделенныйТекстВыражения(ТекстВставки);
	
КонецПроцедуры

Процедура ПодгруппыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ОформлениеСтроки.Ячейки.Параметр.УстановитьТекст("*");
	
КонецПроцедуры

Процедура ПереносСловПриИзменении(Элемент)
	
	ОбновитьПроверочныйТекст();
	
КонецПроцедуры

Процедура ДействияФормыПараметрыИзБуфераОбмена(Кнопка)

	Текст = ирОбщий.ПолучитьТекстИзБуфераОбменаОСЛкс();
	
	// Сначала пробуем найти расширенное описание выражения
	// Пример
	// Описание регулярного выражения для конструктора из подсистемы "Инструменты разработчика"
	// {Шаблон.Начало}
	//	 + <Комментарий> = (<Строка комментария>(?:\n<ПР><Строка комментария>)*)
	//	 + <Строка комментария> = (?://<Текст>$)
	//	 - <Строка комментария> = (?://\s*<Текст>$)
	// {Шаблон.Конец}
	ТекстРасширенный = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(Текст, "{Шаблон.Начало}", "{Шаблон.Конец}", Ложь);
	Вхождения = ирОбщий.НайтиРегулярноеВыражениеЛкс(ТекстРасширенный, "(\+|\-)\s*" + мЛеваяСкобкаПараметра + "(" + шИмя + ")" + мПраваяСкобкаПараметра + "\s*=\s*(.*)\r");
	#Если Сервер И Не Сервер Тогда
	    Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
	#КонецЕсли
	Если Вхождения.Количество() > 0 Тогда
		СпроситьОчиститьПараметры();
		Для Каждого Вхождение Из Вхождения Цикл
			ИмяПараметра = Вхождение.Подгруппы[1];
			СтрокаПараметра = Параметры.Найти(НРег(ИмяПараметра), "НИмя");
			Если СтрокаПараметра = Неопределено Тогда
				СтрокаПараметра = Параметры.Вставить(0);
				СтрокаПараметра.Имя = ИмяПараметра;
				ОбновитьИмяВНижнемРегистре(СтрокаПараметра);
			Иначе
				Параметры.Сдвинуть(СтрокаПараметра, -Параметры.Индекс(СтрокаПараметра));
			КонецЕсли; 
			СтрокаПараметра.ЭтоВариант = Вхождение.Подгруппы[0] = "-";
			СтрокаПараметра.Значение = Вхождение.Подгруппы[2];
			ПроверитьСинтаксис(СтрокаПараметра);
		КонецЦикла;
	Иначе
		// Теперь пробуем найти описание выражения в виде кода 1С
		// {ОписаниеРегулярногоВыражения.Начало} конструктор из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
		// Перем Комментарий1С, Разделитель1С, Идентификатор, ЛитералСтрока1С, СтроковоеВыражение1С, ИмяПараметра, ПрисвоениеСтроковогоЗначения;
		// {Шаблон.Начало}
		// + <Комментарий1С> = //[^\n]*\n
		// + <Разделитель1С> = (?:<Комментарий1С>|\s|^|$)
		// + <Идентификатор> = (?:[_ЁА-ЯA-Z][_ЁА-ЯA-Z0-9]*)
		// + <ЛитералСтрока1С> = "(?:(?:"")|[^"\n])*(?:<Разделитель1С>*\|(?:(?:"")|[^"\n])*)*(?:"|$)
		// + <СтроковоеВыражение1С> = (<ЛитералСтрока1С>(?:\s*\+\s*(?:<ЛитералСтрока1С>|<Идентификатор>))*)
		// + <ИмяПараметра> = (<Идентификатор>)
		// + <ПрисвоениеСтроковогоЗначения> = <ИмяПараметра>\s*=\s*<СтроковоеВыражение1С>\s*;
		// {Шаблон.Конец}
		Комментарий1С = "//[^\n]*\n";
		Разделитель1С = "(?:" + Комментарий1С + "|\s|^|$)";
		Идентификатор = "(?:[_ЁА-ЯA-Z][_ЁА-ЯA-Z0-9]*)";
		ЛитералСтрока1С = """(?:(?:"""")|[^""\n])*(?:" + Разделитель1С + "*\|(?:(?:"""")|[^""\n])*)*(?:""|$)";
		СтроковоеВыражение1С = "(" + ЛитералСтрока1С + "(?:\s*\+\s*(?:" + ЛитералСтрока1С + "|" + Идентификатор + "))*)";
		ИмяПараметра = "(" + Идентификатор + ")";
		ПрисвоениеСтроковогоЗначения = "" + ИмяПараметра + "\s*=\s*" + СтроковоеВыражение1С + "\s*;";
		// {ОписаниеРегулярногоВыражения.Конец}
		Вхождения = ирОбщий.НайтиРегулярноеВыражениеЛкс(Текст, ПрисвоениеСтроковогоЗначения);
		#Если Сервер И Не Сервер Тогда
		    Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
		#КонецЕсли
		Если Вхождения.Количество() > 0 Тогда
			СпроситьОчиститьПараметры();
			Для каждого Вхождение Из Вхождения Цикл
				ИмяПараметра = Вхождение.Подгруппы[0];
				ПрисвоенноеЗначение = Вхождение.Подгруппы[1];
				// {ОписаниеРегулярногоВыражения.Начало} конструктор из подсистемы "Инструменты разработчика" (http://devtool1c.ucoz.ru)
				// Перем Комментарий1С, Разделитель1С, Идентификатор, ЛитералСтрока1С, СтроковоеВыражение1С;
				// {Шаблон.Начало}
				// + <Комментарий1С> = //[^\n]*\n
				// + <Разделитель1С> = (?:<Комментарий1С>|\s|^|$)
				// + <Идентификатор> = ([_ЁА-ЯA-Z][_ЁА-ЯA-Z0-9]*)
				// + <ЛитералСтрока1С> = ("(?:(?:"")|[^"\n])*(?:<Разделитель1С>*\|(?:(?:"")|[^"\n])*)*(?:"|$))
				// + <СтроковоеВыражение1С> = <ЛитералСтрока1С>|\s*\+\s*|<Идентификатор>
				// {Шаблон.Конец}
				Комментарий1С = "//[^\n]*\n";
				Разделитель1С = "(?:" + Комментарий1С + "|\s|^|$)";
				Идентификатор = "([_ЁА-ЯA-Z][_ЁА-ЯA-Z0-9]*)";
				ЛитералСтрока1С = "(""(?:(?:"""")|[^""\n])*(?:" + Разделитель1С + "*\|(?:(?:"""")|[^""\n])*)*(?:""|$))";
				СтроковоеВыражение1С = "" + ЛитералСтрока1С + "|\s*\+\s*|" + Идентификатор + "";
				// {ОписаниеРегулярногоВыражения.Конец}
				Вхождения = ирОбщий.НайтиРегулярноеВыражениеЛкс(ПрисвоенноеЗначение, СтроковоеВыражение1С);
				ВыражениеПараметра = "";
				Для каждого Вхождение Из Вхождения Цикл
					ЛитералСтрока1С = Вхождение.Подгруппы[0];
					Идентификатор = Вхождение.Подгруппы[1];
					Если ЛитералСтрока1С <> Неопределено Тогда
						ВыражениеПараметра = ВыражениеПараметра + ирОбщий.СтрокаИзВыраженияВстроенногоЯзыкаЛкс(ЛитералСтрока1С);
					ИначеЕсли Идентификатор <> Неопределено Тогда
						ВыражениеПараметра = ВыражениеПараметра + мЛеваяСкобкаПараметра + Идентификатор + мПраваяСкобкаПараметра;
					КонецЕсли; 
				КонецЦикла;
				СтрокаПараметра = Параметры.Найти(НРег(ИмяПараметра), "НИмя");
				Если СтрокаПараметра = Неопределено Тогда
					СтрокаПараметра = Параметры.Вставить(0);
					СтрокаПараметра.Имя = ИмяПараметра;
					ОбновитьИмяВНижнемРегистре(СтрокаПараметра);
				Иначе
					Параметры.Сдвинуть(СтрокаПараметра, -Параметры.Индекс(СтрокаПараметра));
				КонецЕсли; 
				СтрокаПараметра.Значение = ВыражениеПараметра;
				ПроверитьСинтаксис(СтрокаПараметра);
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли;
	Если Вхождения.Количество() = 0 Тогда
		Сообщить("В буфере обмена не найдено описания выражения");
		Возврат;
	КонецЕсли; 
	ЭтаФорма.Модифицированность = Истина;
	УстановитьТекущуюСтрокуПараметра();
	
КонецПроцедуры

Процедура СпроситьОчиститьПараметры()
	
	Ответ = Вопрос("Очистить текущие параметры?", РежимДиалогаВопрос.ДаНет,, КодВозвратаДиалога.Да);
	Если Ответ = КодВозвратаДиалога.Да Тогда
		Если ПроверитьСохранитьПолноеВыражение() Тогда
			ОчиститьПараметры();
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура ДоступныеПараметрыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ОформитьСтрокуПараметраОбщее(ОформлениеСтроки);
	Если ДанныеСтроки.Использован Тогда
		ОформлениеСтроки.ЦветФона = WebЦвета.СветлоЖелтый;
	КонецЕсли;
	ОформлениеСтроки.Ячейки.Имя.УстановитьТекст(мЛеваяСкобкаПараметра + ДанныеСтроки.Имя + мПраваяСкобкаПараметра);
	
КонецПроцедуры

Процедура ОформитьСтрокуПараметраОбщее(Знач ОформлениеСтроки)
	
	Если Не ОформлениеСтроки.ДанныеСтроки.Корректно Тогда
		ОформлениеСтроки.ЦветТекста = WebЦвета.Красный;
	КонецЕсли;

КонецПроцедуры

Процедура МногострочныйПриИзменении(Элемент)
	
	ОбновитьПроверочныйТекст();
	
КонецПроцедуры

Процедура ИгнорироватьРегистрПриИзменении(Элемент)
	
	ОбновитьПроверочныйТекст();

КонецПроцедуры

Процедура ОбновитьПроверочныйТекстОтложенно()
	
	ОбновитьПроверочныйТекст(Ложь);
	
КонецПроцедуры

Процедура ПроверочныйТекстonkeypress(Элемент, pEvtObj)
	
	Если АвтообновлениеПроверочногоТекста Тогда
		ПодключитьОбработчикОжидания("ОбновитьПроверочныйТекстОтложенно", 1, Истина);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КП_ПроверочныйТекстОткрытьТаблицуРезультатов(Кнопка)
	
	Если Не ЗначениеЗаполнено(РазвернутоеВыражение) Тогда
		Возврат;
	КонецЕсли; 
	Текст = ПроверочныйТекст();
	Вхождения = ирОбщий.НайтиРегулярноеВыражениеЛкс(Текст, РазвернутоеВыражение,,, ИгнорироватьРегистр, Многострочный, Ложь);
	#Если Сервер И Не Сервер Тогда
		Вхождения = Обработки.ирПлатформа.Создать().ВхожденияРегулярногоВыражения;
	#КонецЕсли
	Если ТипЗнч(Вхождения) = Тип("Строка") Тогда
		Возврат;
	КонецЕсли; 
	ирОбщий.ОткрытьЗначениеЛкс(Вхождения);
	
КонецПроцедуры

ирОбщий.ИнициализироватьФормуЛкс(ЭтаФорма, "Обработка.ирКонструкторРегулярногоВыражения.Форма.Форма");
мПлатформа = ирКэш.Получить();
шИмя = мПлатформа.шИмя;
RegExp = мПлатформа.RegExp;
RegExpLocal = мПлатформа.RegExp2;
мЛеваяСкобкаПараметра = "<";
мПраваяСкобкаПараметра = ">";
ШаблонИмениПараметра = "шаблон";
мРасширениеФайла = "rep";
мОписаниеРасширенияФайла = "Описание регулярного выражения";
мНайденныеГруппы = Новый ТаблицаЗначений;
мНайденныеГруппы.Колонки.Добавить("Номер");
мНайденныеГруппы.Колонки.Добавить("Позиция");
мНайденныеГруппы.Колонки.Добавить("Длина");
мНайденныеГруппы.Колонки.Добавить("Значение");
мНайденныеГруппы.Колонки.Добавить("ПозицияПодгруппы");
мНайденныеГруппы.Колонки.Добавить("ДлинаПодгруппы");
мНайденныеГруппы.Колонки.Добавить("Подстрока", Новый ОписаниеТипов("СписокЗначений"));
АвтообновлениеПроверочногоТекста = Истина;
Автовыделение = Истина;
ПереносСлов = Истина;
мСтруктураВосстановления = ирОбщий.ПолучитьСтруктуруВосстановленияКонсолиЛкс("irRegexpConstructor");
